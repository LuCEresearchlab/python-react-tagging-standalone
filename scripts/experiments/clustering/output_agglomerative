data_agglomerative/experiment_q00_clean_answers_full.json
[[{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.86415123  0.78567446  0.16671958  0.1055112   0.          0.43924022
  0.26971171  0.37861507  0.10909548  0.84708892  0.43231207  0.10830876
 -0.15191849 -0.17667277  0.43691422 -0.08170958  0.43546104  0.56579267
  0.04721208  0.63842686 -0.19105191  0.45126341  0.65536655  0.
  0.80582321 -0.00603379 -0.02634737  0.09641194  0.19280873 -0.10047663
  0.15254908 -0.04423643  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.24866701525564947
min: -0.19105190699461527 arg: 20
std: 0.31490576327288916


data_agglomerative/experiment_q00_clean_answers_only_lemma.json
[[{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}]]
silhouette scores
[ 0.71511465  0.57585095  0.12880572 -0.14895021  0.          0.10121308
  0.1897864   0.40985221  0.15370259  0.71511465  0.34254195  0.08276271
 -0.0324656   0.15752146 -0.09188927 -0.18659705  0.00207294  0.22385718
  0.14139765 -0.23495085 -0.01373639  0.16136486  0.72281816 -0.28619045
  0.65641673 -0.04732858 -0.13753149  0.0406696   0.3097024   0.02569298
  0.41653726  0.12927914 -0.02819022]
max: 0.7228181599071285 arg: 22
mean: 0.15740136873888724
min: -0.2861904515577551 arg: 23
std: 0.2754581085129156


data_agglomerative/experiment_q00_clean_answers_only_lowercase.json
[[{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}]]
silhouette scores
[ 1.          0.33906622  0.31147198  0.3896024   0.50762669  0.02635475
  0.34088596  0.23057421  0.0578719   1.          0.12473275 -0.12188111
  0.23482722 -0.07891885 -0.18588596  0.15925534  0.1153429   0.1278618
 -0.03349541  0.1881989   0.26717071  0.23552708  0.54734939  0.23899027
  0.49019061 -0.01221678  0.07153584  0.31626339  0.34077365  0.36530942
 -0.18629615 -0.0971158  -0.03592121]
max: 1.0 arg: 0
mean: 0.22045612409224455
min: -0.18629615021842535 arg: 30
std: 0.27705564275125366


data_agglomerative/experiment_q00_clean_answers_only_stopwords.json
[[{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.86415123  0.78567446  0.17083764  0.09977374  0.          0.42562068
  0.22836134  0.31618471  0.08510531  0.84708892  0.43231207  0.10629846
 -0.1462578  -0.1588197   0.43691422 -0.07601636  0.43546104  0.56579267
  0.04721208  0.63842686 -0.1695268   0.39615517  0.65536655  0.
  0.80582321 -0.00603379 -0.03453565  0.09641194  0.19280873 -0.10238857
  0.00505768 -0.00428257  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.24057507401355163
min: -0.16952680138214796 arg: 20
std: 0.31310501650045935


data_agglomerative/experiment_q00_clean_answers_stopwords_lemma.json
[[{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.86415123  0.78567446  0.16671958  0.1055112   0.          0.43924022
  0.26971171  0.38242702  0.10909548  0.84708892  0.43231207  0.10830876
 -0.15191849 -0.17667277  0.43691422 -0.08170958  0.43546104  0.56579267
  0.04721208  0.63842686 -0.19105191  0.41529509  0.65536655  0.
  0.80582321 -0.00603379 -0.02634737  0.09641194  0.19280873 -0.10047663
  0.104884   -0.05229731  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.24600391442239436
min: -0.19105190699461527 arg: 20
std: 0.31508435247412653


data_agglomerative/experiment_q00_raw.json
[[{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}]]
silhouette scores
[ 1.          0.24294385  0.09838997 -0.19785707  0.          0.11874415
  0.20971934  0.34821627  0.11226698  1.          0.42506516  0.06669354
 -0.02926467  0.19203349  0.08103834 -0.17809382 -0.32395339 -0.10293765
 -0.06257275 -0.10649304  0.15762382  0.06163966  0.62141993 -0.28069784
  0.40785411 -0.07968703 -0.12220911  0.18955195  0.32474266  0.00228989
  0.43765285  0.10514986 -0.12265801]
max: 1.0 arg: 0
mean: 0.1392912561585287
min: -0.32395338664574835 arg: 16
std: 0.3060862636352918


data_agglomerative/experiment_q01_clean_answers_full.json
[[{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}]]
silhouette scores
[ 0.40177899  0.11602146  0.12877665  0.24562541 -0.10347547  0.31418446
  0.06740865  0.08642533  0.0617949   0.          0.39016939  0.13813291
  0.29810868  0.30205169  0.15662128  0.35060787  0.01469806  0.33313033
  0.45921927  0.46926135  0.27965573  0.2947947   0.30344458  0.
  0.02621827  0.39589877 -0.14471378 -0.09458149  0.20453536  0.16135813
  0.44027703  0.05825342 -0.20472913]
max: 0.46926134922167567 arg: 19
mean: 0.18033190161182874
min: -0.20472912741514177 arg: 32
std: 0.18229044225718866


data_agglomerative/experiment_q01_clean_answers_only_lemma.json
[[{'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}]]
silhouette scores
[ 0.97852023  0.12881623  0.22768634 -0.11455951  0.01745801  0.31715221
  0.71843327  0.09237417  0.14484753  0.26215487  0.97833874  0.48151492
  0.06190091  0.37117582  0.17023859  0.14914149  0.33621628  0.4006515
  0.07864541  0.48346591  0.281565    0.45270251  0.2204876  -0.02637557
  0.39763011  0.28816637  0.03241982  0.03077296 -0.06812383 -0.03504867
  0.41838512  0.0513893   0.26897391]
max: 0.9785202332115195 arg: 0
mean: 0.2605187138715563
min: -0.11455950938188457 arg: 3
std: 0.2606823200151062


data_agglomerative/experiment_q01_clean_answers_only_lowercase.json
[[{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'It is marked with keyword final.', 'idx': 56}]]
silhouette scores
[ 0.57884742 -0.08786626  0.10725621  0.16763097  0.1649873   0.0696047
 -0.09756538  0.17371822 -0.23068988  0.29853403  0.22636922  0.08931978
 -0.34749558  0.02170356  0.31403862  0.32396722  0.16907205  0.09461136
  0.47024523  0.68799396  0.          0.          0.15961303  0.
  0.15590749  0.12914043 -0.17110947  0.30704154  0.08080046  0.05209937
 -0.22647961 -0.18205882  0.        ]
max: 0.6879939615116254 arg: 19
mean: 0.10603748924114015
min: -0.34749558414766035 arg: 12
std: 0.221917261237168


data_agglomerative/experiment_q01_clean_answers_only_stopwords.json
[[{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}]]
silhouette scores
[ 0.2816099   0.32997507  0.12877665  0.26067474 -0.16764184  0.31418446
  0.19460676  0.06080462  0.0617949   0.          0.46829592  0.
  0.40559477  0.40302384  0.15662128  0.37977117 -0.08754578  0.40399457
  0.49662194  0.46926135  0.27965573  0.36267455  0.30344458  0.11482805
 -0.01178885  0.15470438 -0.10545502 -0.17997837  0.14141677  0.16135813
  0.45969005  0.05825342 -0.20472913]
max: 0.4966219422773811 arg: 18
mean: 0.18468177575703892
min: -0.20472912741514177 arg: 32
std: 0.20280893356091023


data_agglomerative/experiment_q01_clean_answers_stopwords_lemma.json
[[{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}]]
silhouette scores
[ 0.40177899  0.06433567  0.12877665  0.24674573 -0.10347547  0.31418446
  0.06740865  0.08642533  0.0617949   0.          0.39016939  0.13813291
  0.29038937  0.30131584  0.15662128  0.35060787  0.01469806  0.29788836
  0.45921927  0.46926135  0.27965573  0.29220069  0.30344458  0.
  0.02621827  0.37887259 -0.14471378 -0.09458149  0.20453536  0.16135813
  0.43739656  0.05825342 -0.20472913]
max: 0.46926134922167567 arg: 19
mean: 0.17679362136110333
min: -0.20472912741514177 arg: 32
std: 0.18132885932221537


data_agglomerative/experiment_q01_raw.json
[[{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}]]
silhouette scores
[ 0.23857868  0.2753563   0.08033932 -0.07600564  0.08487227  0.32548676
  0.24854479  0.32337168  0.10424874  0.          0.33030325  0.12216327
  0.35636675  0.23888769  0.19772125  0.1300043  -0.0658654   0.42383096
  0.38960239  0.40838379  0.26702425  0.44775884 -0.00283857  0.12112846
  0.30297651 -0.03378233  0.13872879  0.09968047  0.39901475 -0.10391025
 -0.11062774  0.07462294  0.33005553]
max: 0.44775883995506965 arg: 21
mean: 0.1838188726620725
min: -0.11062773818637481 arg: 30
std: 0.16443132013382183


data_agglomerative/experiment_q02_clean_answers_full.json
[[{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.61181705 -0.28077977 -0.22432962  0.07961316 -0.17507347  0.1875293
  0.7662601   0.12906425  0.06988472 -0.17871226  0.65569782 -0.14776991
  0.30645636  0.          0.06101368  0.         -0.07836327  0.02258158
  0.03674699  0.47807737  0.          0.153744    0.45021814 -0.08998941
  0.33107445  0.          0.3190434  -0.09897088  0.19333124  0.19071708
  0.15845963 -0.03092663  0.14749869]
max: 0.7662600979032402 arg: 6
mean: 0.12254284265981513
min: -0.2807797702675701 arg: 1
std: 0.2512929713717409


data_agglomerative/experiment_q02_clean_answers_only_lemma.json
[[{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.39178613  0.1508027   0.53193518  0.58128939  0.64464606  0.40335086
 -0.35474435 -0.04083153  0.08530344  0.39776556  0.12559338  0.34806433
 -0.28663694  0.          0.04279759  0.          0.39625926  0.18410326
  0.08867084  0.1904838  -0.44107356  0.20016397  0.07313326  0.29859544
  0.08774161  0.2105579   0.3464591   0.18484575  0.14568659 -0.5283205
  0.45279839  0.36032746  0.14623113]
max: 0.6446460591150398 arg: 4
mean: 0.16417531854294187
min: -0.5283204978559953 arg: 29
std: 0.27118220267936183


data_agglomerative/experiment_q02_clean_answers_only_lowercase.json
[[{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}]]
silhouette scores
[ 0.74951374  0.22125354  0.13306581  0.23943491  0.46135744  0.552107
  0.20651629  0.30202094 -0.26644984 -0.11743585 -0.20948752  0.4204324
  0.41644777  0.46057803  0.          0.31874685  0.67716651  0.01315906
 -0.28911927 -0.02146899 -0.18829118 -0.3359945  -0.04321722  0.13051375
 -0.0895836   0.          0.27238985  0.18731279  0.46461521 -0.2263321
  0.1069583  -0.26904892 -0.15117604]
max: 0.7495137380959436 arg: 0
mean: 0.12502985247273313
min: -0.3359945034689187 arg: 21
std: 0.29207361193139725


data_agglomerative/experiment_q02_clean_answers_only_stopwords.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.53707452 -0.10314419  0.40521373  0.06541782  0.49856132 -0.03124415
  0.55662882  0.2574929   0.1709099  -0.47382254  0.66638695  0.1381955
  0.11351868  0.          0.16703032  0.15203415  0.04322476  0.03772201
 -0.33154135  0.80022716 -0.14124529 -0.01952915  0.46070478 -0.18714568
 -0.02210403  0.08746088  0.32943086 -0.24425471  0.42103539 -0.13777718
  0.38845065  0.28610716 -0.0316163 ]
max: 0.8002271592232116 arg: 19
mean: 0.14725465766014087
min: -0.4738225408115939 arg: 9
std: 0.2905567644635372


data_agglomerative/experiment_q02_clean_answers_stopwords_lemma.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.55400373 -0.17641421  0.42891035  0.170574    0.50853457 -0.07403142
  0.57400543  0.03827306  0.21465924 -0.24884942  0.64054399  0.11403087
  0.49747214  0.          0.13945375  0.         -0.06154301 -0.12739184
 -0.37124919  0.85621941  0.          0.153744    0.46844213 -0.16788223
 -0.0350678  -0.0277995   0.1622745  -0.36133586  0.25782656 -0.16443569
  0.33036487  0.30698139  0.15947561]
max: 0.8562194096318622 arg: 19
mean: 0.14423604375849647
min: -0.3712491901446941 arg: 18
std: 0.2965085272746911


data_agglomerative/experiment_q02_raw.json
[[{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}]]
silhouette scores
[ 0.335674   -0.26418758  0.56163413  0.30741202  0.56115457  0.29256387
 -0.40257153  0.00666032  0.04583044  0.22083375  0.02232821  0.11339708
  0.41048401 -0.0850485  -0.00564833  0.          0.32671132  0.18134574
 -0.08149513 -0.02333243 -0.14338501 -0.15891716  0.15512874  0.35744044
  0.05269324  0.14631503  0.2635517   0.12255078  0.15359548 -0.26351798
  0.3017286   0.24601828 -0.01963568]
max: 0.5616341324525107 arg: 2
mean: 0.1132518905640056
min: -0.40257153231345216 arg: 6
std: 0.22494680981530116


data_agglomerative/experiment_q03_clean_answers_full.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}]]
silhouette scores
[-0.35178081  0.06471453  0.55158963  0.11918303  0.16931005  0.23076206
 -0.14529672 -0.01707469  0.60763099 -0.07545583 -0.12940826  0.
  0.36676949 -0.07490085  0.12431641 -0.15981846  0.21076636  0.17694585
  0.10214769  0.61933321  0.1388747   0.09007086 -0.03107754 -0.13678552
  0.16459656  0.22581254  0.04896638  0.27010586  0.30102145  0.21643411
  0.42772696  0.14155733]
max: 0.6193332134625416 arg: 19
mean: 0.13271991781708475
min: -0.35178080998503286 arg: 0
std: 0.2214672994496668


data_agglomerative/experiment_q03_clean_answers_only_lemma.json
[[{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[ 0.07946568  0.07866871  0.88157936  0.12822652  0.17275602  0.32822234
  0.4529718   0.05556256  0.50918396 -0.12956611  0.22586979  0.14929185
  0.11445131  0.59929442  0.          0.07510378  0.8133129  -0.01388202
 -0.03458616  0.65951959 -0.082694    0.53697999 -0.19856842 -0.08529233
  0.05915235  0.          0.04221871  0.30535309  0.86003592  0.
  0.55679046 -0.04372943]
max: 0.8815793637269549 arg: 2
mean: 0.2217403954394233
min: -0.1985684151342764 arg: 22
std: 0.30081452612771004


data_agglomerative/experiment_q03_clean_answers_only_lowercase.json
[[{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'Immutable object has no mutators', 'idx': 132}]]
silhouette scores
[ 0.0089564   0.5977295  -0.09917606  0.14102127  0.31927039  0.18553968
  0.23055727  0.48460797 -0.00158888  0.39008555  0.45583813 -0.22281293
  0.57481043 -0.10895386  0.11128803  0.36407235  0.07409792 -0.20947441
  0.02173012  0.28757497  0.49726829  0.22739464 -0.08835884 -0.16004377
  0.52897959  0.36998128 -0.13778243  0.32120305  0.14039005  0.
  0.22618422  0.11472736]
max: 0.5977294951193164 arg: 1
mean: 0.17640991545892828
min: -0.22281293012324077 arg: 11
std: 0.23718683097588839


data_agglomerative/experiment_q03_clean_answers_only_stopwords.json
[[{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}]]
silhouette scores
[ 0.27355068  0.31007553  0.18021428  0.1923304   0.16571393  0.18975303
  0.31113847  0.02105615 -0.00297454  0.06854533  0.36867003  0.
  0.19998772  0.19145957  0.          0.2001764  -0.3341192   0.16869658
 -0.09562319 -0.17675808  0.17573008  0.30125654  0.07912833  0.02743016
  0.11328734  0.          0.          0.23211175  0.2977817  -0.13196868
  0.40882198  0.31159697]
max: 0.4088219834644726 arg: 30
mean: 0.12647091484541706
min: -0.3341191988711767 arg: 16
std: 0.16703600906144217


data_agglomerative/experiment_q03_clean_answers_stopwords_lemma.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}]]
silhouette scores
[-0.35178081  0.06471453  0.55158963  0.11918303  0.16931005  0.23923275
 -0.14529672 -0.01707469  0.60763099 -0.07545583 -0.12940826  0.
  0.34215666 -0.07490085  0.12431641 -0.15981846  0.21076636  0.15494857
  0.10214769  0.61933321  0.1388747   0.09007086 -0.03107754 -0.11743542
  0.16459656  0.22581254  0.06936703  0.27010586  0.30102145  0.21643411
  0.42772696  0.14155733]
max: 0.6193332134625416 arg: 19
mean: 0.13277027187605916
min: -0.35178080998503286 arg: 0
std: 0.21978876839097075


data_agglomerative/experiment_q03_raw.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}], [{'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}]]
silhouette scores
[ 0.0322999   0.07147275  0.45540117  0.15060777 -0.16612251 -0.14179212
  0.07077398  0.00878444  0.71819694  0.30590009 -0.19725825  0.
  0.          0.59555929  0.          0.85986882  0.05351964  0.84494292
  0.42879848  0.79579514  0.03200629  0.54330811  0.12272919 -0.2301588
 -0.10445124  0.07665933  0.          0.17932999  0.88342712  0.
  0.05764085  0.22660066]
max: 0.8834271150671643 arg: 28
mean: 0.20855749773663212
min: -0.23015880397898586 arg: 23
std: 0.3270008179430133


data_agglomerative/experiment_q04_clean_answers_full.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}]]
silhouette scores
[ 0.25503658  0.68269719  0.8037966   0.44743267  0.91234168  0.51501399
  0.03917942  0.33215554  0.26747479 -0.21513136  0.7978516   0.53063688
  0.24797813 -0.22870151  0.26422835 -0.17386318  0.3031589   0.48008245
  0.79923081  0.55400535  0.1019214   0.50590649  0.25662297  0.14173489
  0.22846332  0.52752602  0.36910038  0.67918843  0.27621407  0.03289563
 -0.11991628  0.45174093 -0.46570264]
max: 0.9123416826714926 arg: 4
mean: 0.3212212281047584
min: -0.46570264289630914 arg: 32
std: 0.32533000384773786


data_agglomerative/experiment_q04_clean_answers_only_lemma.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}], [{'data': 'It is not pure as it prints something to the standard output', 'idx': 161}]]
silhouette scores
[ 0.17269251 -0.20196341  0.70309499  0.67559507  0.48019443  0.67149056
 -0.30415785  0.0358645  -0.13147637 -0.54508303  0.48477715  0.08290987
  0.121836    0.23972529 -0.03517056  0.60396679 -0.04469971 -0.088237
 -0.23204165 -0.09690687 -0.18301439  0.06508499  0.75763969  0.00390803
  0.          0.53558468 -0.15304902  0.22686212 -0.07361367  0.59703862
  0.56171448  0.19402105 -0.14606218]
max: 0.7576396896870994 arg: 22
mean: 0.1508643976579135
min: -0.5450830302355504 arg: 9
std: 0.34036938940995043


data_agglomerative/experiment_q04_clean_answers_only_lowercase.json
[[{'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'It produces a side effect.', 'idx': 158}], [{'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.30029694  0.52769432  0.50034488 -0.05735798 -0.18315049  0.43445333
  0.1068791   0.09433428  0.01715373 -0.19380689  0.25599286  0.26738092
  0.45084886  0.06519049  0.38356424  0.19171691 -0.17358046  0.32403224
  0.55376843  0.35204304  0.08677844  0.56736053  0.11120901  0.3638007
  0.21167889  0.54634403 -0.10034702 -0.13318497  0.31152878  0.26968636
  0.49819531  0.52515766  0.63245829]
max: 0.6324582928525164 arg: 32
mean: 0.24571105318453304
min: -0.19380689304585322 arg: 9
std: 0.24268519191052218


data_agglomerative/experiment_q04_clean_answers_only_stopwords.json
[[{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}]]
silhouette scores
[ 0.57149226  0.67422216  0.75977059 -0.23302354  0.86569876  0.01188668
 -0.3356884  -0.13160155  0.41917293  0.22549006  0.73421314  0.41224118
  0.77675784  0.03321209  0.36940211 -0.25893028  0.16565195  0.16156205
  0.72890966  0.42701571 -0.19722626  0.27336799  0.44935443 -0.10129426
  0.21204107  0.49981989  0.01112074  0.59428353 -0.19172801  0.15780185
  0.28550079  0.40659959  0.2181284 ]
max: 0.8656987646936162 arg: 4
mean: 0.27258258041316413
min: -0.3356883995887399 arg: 6
std: 0.33398637106573814


data_agglomerative/experiment_q04_clean_answers_stopwords_lemma.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}]]
silhouette scores
[ 0.25503658  0.68269719  0.8037966   0.44743267  0.91234168  0.51501399
  0.03917942  0.33215554  0.26747479 -0.21513136  0.7978516   0.53063688
  0.24797813 -0.22870151  0.26422835 -0.17386318  0.3031589   0.48008245
  0.79923081  0.55400535  0.1019214   0.50590649  0.25662297  0.14173489
  0.22846332  0.52752602  0.36910038  0.67918843  0.27621407  0.03289563
 -0.11991628  0.45174093 -0.46570264]
max: 0.9123416826714926 arg: 4
mean: 0.3212212281047584
min: -0.46570264289630914 arg: 32
std: 0.32533000384773786


data_agglomerative/experiment_q04_raw.json
[[{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.46983613  0.43098907  0.75088361  0.39379747  0.59370433  0.38688104
 -0.1413064   0.05885832  0.19605588 -0.12955471  0.53600404  0.32490595
 -0.09970896  0.25443698  0.56649194 -0.1035813   0.14890772  0.37491911
  0.5067753   0.40522972  0.25339808  0.40966658  0.05561509  0.00868373
  0.3226729   0.28297834  0.39516602  0.33799707  0.42088927 -0.04075363
  0.30067153  0.41863265  0.40913446]
max: 0.7508836118191318 arg: 2
mean: 0.2878568892863498
min: -0.14130640122015767 arg: 6
std: 0.2240397104128466


data_agglomerative/experiment_q05_clean_answers_full.json
[[{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.42065347  0.26860511  0.37761951  0.20733392 -0.01887701  0.38489944
  0.11629747  0.40502397  0.04568633  0.41323587  0.19489479  0.08629991
  0.15689372  0.17778776  0.00200247  0.26811318 -0.02071885  0.45005442
  0.11877063 -0.02461469  0.          0.1938529   0.3321397   0.18679548
  0.22620876  0.2123171   0.03280943  0.36731292  0.          0.39741176
  0.4357484   0.21437826  0.08046528]
max: 0.45005442356247033 arg: 17
mean: 0.20331519456749506
min: -0.024614687466048356 arg: 19
std: 0.15334613471201297


data_agglomerative/experiment_q05_clean_answers_only_lemma.json
[[{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}]]
silhouette scores
[ 0.51422642 -0.08660618 -0.09432048  0.07487922  0.24564937  0.33957869
  0.13358455  0.33749396  0.33381308 -0.12314307  0.01419587  0.3303426
  0.15445816  0.04868603  0.37170305 -0.18958882  0.24619253  0.17408976
  0.25671163  0.4749951  -0.08604678  0.4704224   0.24440693  0.06335717
  0.16009365  0.18939038  0.25149815  0.31376927  0.          0.16852371
 -0.00264009 -0.15284117  0.4207932 ]
max: 0.5142264219031082 arg: 0
mean: 0.16962631094739816
min: -0.1895888198890866 arg: 15
std: 0.19128814845495923


data_agglomerative/experiment_q05_clean_answers_only_lowercase.json
[[{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}]]
silhouette scores
[ 1.          0.29488271  0.41324461  0.16826248  0.43115886  0.61463964
  0.027091    0.20622869 -0.37180143  0.55739363  0.02113904 -0.32474801
  0.17322194 -0.01129017 -0.04827321  0.01834076  0.39335008 -0.12756537
  0.27461261  1.          0.          0.24227136  0.16972854  0.48617497
 -0.24538178  0.13773303  0.48014674 -0.06048472 -0.09275982  0.3639837
  0.39089842  0.59876006 -0.31650655]
max: 1.0 arg: 0
mean: 0.20801369065140238
min: -0.37180142801014504 arg: 8
std: 0.3343449465659841


data_agglomerative/experiment_q05_clean_answers_only_stopwords.json
[[{'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}]]
silhouette scores
[-0.00543596  0.05113502  0.47471839  0.21576532  0.03849922  0.36451845
  0.15502542  0.43473414  0.          0.45314802  0.20329334  0.08989152
  0.1633147   0.18679707 -0.02802855  0.320513    0.03444436  0.46020702
  0.13837746  0.21416674  0.02331915  0.12714597  0.27391202  0.22014723
  0.280241    0.18160824 -0.16455647  0.33356098  0.          0.3584038
  0.14413752 -0.07065059  0.11756856]
max: 0.47471838654901155 arg: 2
mean: 0.17545218448114258
min: -0.1645564673700663 arg: 26
std: 0.16162167321824245


data_agglomerative/experiment_q05_clean_answers_stopwords_lemma.json
[[{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.42065347  0.26860511  0.37761951  0.20733392 -0.01887701  0.38014724
  0.11177819  0.40502397  0.04568633  0.41323587  0.19489479  0.08629991
  0.17949371  0.17778776  0.00200247  0.26811318 -0.02071885  0.45005442
  0.11877063 -0.02461469  0.          0.1938529   0.30399193  0.18679548
  0.23644274  0.2123171   0.03280943  0.36731292  0.          0.39741176
  0.4357484   0.21437826  0.08046528]
max: 0.45005442356247033 arg: 17
mean: 0.20317624670541176
min: -0.024614687466048356 arg: 19
std: 0.152516778697224


data_agglomerative/experiment_q05_raw.json
[[{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}]]
silhouette scores
[ 0.25359974  0.14037413  0.29184066  0.13839405  0.31422189  0.332684
  0.02789634  0.33030026  0.          0.17593028  0.36674323  0.25061098
  0.14944237  0.11818647  0.18506158  0.1805005   0.38866025  0.44303455
  0.2693065  -0.0601366   0.23982967  0.21723352  0.34218489  0.19701398
  0.13611174 -0.18090992  0.00436227  0.35585936  0.         -0.01377546
 -0.05324598  0.09799004 -0.09793722]
max: 0.4430345465085248 arg: 17
mean: 0.16792024426537722
min: -0.1809099213272568 arg: 25
std: 0.1549909374474683


data_agglomerative/experiment_q06_clean_answers_full.json
[[{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}]]
silhouette scores
[ 0.36564768  0.07948113  0.33708041 -0.00571326  0.0702938   0.41772614
  0.62852516  0.24793133 -0.11908775  0.24738138  0.23436051  0.11307481
 -0.13569338 -0.03883349  0.24046829  0.2300743   0.50412969  0.52638663
  0.21511633  0.21917858 -0.19781585  0.13085992  0.10600487  0.37202014
  0.34122142  0.4785301   0.51029279 -0.10527393  0.15074388 -0.28041968
 -0.12751094  0.25911195 -0.02289848]
max: 0.6285251569522028 arg: 6
mean: 0.18158771044934016
min: -0.28041968257364147 arg: 29
std: 0.22756068148513445


data_agglomerative/experiment_q06_clean_answers_only_lemma.json
[[{'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}]]
silhouette scores
[ 0.19434201 -0.00677906 -0.0696962  -0.42170795 -0.15456684  0.20256095
  0.58835138  0.00941052 -0.07529001  0.49659068  0.53862596 -0.10661012
  0.14400832  0.5414658   0.43722266 -0.1706649   0.42365489  0.22600529
 -0.0364193  -0.18586818  0.53052751 -0.02628709  0.1384457   0.3045241
  0.42924912 -0.15518243  0.0153483  -0.07267876  0.31871088  0.00956084
 -0.00142383  0.01588004  0.12711963]
max: 0.5883513780494314 arg: 6
mean: 0.12752817848980758
min: -0.421707948733444 arg: 3
std: 0.25674985828994373


data_agglomerative/experiment_q06_clean_answers_only_lowercase.json
[[{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}], [{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'It depends on the current state of the object.', 'idx': 225}], [{'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'return a non-local variable', 'idx': 226}]]
silhouette scores
[ 0.06521369 -0.14179867  0.43755315  0.44555993  0.34374763  0.59230611
  0.20139456  0.34907303  0.06834475  0.11278723  0.51844398  0.227868
  0.02326366 -0.00990764  0.16840933 -0.02010683 -0.10415364  0.15309726
  0.54541446  0.3100191   0.          0.          0.45648455  0.46313818
  0.3562498   0.17967557 -0.03961144  0.23051198  0.23934343  0.43981945
  0.          0.45270168 -0.26293318]
max: 0.5923061093911935 arg: 5
mean: 0.2061184576877045
min: -0.26293318107054975 arg: 32
std: 0.22024056458605398


data_agglomerative/experiment_q06_clean_answers_only_stopwords.json
[[{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.07777452  0.28326883  0.14991878  0.03421978 -0.05526067 -0.26745938
 -0.29455653  0.17258651  0.20227143  0.07164256  0.28914159 -0.02094911
  0.29480042  0.37177634  0.49485522  0.24977112  0.06572179  0.00378829
  0.1822812   0.36578328 -0.12990094  0.43056259 -0.10847941  0.3596842
  0.3601805   0.20020965  0.20575724  0.31394625  0.17776569  0.22661798
  0.          0.19889002 -0.0812922 ]
max: 0.49485522437766993 arg: 14
mean: 0.14622174370514326
min: -0.29455652929394505 arg: 6
std: 0.1916894040394881


data_agglomerative/experiment_q06_clean_answers_stopwords_lemma.json
[[{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}]]
silhouette scores
[ 0.36564768  0.07948113  0.33708041 -0.00571326  0.0702938   0.41772614
  0.62852516  0.24793133 -0.11908775  0.24738138  0.23436051  0.11307481
 -0.13569338 -0.03883349  0.24046829  0.2300743   0.50412969  0.52638663
  0.21511633  0.21917858 -0.19781585  0.13085992  0.10600487  0.37202014
  0.34122142  0.4785301   0.51029279 -0.10527393  0.15074388 -0.28041968
 -0.12751094  0.25911195 -0.02289848]
max: 0.6285251569522028 arg: 6
mean: 0.18158771044934016
min: -0.28041968257364147 arg: 29
std: 0.22756068148513445


data_agglomerative/experiment_q06_raw.json
[[{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}]]
silhouette scores
[-0.08404365 -0.24825229 -0.24369307 -0.52354954 -0.0670412   0.14159679
 -0.34300197  0.65303456 -0.02684296  0.27368695  0.17249373  0.10003884
  0.41458433  0.48374304  0.36474378  0.78120401  0.00338315  0.61714237
  0.         -0.20043661  0.28955398  0.38094088  0.08166352  0.57547343
  0.32770546 -0.33743024  0.08021678  0.13869207  0.10319428  0.11695893
 -0.25370557  0.06654537 -0.39063662]
max: 0.781204006079927 arg: 15
mean: 0.10448371299505892
min: -0.5235495420417786 arg: 3
std: 0.318883250133609


data_agglomerative/experiment_q07_clean_answers_full.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}]]
silhouette scores
[ 5.76060715e-01  3.08077857e-01  9.66538975e-02 -4.05249877e-02
  1.02192057e-01  0.00000000e+00  0.00000000e+00  2.45873243e-01
  2.49075593e-01  1.42088023e-01  6.62947695e-01 -7.51494054e-02
  2.34260650e-02 -3.84743094e-02  3.05434105e-02  2.77027392e-01
  7.16110491e-01  1.57169322e-01 -2.66834919e-01 -3.29505216e-01
  1.56742098e-01 -1.42731114e-01  2.68145144e-01  4.44071508e-02
  8.79157413e-02 -3.12806241e-04  7.45966593e-02  1.58438520e-01
  1.53492719e-02 -1.65478707e-01  2.88594126e-01 -1.58216024e-01
  6.63582513e-01]
max: 0.7161104911831325 arg: 16
mean: 0.1250845302078907
min: -0.32950521636837415 arg: 19
std: 0.24925212296162239


data_agglomerative/experiment_q07_clean_answers_only_lemma.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}], [{'data': 'it should be f()(1)', 'idx': 292}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}, {'data': 'return another function', 'idx': 304}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}]]
silhouette scores
[ 0.50875805  0.18305727  0.08908172  0.          0.54960804  0.
  0.          0.21666305  0.22682218  0.114701    0.56966824  0.21895601
  0.04027535  0.18906835  0.05120612  0.12537521  0.65851515  0.03272519
 -0.06667134 -0.01029438  0.52524153 -0.01606865  0.26623342  0.12127426
  0.07516598  0.23815393  0.14924319  0.34833157  0.04617741 -0.25636851
  0.25178371 -0.06933689  0.66901619]
max: 0.6690161896620515 arg: 32
mean: 0.18322310201165687
min: -0.25636851428924745 arg: 29
std: 0.22189568445393507


data_agglomerative/experiment_q07_clean_answers_only_lowercase.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}]]
silhouette scores
[ 0.05550087  0.55546494  0.04146752  0.23298258  0.40533679 -0.05849426
  0.207343    0.08123518  0.36122021  0.3497875   0.53946245  0.00943683
  0.32079449  0.19400549  0.25637856  0.30125239  0.47615923  0.21188084
  0.09308213  0.48618244  0.11876875  0.32580414  0.21683173  0.18777878
  0.17516482  0.48108395 -0.00141588  0.41647106  0.58515556 -0.09715969
  0.34359097  0.56664401  0.5213117 ]
max: 0.5851555550101158 arg: 28
mean: 0.27153057793104224
min: -0.09715969359755201 arg: 29
std: 0.1915145133638686


data_agglomerative/experiment_q07_clean_answers_only_stopwords.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}]]
silhouette scores
[ 0.59011264  0.31578571  0.08116986 -0.04595634  0.08104046  0.
  0.          0.27546463  0.19344832  0.12999422  0.67717921 -0.04211999
  0.00263384  0.02171505 -0.03265624  0.21442291  0.73458432  0.14080836
 -0.27913197 -0.33108411  0.13383723 -0.1454954   0.2720583   0.04824611
  0.04754788 -0.02753486  0.09709645  0.17388481  0.01113403 -0.18083084
  0.2704024  -0.11209595  0.68505242]
max: 0.7345843188681426 arg: 16
mean: 0.12123374096485753
min: -0.3310841074015257 arg: 19
std: 0.2528116373310097


data_agglomerative/experiment_q07_clean_answers_stopwords_lemma.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}]]
silhouette scores
[ 5.76060715e-01  3.08077857e-01  9.66538975e-02 -4.05249877e-02
  1.02192057e-01  0.00000000e+00  0.00000000e+00  2.45873243e-01
  2.07603493e-01  1.42088023e-01  6.62947695e-01 -6.96298560e-02
  2.07446028e-02 -4.14487889e-02  1.70141056e-02  2.67928748e-01
  7.16110491e-01  1.57169322e-01 -2.66834919e-01 -3.29505216e-01
  1.60590627e-01 -1.42731114e-01  2.63077892e-01  5.84919348e-02
  8.40798198e-02 -3.12806241e-04  8.99728760e-02  1.69929887e-01
  1.53492719e-02 -1.65478707e-01  2.88594126e-01 -1.58216024e-01
  6.63582513e-01]
max: 0.7161104911831325 arg: 16
mean: 0.1242257811197799
min: -0.32950521636837415 arg: 19
std: 0.24848909500997518


data_agglomerative/experiment_q07_raw.json
[[{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}]]
silhouette scores
[ 0.49114643  0.18564222  0.20456162 -0.07876895  0.45761252  0.
  0.          0.28049611  0.17169818  0.11001212  0.57899677  0.36389644
  0.01276806  0.26678047  0.12987227  0.12080217  0.66593537 -0.01993012
 -0.0888721  -0.05074771  0.30150842 -0.02622039  0.          0.16601181
  0.06256432  0.21190091  0.5060395   0.22804268  0.17543148 -0.16948171
  0.25927688 -0.00593403  0.67740924]
max: 0.677409238474177 arg: 32
mean: 0.18752881765736631
min: -0.16948170927381337 arg: 29
std: 0.21876944502210474


data_agglomerative/experiment_q08_clean_answers_full.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Just because', 'idx': 336}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.17432954  0.          0.05362856  0.1448438   0.29182035
  0.02725785  0.14707243  0.48456861  0.1087889  -0.01027581  0.06019832
  0.20015254  0.34905411  0.24440678  0.56771779  0.44367964  0.10036984
 -0.09475726  0.34297889  0.          0.28506967 -0.07518074  0.19208339
 -0.29752889  0.05542746  0.19436672  0.16505053  0.          0.51018071
  0.18713231  0.21327507]
max: 0.5677177893076119 arg: 15
mean: 0.14740787644513553
min: -0.2975288858203159 arg: 24
std: 0.19489696084551944


data_agglomerative/experiment_q08_clean_answers_only_lemma.json
[[{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'Just because', 'idx': 336}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.16064656  0.20806202  0.14332048 -0.04372663  0.23859461
 -0.08231514  0.62979976  0.54508685  0.15213283  0.13421837  0.10187584
  0.4411722   0.19048365  0.07298532  0.58346881  0.4423339   0.13185515
 -0.01015518  0.24943944  0.38662728 -0.42295253  0.13242771  0.43000951
 -0.15423741  0.04172507  0.09241852  0.28983285  0.         -0.13774513
  0.30810057 -0.14256739]
max: 0.6297997638734284 arg: 7
mean: 0.14973827393815253
min: -0.42295252557985413 arg: 21
std: 0.23836885244513564


data_agglomerative/experiment_q08_clean_answers_only_lowercase.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': "it's the regular expression", 'idx': 308}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[-0.15283778  0.11174383 -0.2030791   0.04856775  0.32964487  0.06921149
  0.39136732 -0.24112221  0.18461204 -0.15624945 -0.20070508 -0.17703108
  0.20430741  0.146368    0.23755835  0.80433616  0.42633936  0.08049832
 -0.04073555  0.2828643   0.06736747  0.06571514  0.30636765  0.1475902
  0.29014965  0.23260673  0.50778422 -0.1158825   0.          0.49141824
  0.18573973 -0.00842708]
max: 0.8043361628106027 arg: 15
mean: 0.13487776328930587
min: -0.24112220744642335 arg: 7
std: 0.23709082053956243


data_agglomerative/experiment_q08_clean_answers_only_stopwords.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Just because', 'idx': 336}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.15259519  0.30402001  0.2046927   0.01113217  0.27639267
  0.06314527  0.22997985  0.54019066  0.40667465  0.06699633  0.12601774
  0.18120836  0.32487095  0.11258936  0.45316097  0.25441032  0.14311857
  0.12100604  0.32019813  0.          0.53074678 -0.18325385  0.05310174
  0.30619     0.16365537  0.3266322   0.35144047  0.          0.46522675
  0.14635057  0.23285982]
max: 0.5401906638657533 arg: 8
mean: 0.1993799815813197
min: -0.18325385228697422 arg: 22
std: 0.1782013155788653


data_agglomerative/experiment_q08_clean_answers_stopwords_lemma.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Just because', 'idx': 336}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.17432954  0.          0.05362856  0.14397086  0.29182035
  0.04238357  0.14707243  0.48456861  0.11733575 -0.01027581  0.05293992
  0.20015254  0.34549831  0.24440678  0.56771779  0.44367964  0.10036984
 -0.09475726  0.34297889  0.          0.29945502 -0.07518074  0.19208339
 -0.29752889  0.05542746  0.19436672  0.17307368  0.          0.51018071
  0.18713231  0.21327507]
max: 0.5677177893076119 arg: 15
mean: 0.14848268624599392
min: -0.2975288858203159 arg: 24
std: 0.1949280318191869


data_agglomerative/experiment_q08_raw.json
[[{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'Just because', 'idx': 336}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.          0.25426689  0.11856585  0.43749263  0.          0.17822707
 -0.04409815  0.29224985  0.15723711  0.74649144  0.18489216  0.0993278
 -0.11956669 -0.01973692  0.05916134  0.11055046 -0.13900678  0.03544867
  0.28734845  0.11286628  0.22366083  0.52666644 -0.02518266  0.26072182
  0.13158096  0.13616921  0.22082462  0.54203469  0.          0.07719948
  0.13716737  0.30619096]
max: 0.7464914432650306 arg: 9
mean: 0.1652734750952845
min: -0.1390067789973396 arg: 16
std: 0.19206259427609948


data_agglomerative/experiment_q09_clean_answers_full.json
[[{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[ 0.14360739 -0.27819887  0.06632086  0.18394164 -0.25367854  0.2326453
  0.23651517  0.07222661  0.32371394  0.31620544 -0.22930932  0.12417285
 -0.2796361   0.32370933 -0.05138126  0.16789989  0.22130726  0.03037912
  0.03401674  0.17048625  0.27019062  0.17048625  0.          0.04042598
  0.16266609 -0.30803604  0.15927323 -0.34163264  0.3502504  -0.21447998
  0.07819965  0.          0.3164632 ]
max: 0.35025040307399224 arg: 28
mean: 0.06784092224939854
min: -0.34163263866630994 arg: 27
std: 0.20396011036407022


data_agglomerative/experiment_q09_clean_answers_only_lemma.json
[[{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}]]
silhouette scores
[ 0.2109947   0.         -0.01236515  0.32053657 -0.21913936  0.24112345
 -0.01839146 -0.03020255  0.35774477  0.30032164 -0.24664682  0.07741219
  0.05307272 -0.16488652 -0.09786084  0.0674834   0.39139042  0.1125146
 -0.09589821  0.08693263  0.36484363 -0.21637928  0.06540437  0.16064582
  0.05766091 -0.3273936   0.07619894 -0.30926839  0.          0.
  0.1178491   0.09560083  0.46406787]
max: 0.4640678743340882 arg: 32
mean: 0.05707170957590256
min: -0.3273936024667949 arg: 25
std: 0.199957956644526


data_agglomerative/experiment_q09_clean_answers_only_lowercase.json
[[{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'It returns the wrapped function.', 'idx': 369}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}]]
silhouette scores
[-0.65412027  0.24246993  0.50568899 -0.08570203  0.3463534   0.23539489
  1.          0.25704187  0.23842765  0.74225889  0.38715723  0.4832986
  0.13969294 -0.40895513  0.63034067  1.          0.64063584  0.64298606
  0.35621144  0.77143763  0.24908743  0.75881179  0.10529156  0.39891238
 -0.23195892  0.2668231   0.         -0.36029075  0.71714714  0.55239058
 -0.09070043  0.51967485  0.27133422]
max: 1.0 arg: 6
mean: 0.32203459190024697
min: -0.654120271023774 arg: 0
std: 0.38629076436829285


data_agglomerative/experiment_q09_clean_answers_only_stopwords.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}]]
silhouette scores
[ 0.25968293 -0.19487807 -0.1715378   0.00303966  0.24987112  0.00346081
  0.18671365 -0.03154851  0.23958656  0.20605728  0.         -0.07278705
 -0.07276321  0.28009694  0.          0.02673521  0.43640072  0.06331091
 -0.05694037  0.53017235  0.41845486  0.55461642 -0.25345147 -0.0916634
 -0.04902859 -0.24116036  0.17704215 -0.39220533  0.27458299 -0.14446055
 -0.02280944  0.          0.04120372]
max: 0.5546164240308952 arg: 21
mean: 0.0653270950952657
min: -0.3922053298973447 arg: 27
std: 0.22430223575505126


data_agglomerative/experiment_q09_clean_answers_stopwords_lemma.json
[[{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[ 0.14360739 -0.27819887  0.06525235  0.18129563 -0.25017619  0.2326453
  0.12712333  0.07222661  0.32371394  0.31620544 -0.22930932  0.14986854
 -0.20886667  0.32370933 -0.05547783  0.11913515  0.22130726  0.03037912
  0.03401674  0.11891353  0.27019062  0.11891353  0.          0.04042598
  0.16266609 -0.30803604  0.15927323 -0.34163264  0.32173588 -0.17282853
  0.07819965  0.          0.3164632 ]
max: 0.3237139410978536 arg: 8
mean: 0.06311338633196238
min: -0.34163263866630994 arg: 27
std: 0.19418343450582867


data_agglomerative/experiment_q09_raw.json
[[{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}]]
silhouette scores
[ 0.3102622   0.05352548  0.04441121  0.22011379  0.18358492  0.33383643
 -0.03095557 -0.09422413  0.14638855  0.007673   -0.12940133  0.27422471
 -0.11859869  0.         -0.18415032  0.06886557  0.54990356  0.19978175
  0.          0.15027033  0.54156851  0.07142062 -0.12195436 -0.05957132
 -0.01911853 -0.21860409 -0.19191169  0.         -0.25981468  0.03684056
  0.21849944  0.21166989  0.39712707]
max: 0.5499035589778761 arg: 16
mean: 0.07853523855683144
min: -0.25981467648270185 arg: 28
std: 0.2024814816881057


data_agglomerative/experiment_q10_clean_answers_full.json
[[{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'Just because', 'idx': 404}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}]]
silhouette scores
[-0.03111428  0.          0.5219843   0.42997014 -0.05385584  0.62449202
  0.02237946  0.24719896  0.37056828  0.43483963 -0.09371157  0.
  0.34585188  0.5777524   0.35118    -0.14775172  0.33555941  0.42896056
 -0.00202782  0.61444439 -0.16533779  0.37804213  0.52026616 -0.12775601
  0.17699821  0.61673796  0.37030816  0.13110975 -0.01837361  0.
 -0.14845556 -0.28763933]
max: 0.6244920184819793 arg: 5
mean: 0.20070688370424464
min: -0.28763933330272445 arg: 31
std: 0.2715713301060804


data_agglomerative/experiment_q10_clean_answers_only_lemma.json
[[{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[ 0.07488141  0.          0.57358664  0.18379878 -0.1177368   0.58403196
  0.31772527  0.3084927   0.01821239  0.18630556  0.27440663  0.
 -0.22627943  0.03961794  0.03884126 -0.11055447  0.28433757  0.
  0.1619453   0.33433749  0.04678611  0.35066581  0.22059601  0.34253427
  0.39853821  0.53387963  0.18238106 -0.04196416  0.19281456  0.
  0.11793204  0.05245658]
max: 0.584031957909444 arg: 5
mean: 0.166330322355916
min: -0.22627942554733887 arg: 12
std: 0.19793672530453668


data_agglomerative/experiment_q10_clean_answers_only_lowercase.json
[[{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}], [{'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[ 0.10466434 -0.15379256  0.64842821  0.56851815  0.02896833  0.41221213
 -0.29085814  0.09144809  0.10791542  0.44377179  0.54628536  0.03796834
  0.43605433 -0.26026573  0.15942565 -0.06308266  0.26914803 -0.18311949
  0.41309504  0.59211517 -0.20425931  0.18514991 -0.18087946 -0.24467341
 -0.25444283  0.52305153  0.27631729  0.30650414  0.75169822  0.
 -0.04986224  0.15946769]
max: 0.7516982192300194 arg: 28
mean: 0.16178035448317923
min: -0.2908581408130811 arg: 6
std: 0.3009144592882512


data_agglomerative/experiment_q10_clean_answers_only_stopwords.json
[[{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[-0.05020365  0.          0.53303057  0.42997014 -0.02643383  0.63114533
  0.00194868  0.2140167   0.33386488  0.43573115 -0.14752177  0.
  0.34382375  0.57099329  0.36276339 -0.10392217  0.27409973  0.42653226
 -0.05951363  0.62096657 -0.2085102   0.34448048  0.52685462 -0.09459117
  0.16825193  0.62817951  0.330242    0.12929894 -0.01490838  0.
 -0.19064383 -0.3241837 ]
max: 0.6311453254641833 arg: 5
mean: 0.19018004989388837
min: -0.32418370239965616 arg: 31
std: 0.27692159459967697


data_agglomerative/experiment_q10_clean_answers_stopwords_lemma.json
[[{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[-0.04079453  0.          0.5219843   0.42997014 -0.08050645  0.62449202
  0.02237946  0.24719896  0.37056828  0.43483963 -0.09371157  0.
  0.34585188  0.5777524   0.35118    -0.14775172  0.33555941  0.4271453
 -0.00202782  0.61444439 -0.16800405  0.37804213  0.53300179 -0.13576058
  0.17699821  0.61673796  0.37030816  0.12303234 -0.01407786  0.
 -0.19072617 -0.28763933]
max: 0.6244920184819793 arg: 5
mean: 0.1981402094837879
min: -0.28763933330272445 arg: 31
std: 0.2752311848753109


data_agglomerative/experiment_q10_raw.json
[[{'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'Just because', 'idx': 404}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}]]
silhouette scores
[ 0.1022485   0.          0.41613925  0.13031263  0.26761888  0.32832069
 -0.00392689  0.27173774  0.02276434  0.39165825  0.07369845  0.
  0.05403508  0.04308143  0.23003709  0.01525487 -0.23935039 -0.01618797
  0.19742656  0.31964729  0.18956    -0.04601571  0.11365763  0.27571634
  0.23307788  0.37998875  0.08713015  0.16075173  0.19400602  0.
 -0.10915104 -0.08058858]
max: 0.4161392499156527 arg: 2
mean: 0.12508278000047965
min: -0.23935038734648167 arg: 16
std: 0.15656216548417498


data_agglomerative/experiment_q11_clean_answers_full.json
[[{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[-0.50598118 -0.15875828 -0.16151013  0.34058814  0.21312594  0.48474039
 -0.14105472  0.69438028  0.20163264  0.25167798  0.63357711  0.2101172
  0.04926253 -0.32668399 -0.06386632  0.28788962 -0.34237293  0.39745232
  0.29172636  0.33597909 -0.22970418  0.73059748 -0.3576315  -0.37620451
 -0.17108942  0.          0.         -0.14023778 -0.14982341  0.24101852
  0.32604045  0.          0.79936653]
max: 0.7993665253652315 arg: 32
mean: 0.1019470972822406
min: -0.5059811836173403 arg: 0
std: 0.33989158854622964


data_agglomerative/experiment_q11_clean_answers_only_lemma.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}]]
silhouette scores
[ 0.          0.31695594  0.294908    0.07396904 -0.32576358  0.1791273
 -0.34535005 -0.01640346  0.24453226  0.62548409  0.36517932  0.13350207
  0.37185546 -0.29111932  0.08137406  0.44239056  0.36856627  0.40186784
  0.33710754  0.31209284 -0.23103598 -0.13942152 -0.2022321  -0.16028683
 -0.01765127 -0.12933155 -0.05256478  0.04804051 -0.16624234 -0.16889471
  0.03021795  0.10335147  0.41665899]
max: 0.6254840917963856 arg: 9
mean: 0.08790557720476992
min: -0.3453500506588692 arg: 6
std: 0.2543241313699934


data_agglomerative/experiment_q11_clean_answers_only_lowercase.json
[[{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'r yields 4', 'idx': 443}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}, {'data': 'Instgant call of inline-defined function', 'idx': 472}]]
silhouette scores
[ 0.25608956 -0.26875827  0.49080557  0.03229964 -0.11656633  0.45547866
  0.34743672 -0.01484478  0.39157381  0.6020367   0.62695053 -0.00297878
  0.63641265 -0.07680231  0.45723573  0.22061275 -0.24629538  0.29752866
  0.32309515  0.30705412  0.17395679  0.4082105   0.38573275  0.12409708
  0.1283817   0.         -0.09426637  0.11053178  0.03591425  0.00589797
  0.39338528  0.          0.41923917]
max: 0.6364126508313356 arg: 12
mean: 0.20634682688403186
min: -0.2687582689813324 arg: 1
std: 0.24448434370592168


data_agglomerative/experiment_q11_clean_answers_only_stopwords.json
[[{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'r yields 4', 'idx': 443}, {'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}]]
silhouette scores
[ 0.04619311 -0.033198    0.17262252  0.3132834  -0.18085606 -0.1545441
  0.54295537  0.72752196  0.34161272  0.53548805 -0.66381128  0.22115368
  0.35786542  0.62423173  0.33105738  0.40315096  0.41427546  0.43210412
  0.32057337 -0.11798098 -0.05725821  0.37454493  0.         -0.23502126
  0.13399783 -0.30128414 -0.1471745   0.1064602   0.65268147  0.2345461
  0.29747127  0.          0.63029289]
max: 0.7275219557113796 arg: 7
mean: 0.19160470833518808
min: -0.6638112841710125 arg: 10
std: 0.31457163392928694


data_agglomerative/experiment_q11_clean_answers_stopwords_lemma.json
[[{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[-0.50598118  0.06694719 -0.07501914  0.35672877  0.21312594  0.48474039
 -0.14105472  0.69438028  0.1289613   0.25167798  0.64133802  0.21216504
 -0.01890961 -0.32668399  0.06663356  0.3294663  -0.34237293  0.4212948
  0.31206548  0.33597909 -0.22970418  0.73059748 -0.3576315  -0.37470824
  0.01988032 -0.39698353 -0.31525503 -0.01035984 -0.14982341  0.22932967
  0.32604045  0.          0.79936653]
max: 0.7993665253652315 arg: 32
mean: 0.10231003916622397
min: -0.5059811836173403 arg: 0
std: 0.34921629481857336


data_agglomerative/experiment_q11_raw.json
[[{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[-4.57121251e-01  1.98188543e-01  1.46919868e-01  2.98345531e-01
 -1.57761238e-01 -1.62910593e-01  1.84099780e-01  2.78556219e-01
  2.94803262e-01  6.60862936e-01  3.27036362e-01  1.52971441e-01
  4.63132580e-01  3.97050530e-02  2.72986561e-01  3.36881121e-01
  3.73851240e-01  4.12915858e-01  3.29807265e-01  3.59934960e-01
 -2.62364389e-02 -2.47748649e-01 -3.30029040e-01  3.94748896e-02
 -2.57552967e-02 -1.31900158e-01 -4.09638240e-04  5.51036200e-02
  1.49383947e-01  1.77824609e-01  4.89722014e-01  0.00000000e+00
  4.68465676e-01]
max: 0.6608629361970089 arg: 9
mean: 0.15063942526230004
min: -0.45712125088929156 arg: 0
std: 0.25144693766596204


data_agglomerative/experiment_q12_clean_answers_full.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.          0.01607945  0.31778048  0.46095032  0.46515499 -0.09946569
  0.13906991 -0.04453718  0.17311409 -0.32265925 -0.08767216  0.23270254
  0.3182261   0.05707893  0.43477731  0.28368618  0.24986966  0.0968086
  0.0408102   0.33902533  0.42674781  0.3719814   0.37586563 -0.04856064
  0.50486862  0.11645362  0.43696001 -0.1552201   0.          0.
  0.60131046  0.          0.4220811 ]
max: 0.6013104623386525 arg: 30
mean: 0.18555417247473754
min: -0.3226592514016848 arg: 9
std: 0.2250109575308914


data_agglomerative/experiment_q12_clean_answers_only_lemma.json
[[{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.24403185  0.21595815  0.30768303  0.31626722 -0.02883598  0.17001145
 -0.13370024 -0.2449372  -0.09567848  0.33561629  0.21903931 -0.09056401
  0.14610384 -0.04021433  0.24463557  0.15901007  0.00559508  0.29151507
 -0.06826812  0.03710923  0.28383721  0.08712093  0.56310723  0.11040009
  0.51171233 -0.16530063 -0.07115689 -0.01609472  0.00078962  0.
  0.15683949  0.          0.48719573]
max: 0.5631072321601728 arg: 22
mean: 0.11935843042468136
min: -0.24493719920833745 arg: 7
std: 0.1976651538587293


data_agglomerative/experiment_q12_clean_answers_only_lowercase.json
[[{'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}, {'data': 'Same as previous', 'idx': 506}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}]]
silhouette scores
[ 0.32329591  0.3883753   0.02070592  0.13582717  0.50357879  0.05309182
  0.50898322  0.63471346 -0.15098157 -0.16442595  0.12004425 -0.06520126
  0.44543966  0.47269889 -0.09961888  0.30476551  0.42345427  0.42817724
  0.08283072  0.16862613  0.19756271 -0.11492956 -0.03203331  0.12379376
  0.64533343  0.01680553  0.23195798 -0.21666104  0.16151096  0.00238969
  0.46106472  0.25702321  0.04163573]
max: 0.6453334262592616 arg: 24
mean: 0.19120710342532896
min: -0.2166610351938249 arg: 27
std: 0.23803043471598442


data_agglomerative/experiment_q12_clean_answers_only_stopwords.json
[[{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.06197914 -0.0267798   0.219744    0.45812883  0.17407177  0.2487143
  0.16601231  0.02780016 -0.20464115  0.08554034  0.23377306 -0.14663772
  0.29087544  0.          0.42942023  0.3208161   0.08310453 -0.17340178
  0.05691003  0.20114263  0.18994113  0.29258045  0.40719164  0.03706641
  0.30316758  0.02753227 -0.0742032  -0.00971154 -0.15413037  0.
  0.18088812  0.          0.22887747]
max: 0.45812882907495966 arg: 3
mean: 0.11926582963590614
min: -0.20464114750762177 arg: 8
std: 0.17300907264704316


data_agglomerative/experiment_q12_clean_answers_stopwords_lemma.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.         -0.00400373  0.33209589  0.46095032  0.46515499 -0.09946569
  0.13906991 -0.04453718  0.1419223  -0.32265925 -0.08767216  0.23270254
  0.3182261   0.0516788   0.43477731  0.36183755  0.24986966  0.08558294
  0.04673338  0.35493646  0.42674781  0.37287177  0.37365301  0.04159701
  0.50486862  0.11645362  0.43696001 -0.14619126  0.          0.
  0.60131046  0.          0.42947727]
max: 0.6013104623386525 arg: 30
mean: 0.1901499524770671
min: -0.3226592514016848 arg: 9
std: 0.22525206310058324


data_agglomerative/experiment_q12_raw.json
[[{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}], [{'data': 'do not recall nothing', 'idx': 508}]]
silhouette scores
[ 0.1668045   0.          0.33669541  0.29167702 -0.08239437  0.34307113
 -0.11193819 -0.12827658  0.09243033  0.36041475  0.41111775 -0.05525509
  0.17020623  0.16385457  0.23094225  0.37413806  0.01028526  0.31259824
 -0.02865538  0.26792001  0.2679824   0.          0.41693847  0.09717654
  0.49458671 -0.19237162 -0.04866717  0.02273647 -0.0304357   0.
  0.07208848  0.          0.45586109]
max: 0.4945867108089817 arg: 24
mean: 0.14186459220209083
min: -0.19237162280722442 arg: 25
std: 0.19062880479312108


data_agglomerative/experiment_q13_clean_answers_full.json
[[{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'Definition of function; call of function', 'idx': 540}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.70443446 -0.09455275  0.40888537 -0.00806961  0.81600682 -0.40438628
  0.15016961  0.8401536   0.3642783  -0.12619613  0.7928781   0.66448047
 -0.49824604  0.77771429  0.09038311  0.3755229  -0.05167567  0.6448781
 -0.02815143  0.33228534  0.32095034  0.68201468  0.80219605  0.26557172
  0.69007937  0.08608711 -0.13014412 -0.01111636 -0.03376699 -0.04819859
 -0.03426584  0.00789351]
max: 0.840153597688565 arg: 7
mean: 0.2608779198801321
min: -0.4982460425311096 arg: 12
std: 0.37876470572249105


data_agglomerative/experiment_q13_clean_answers_only_lemma.json
[[{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'it returns 4', 'idx': 514}, {'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}]]
silhouette scores
[ 0.48610436 -0.01500646  0.28621713 -0.02689756  0.10299686  0.07766074
  0.18883527 -0.39387653  0.31459473  0.          0.53267403  0.53662028
  0.60267579  0.3108629  -0.03086828  0.19981023  0.3399084   0.37339065
 -0.02914133  0.40611375  0.29717368  0.51360139  0.75640887  0.26688228
  0.43868559  0.27975438  0.24398129  0.24415769  0.45022607  0.26588237
  0.31187619  0.41454237]
max: 0.7564088685791558 arg: 22
mean: 0.27330772340441567
min: -0.393876526611705 arg: 7
std: 0.2275048721299758


data_agglomerative/experiment_q13_clean_answers_only_lowercase.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}], [{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'the variable r will store the result of the function f', 'idx': 539}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'f is the definition and then r is the invocation', 'idx': 530}], [{'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}]]
silhouette scores
[ 0.29361315  0.03711501 -0.14982489  0.12032234  0.65401547 -0.3426987
  0.42258386  0.63596783 -0.18902644 -0.24879981  0.0402802   0.6877433
 -0.16224818 -0.13633147  0.58081128 -0.1056628  -0.12216704 -0.19115098
 -0.4160834   0.29758301  0.74873837 -0.17569198 -0.18242113  0.27416169
  0.25936815  0.40375796  0.13038     0.43975071  0.13702568  0.
  0.24559481  0.41100008]
max: 0.7487383691976509 arg: 20
mean: 0.13742831551545884
min: -0.4160834031088121 arg: 18
std: 0.32189695495744597


data_agglomerative/experiment_q13_clean_answers_only_stopwords.json
[[{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'Definition of function; call of function', 'idx': 540}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.11291667 -0.23236243  0.39044276  0.11366315  0.81475356 -0.37851277
  0.15130869 -0.69981201  0.4428689   0.          0.82162081  0.76322446
 -0.01920429  0.68448757  0.10980802  0.42216796 -0.03463375  0.65509199
  0.0131705   0.36212271  0.34076422  0.3637854   0.63647803  0.19359118
  0.33164731  0.08608711 -0.26831363 -0.05400536 -0.09151459 -0.03508104
 -0.09011515 -0.18311036]
max: 0.8216208147909235 arg: 10
mean: 0.17885423780917392
min: -0.699812010212767 arg: 7
std: 0.3595713790836591


data_agglomerative/experiment_q13_clean_answers_stopwords_lemma.json
[[{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'Definition of function; call of function', 'idx': 540}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.70443446 -0.09455275  0.39726676 -0.00806961  0.81600682 -0.40438628
  0.15016961  0.8401536   0.4252758  -0.12619613  0.7928781   0.66448047
 -0.49824604  0.77771429  0.10980802  0.3755229  -0.05167567  0.65509199
 -0.02357822  0.33228534  0.32095034  0.68201468  0.80219605  0.26557172
  0.69007937  0.08608711 -0.13014412 -0.01111636 -0.03376699 -0.03508104
 -0.03426584  0.00789351]
max: 0.840153597688565 arg: 7
mean: 0.26390005857782656
min: -0.4982460425311096 arg: 12
std: 0.3789247907668053


data_agglomerative/experiment_q13_raw.json
[[{'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}]]
silhouette scores
[-0.00569043  0.          0.36134449  0.07044918  0.25819885  0.16145698
  0.20029041  0.12506897 -0.03847302  0.08791005 -0.12268779  0.24318868
  0.20738715  0.14784401  0.0055251   0.51429374  0.30663563  0.04005771
  0.45537066  0.42981897  0.23756804  0.00483417  0.03957346  0.01803533
  0.10075619  0.30312385 -0.04637647  0.24061009  0.24295845  0.06442449
  0.42012242  0.52795974]
max: 0.5279597387204231 arg: 31
mean: 0.1750493472221207
min: -0.12268778928174678 arg: 10
std: 0.17165525912703614


data_agglomerative/experiment_q14_clean_answers_full.json
[[{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}]]
silhouette scores
[ 0.5127669  -0.11075476 -0.07469108  0.58620346  0.04531013  0.34019804
 -0.17832385 -0.14504696  0.66306081 -0.08367455  0.31423619 -0.20537868
  0.1147847   0.63903528 -0.12093223  0.41796525  0.24412195 -0.32370159
  0.16732183  0.16977333 -0.41758315  0.24924951  0.          0.03333698
  0.45811593  0.40531606 -0.09454986  0.04470099  0.63834067  0.
  0.02430871 -0.22133557  0.44556334]
max: 0.6630608070185664 arg: 8
mean: 0.13750720554903706
min: -0.41758315271729046 arg: 20
std: 0.2948541550218527


data_agglomerative/experiment_q14_clean_answers_only_lemma.json
[[{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}], [{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}]]
silhouette scores
[-0.05624071  0.63334117 -0.03804017  0.01704699 -0.45864022  0.23836995
  0.05600116  0.13969915  0.26911723  0.25185608  0.21405896  0.01874013
  0.08637714  0.0776982   0.12455378  0.08992714  0.16731452  0.3128159
  0.05503397  0.09660016 -0.06340787  0.22365506 -0.17484235  0.10595693
  0.02476367  0.01716557  0.          0.28432764 -0.14158214  0.
 -0.08645659  0.03432118  0.44479681]
max: 0.6333411725876623 arg: 1
mean: 0.08982813395670047
min: -0.4586402224388712 arg: 4
std: 0.1899785368930704


data_agglomerative/experiment_q14_clean_answers_only_lowercase.json
[[{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}], [{'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}], [{'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}]]
silhouette scores
[ 0.17049894 -0.08109785  0.10691669  0.48426329  0.25852171  0.09580402
 -0.47300013 -0.40818771  0.24531598  0.40422259  0.47902086  0.32248642
  0.5158401   0.15007229  0.4352414   0.00385628 -0.09665716  0.4434497
 -0.52093593  0.         -0.34968486  0.2083133  -0.0912036   0.01939116
 -0.09400722  0.38785503  0.21535542 -0.16611992  0.18113542 -0.27991947
 -0.0824528   0.0370916  -0.05619653]
max: 0.5158400989153855 arg: 12
mean: 0.07470269672296995
min: -0.5209359349955762 arg: 18
std: 0.2810348962492593


data_agglomerative/experiment_q14_clean_answers_only_stopwords.json
[[{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}, {'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}]]
silhouette scores
[ 0.43819976 -0.08584379 -0.08289831  0.49505741  0.12738643  0.28889713
 -0.09502016 -0.11098902  0.52958501  0.          0.31904684 -0.17484872
  0.13647924  0.63352175 -0.05383256  0.34764135  0.26537713 -0.25800897
  0.16762119  0.16752748 -0.37918051 -0.09777608  0.         -0.01494294
  0.20607675  0.40877122 -0.0503417   0.07437167  0.60593434  0.
  0.05412709 -0.22182924  0.4166455 ]
max: 0.6335217464109978 arg: 13
mean: 0.1229319783791096
min: -0.379180513100383 arg: 20
std: 0.2574618319597025


data_agglomerative/experiment_q14_clean_answers_stopwords_lemma.json
[[{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}]]
silhouette scores
[ 0.5127669  -0.11075476 -0.07469108  0.58620346  0.04531013  0.34019804
 -0.17832385 -0.14504696  0.66306081 -0.08367455  0.31423619 -0.20537868
  0.1147847   0.63903528 -0.12093223  0.41796525  0.24412195 -0.32370159
  0.16732183  0.16977333 -0.41758315  0.24924951  0.          0.03333698
  0.45811593  0.40531606 -0.09454986  0.04470099  0.63834067  0.
  0.02430871 -0.22133557  0.44556334]
max: 0.6630608070185664 arg: 8
mean: 0.13750720554903706
min: -0.41758315271729046 arg: 20
std: 0.2948541550218527


data_agglomerative/experiment_q14_raw.json
[[{'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'only has one parameter', 'idx': 580}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}]]
silhouette scores
[ 0.34139744  0.         -0.14709082  0.35329037  0.          0.2940422
 -0.13718929  0.14019409  0.13078319  0.30755012  0.26688304 -0.10337077
  0.03670945 -0.18583067  0.          0.34575364  0.17557486  0.05692718
 -0.04627537 -0.00232735 -0.25576082  0.09167903  0.11039095 -0.05215413
  0.38054732 -0.09281812  0.          0.03138056  0.56791405  0.
 -0.10229268 -0.08220884  0.3825986 ]
max: 0.5679140542902157 arg: 28
mean: 0.08503931074298414
min: -0.2557608221536163 arg: 20
std: 0.19569668837287035


data_agglomerative/experiment_q15_clean_answers_full.json
[[{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'Just because', 'idx': 642}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}]]
silhouette scores
[-0.15650195  0.43661308  0.34786674 -0.14652107  0.62524508  0.16728284
  0.06781141  0.11864733  0.15598888  0.29715973  0.09134057 -0.24377858
 -0.18122728 -0.03569197  0.51127721  0.80870884  0.14258622 -0.05966492
  0.64964737 -0.21487677  0.38955119 -0.21508863 -0.14366373 -0.10875498
  0.55864297 -0.31713106  0.01540338  0.24973414  0.34323414  0.
 -0.0204782   0.65320327  0.06378836]
max: 0.8087088392541519 arg: 15
mean: 0.1469804121632753
min: -0.3171310634668258 arg: 25
std: 0.29944604714150985


data_agglomerative/experiment_q15_clean_answers_only_lemma.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Just because', 'idx': 642}], [{'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}]]
silhouette scores
[-2.27626604e-01  7.93560605e-01  1.97536564e-01  3.67843562e-01
 -4.68480322e-01  2.46226983e-01  4.30922308e-01  3.98913385e-01
  1.74211962e-01 -2.40552204e-01  1.03647222e-01  4.56733003e-01
  4.82440867e-01 -3.10874283e-01  2.61058808e-01  5.89934547e-01
 -2.54277781e-01 -9.26146352e-02  4.41829145e-01  0.00000000e+00
  2.71463962e-01  1.81779969e-01 -1.10810338e-01  1.80731198e-01
  1.57665711e-01 -5.60009765e-02  3.03540039e-01  2.78875492e-04
 -2.70190221e-02  0.00000000e+00  0.00000000e+00 -1.02016790e-01
  2.48947336e-02]
max: 0.7935606054595455 arg: 1
mean: 0.12651334825989463
min: -0.46848032193355355 arg: 4
std: 0.27840283074460614


data_agglomerative/experiment_q15_clean_answers_only_lowercase.json
[[{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'two functions are invoked with two different params', 'idx': 632}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}], [{'data': 'Just because', 'idx': 642}]]
silhouette scores
[ 0.12865561  0.59582997  0.06588954 -0.06368561  0.39189654  0.66140494
  0.11021557  0.62898157  0.56647263  0.03191193  0.43782505  0.55247618
  0.60220865 -0.1020567   0.09641246  0.57705047  0.          0.28149436
  0.16162356  0.46686499  0.49177379  0.33722734  0.35061198  0.23773849
  0.42935619  0.55243794  0.57136533 -0.00724894 -0.52196701  0.
  0.13381663  0.29977744  0.18043233]
max: 0.6614049357031911 arg: 5
mean: 0.2802058549236439
min: -0.5219670099116704 arg: 28
std: 0.27019106995186176


data_agglomerative/experiment_q15_clean_answers_only_stopwords.json
[[{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'Just because', 'idx': 642}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}]]
silhouette scores
[-0.16245048  0.49981627  0.44054845 -0.12759294  0.59883423  0.21682372
 -0.00696178 -0.14582815  0.1358907   0.07894958  0.08339192 -0.22491764
 -0.37808867  0.06645233  0.41168415  0.79533717  0.26194969 -0.01396395
  0.58615453  0.          0.34989517 -0.14167706 -0.07103973  0.02150211
  0.62234426 -0.49210558  0.14070158  0.29256049  0.348418    0.
  0.15230325  0.62668632  0.07407836]
max: 0.795337173702663 arg: 15
mean: 0.15271806913948066
min: -0.49210557825332396 arg: 25
std: 0.3021930340534323


data_agglomerative/experiment_q15_clean_answers_stopwords_lemma.json
[[{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'Just because', 'idx': 642}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}]]
silhouette scores
[-0.15650195  0.43661308  0.34786674 -0.14652107  0.62524508  0.16728284
  0.06781141  0.11864733  0.15598888  0.29715973  0.09134057 -0.24377858
 -0.18122728 -0.03569197  0.51127721  0.80870884  0.14258622 -0.05966492
  0.64964737 -0.21487677  0.38955119 -0.21508863 -0.14366373 -0.10875498
  0.55864297 -0.31713106  0.01540338  0.24973414  0.34323414  0.
 -0.0204782   0.65320327  0.06378836]
max: 0.8087088392541519 arg: 15
mean: 0.1469804121632753
min: -0.3171310634668258 arg: 25
std: 0.29944604714150985


data_agglomerative/experiment_q15_raw.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}], [{'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Just because', 'idx': 642}]]
silhouette scores
[-0.15335404  0.17396991  0.24784619  0.20644797 -0.39420582  0.40631851
  0.42217432  0.33675774  0.32400491 -0.17806555  0.17889789  0.35744503
  0.21765898  0.          0.45420311  0.20152684 -0.04363073  0.
  0.42224582  0.         -0.00937005  0.00469962  0.19142074 -0.00933081
  0.47398987  0.28854903  0.27585478  0.06255346  0.09629032  0.
  0.11415805  0.28519366  0.3777729 ]
max: 0.4739898718654475 arg: 24
mean: 0.1615764441741178
min: -0.3942058241102783 arg: 4
std: 0.2022974443277129


data_agglomerative/experiment_q16_clean_answers_full.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}]]
silhouette scores
[ 0.37371721  0.31079594  0.12367158  0.          0.20868577  0.03312897
  0.06131361  0.33702418  0.5839439   0.29770543  0.18232343  0.38364688
  0.618504    0.16378339  0.70279354  0.42168755  0.17056973 -0.03197858
  0.68321706 -0.12349696  0.45640644  0.58858454  0.         -0.33614864
  0.64604442  0.51825509  0.28981426  0.01873346  0.05131235  0.18575119
  0.12620824 -0.00852706  0.25169775]
max: 0.702793535939682 arg: 14
mean: 0.2511869305407332
min: -0.33614864212519385 arg: 23
std: 0.2516162418726556


data_agglomerative/experiment_q16_clean_answers_only_lemma.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[ 0.29040582 -0.21724312 -0.2815594   0.         -0.17818199  0.17748603
  0.25564187 -0.07003689  0.4629063   0.5298302  -0.16370249  0.52121725
  0.52850892  0.36068351  0.28507838  0.15988588 -0.13219175 -0.01771912
  0.35865384  0.20568048  0.31097667  1.          0.29725326  0.24922364
  0.49253005  0.13363201  1.         -0.11937794  0.53012599  0.
  0.03012396  0.04966233  0.23706149]
max: 1.0 arg: 21
mean: 0.2208047022482654
min: -0.2815594031498831 arg: 2
std: 0.306313758846782


data_agglomerative/experiment_q16_clean_answers_only_lowercase.json
[[{'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[ 0.43711846  0.10447334  0.36403989 -0.04112637  0.40346259 -0.22969792
  0.07407875 -0.12271135  0.42485535  0.64188103  0.32013023  0.56263225
  0.35667175  0.04821078  0.09591358  0.31675065  0.67739037 -0.00564848
  0.40592298 -0.27699043  0.12992255  0.27128241  0.          0.17324936
  0.16760463  0.35848423  0.23424037  0.08364596  0.0082665   0.
  0.36604062  0.          0.28931386]
max: 0.6773903709792423 arg: 16
mean: 0.20119417999957726
min: -0.2769904325908047 arg: 19
std: 0.2299014057274201


data_agglomerative/experiment_q16_clean_answers_only_stopwords.json
[[{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}]]
silhouette scores
[ 0.3274774   0.31329997  0.06390166  0.          0.23142895  0.039155
  0.10997356  0.34005137  0.60808436  0.25080826  0.06514652  0.33406335
  0.65190395  0.14238485  0.67860098  0.42623984  0.16797814 -0.07398287
  0.68839323 -0.24200147  0.39977923  0.52511331  0.         -0.26950708
  0.60135759  0.50800062  0.29926018  0.05537512  0.11289457  0.04353269
  0.10302063 -0.09609866  0.24696357]
max: 0.6883932314564389 arg: 18
mean: 0.2318969339121898
min: -0.2695070758503824 arg: 23
std: 0.25440211983413363


data_agglomerative/experiment_q16_clean_answers_stopwords_lemma.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}]]
silhouette scores
[ 0.37371721  0.31079594  0.12367158  0.          0.20868577  0.03312897
  0.06131361  0.33702418  0.5839439   0.29770543  0.18232343  0.38364688
  0.618504    0.16378339  0.70279354  0.42168755  0.17056973 -0.03197858
  0.68321706 -0.12349696  0.45640644  0.58858454  0.         -0.33614864
  0.64604442  0.51825509  0.28981426  0.01873346  0.05131235  0.18575119
  0.12620824 -0.00852706  0.25169775]
max: 0.702793535939682 arg: 14
mean: 0.2511869305407332
min: -0.33614864212519385 arg: 23
std: 0.2516162418726556


data_agglomerative/experiment_q16_raw.json
[[{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[-0.32805165 -0.22449567  0.47514426  0.         -0.2272951   0.40297925
  0.30705773  0.26929488  0.60997471  0.53604626  0.22495134 -0.09613372
  0.59732487  0.          0.58094294  0.20593898  0.1756446  -0.02923861
  1.          0.          0.00460114  0.48969168  0.25666822  0.13539916
 -0.06264993  1.          0.53696512 -0.11587737  0.54436056  0.
 -0.12104973  0.02642507  0.23476339]
max: 1.0 arg: 18
mean: 0.22452673942094725
min: -0.3280516549834556 arg: 0
std: 0.3296099471272593


data_agglomerative/experiment_q17_clean_answers_full.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[ 0.01826052 -0.04671892  0.5896601  -0.68324882  0.13137474  0.03080257
  0.         -0.21109703 -0.08335643  0.18142216  0.76750625 -0.21184666
  0.15591062 -0.27054104 -0.0076603   0.77957955 -0.16585232  0.69363811
 -0.3796545   0.07813089 -0.11325286  0.59886095  0.27303648  0.
  0.29667154 -0.20346433 -0.13438369  0.21824376 -0.42578457  0.29453179]
max: 0.7795795509251514 arg: 15
mean: 0.07235895119882492
min: -0.6832488221899731 arg: 3
std: 0.3497563533700933


data_agglomerative/experiment_q17_clean_answers_only_lemma.json
[[{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'print that', 'idx': 814}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'the output is correct.', 'idx': 805}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[-0.02285369 -0.12314683  0.04335979  0.5975055   0.26224321  0.2125669
 -0.08480076 -0.46707647 -0.009125    0.03229076  0.01587851 -0.02853639
  0.30552138  0.19104963 -0.32728115  0.51062503 -0.29245826  0.64445544
 -0.32170398 -0.04980466  0.         -0.2952339   0.10013681  0.
  0.37555434 -0.40748747 -0.06951202  0.13425782  0.          0.22290888]
max: 0.6444554426437147 arg: 17
mean: 0.03831111327482204
min: -0.46707647191367496 arg: 7
std: 0.2740677541936737


data_agglomerative/experiment_q17_clean_answers_only_lowercase.json
[[{'data': 'the output is correct.', 'idx': 805}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[ 0.40650229  0.29287888  0.24009418  0.52888787  0.73916694  0.48747967
  0.58677446  0.18303835 -0.4463061   0.61192115  0.15235647  0.49488671
 -0.11191751  0.78088145  0.          0.02814026 -0.10601737  0.53624464
  0.27860202  0.13377834  0.64249969 -0.25232395  0.228336   -0.2604165
 -0.49735238  0.27077157  0.         -0.17829485 -0.21503841 -0.14800416]
max: 0.7808814450162735 arg: 13
mean: 0.1802523238455466
min: -0.49735237696725965 arg: 24
std: 0.34888789582726804


data_agglomerative/experiment_q17_clean_answers_only_stopwords.json
[[{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'it follows the CPS expression', 'idx': 784}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[ 0.12040544  0.          0.49576289 -0.67099902  0.18169566  0.07288776
  0.         -0.2404194  -0.07687497 -0.02597621  0.70958042  0.00971777
  0.103757   -0.02153494  0.07767284  0.69576355 -0.19765985  0.68018825
 -0.32237389  0.16503061 -0.13170782  0.54601686  0.07044001  0.
  0.21895367 -0.18006655  0.05379991  0.32393388 -0.37705249  0.32191968]
max: 0.7095804237621028 arg: 10
mean: 0.08676203560824546
min: -0.6709990152324211 arg: 3
std: 0.31515447390258905


data_agglomerative/experiment_q17_clean_answers_stopwords_lemma.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[ 0.01826052 -0.04671892  0.5896601  -0.68324882  0.13137474  0.03080257
  0.         -0.21109703 -0.08335643  0.18142216  0.76750625 -0.21184666
  0.15591062 -0.27054104 -0.0076603   0.77957955 -0.16585232  0.69363811
 -0.3796545   0.07813089 -0.11325286  0.59886095  0.27303648  0.
  0.29667154 -0.20346433 -0.13438369  0.21824376 -0.42578457  0.29453179]
max: 0.7795795509251514 arg: 15
mean: 0.07235895119882492
min: -0.6832488221899731 arg: 3
std: 0.3497563533700933


data_agglomerative/experiment_q17_raw.json
[[{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'the output is correct.', 'idx': 805}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[-0.08064303 -0.13819421  0.52058162  0.30594925  0.22428681  0.19426815
 -0.03929612  0.29952019 -0.01487252  0.26760321  0.72394673  0.32731807
  0.14503633  0.12524577  0.16494537  0.54083752  0.02384864 -0.45055302
 -0.36651402 -0.0340066  -0.06524531  0.59648022  0.08592596  0.
  0.2273435  -0.04502425 -0.25780247  0.34161025 -0.3002632   0.21071788]
max: 0.7239467278237157 arg: 10
mean: 0.11776835668070547
min: -0.45055302012690024 arg: 17
std: 0.2763361611793782


data_agglomerative/experiment_q18_clean_answers_full.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}]]
silhouette scores
[-0.38079318  0.48192595  0.62200288  0.49575551  0.31087975  0.00769174
  0.22188152  0.28902377  0.06374793  0.72778254 -0.18628261  0.
  0.          0.26778285  0.65950787  0.35144804  0.12770986  0.50804521
  0.55029592 -0.03488054 -0.04270926  0.37340787  0.63915274  0.18766459
  0.12753123  0.33553784  0.43001098  0.         -0.29911273]
max: 0.7277825351766795 arg: 9
mean: 0.23568994011217687
min: -0.3807931808481078 arg: 0
std: 0.28730219072597635


data_agglomerative/experiment_q18_clean_answers_only_lemma.json
[[{'data': 'See Option 1.', 'idx': 819}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'after printing c1, the system teminates', 'idx': 818}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'is a wrong result of continuation', 'idx': 848}]]
silhouette scores
[ 0.19223935  0.          0.28394631  0.13983091  0.26312053 -0.22950871
  0.3126136   0.10379169  0.04582271  0.40566201  0.16680519  0.32979756
  0.          0.00130605  0.43582901  0.39328212 -0.00406185  0.42126199
  0.41642148  0.1508459   0.53420514  0.47735897  0.50833237 -0.25706385
  0.08222063  0.08224751  0.12045279  0.          0.45652478]
max: 0.5342051402568073 arg: 20
mean: 0.20114773188162413
min: -0.25706384888994227 arg: 23
std: 0.21089943947772632


data_agglomerative/experiment_q18_clean_answers_only_lowercase.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'See Option 1.', 'idx': 819}], [{'data': 'The last output is ft2', 'idx': 829}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}]]
silhouette scores
[-0.03931314  0.03213779  0.          0.95142572  0.4280749   0.85902411
  0.44673355  0.13072636  0.1364938   0.52629894 -0.1839183   0.28128795
 -0.5683116   0.32031953 -0.13375606  0.00777598  0.01484779  0.83699221
  0.23694089  0.          0.71067952  0.7560283   0.13692307  0.17005026
 -0.07574871 -0.27167554  0.47555952  0.91567482  0.46884253]
max: 0.9514257246268768 arg: 3
mean: 0.2610384212456053
min: -0.5683116024586127 arg: 12
std: 0.3790567169014488


data_agglomerative/experiment_q18_clean_answers_only_stopwords.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}]]
silhouette scores
[-0.06190425  0.50117597  0.62200288  0.49461695  0.31087975  0.13017061
  0.22188152  0.28714374  0.14537628  0.72778254 -0.37147712  0.13717805
  0.          0.26290993  0.65986141  0.3111658   0.09544553  0.50991637
  0.55029592 -0.03488054 -0.04270926  0.37340787  0.64113056  0.18616363
  0.13226942  0.34239566  0.45167581  0.         -0.29911273]
max: 0.7277825351766795 arg: 9
mean: 0.2511986997218073
min: -0.37147712158775653 arg: 10
std: 0.27538126578894767


data_agglomerative/experiment_q18_clean_answers_stopwords_lemma.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}]]
silhouette scores
[-0.38079318  0.48192595  0.62200288  0.49575551  0.31087975  0.00769174
  0.22188152  0.28902377  0.06374793  0.72778254 -0.18628261  0.
  0.          0.26778285  0.65950787  0.35144804  0.12770986  0.50804521
  0.55029592 -0.03488054 -0.04270926  0.37340787  0.63915274  0.18766459
  0.12753123  0.33553784  0.43001098  0.         -0.29911273]
max: 0.7277825351766795 arg: 9
mean: 0.23568994011217687
min: -0.3807931808481078 arg: 0
std: 0.28730219072597635


data_agglomerative/experiment_q18_raw.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'See Option 1.', 'idx': 819}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The last output is ft2', 'idx': 829}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}], [{'data': 'after printing c1, the system teminates', 'idx': 818}]]
silhouette scores
[ 0.31310964  0.          0.43954558  0.1694453   0.06732399  0.10495095
  0.17178268 -0.16723814  0.14054876  0.43361138 -0.01913091  0.26613649
  0.38728021  0.09638918  0.56524649  0.44007034  0.21065965  0.46116181
  0.45254832  0.29180683  0.12019272  0.21441337  0.64217281  0.4261641
  0.0345006   0.2141778   0.19200407  0.         -0.30759061]
max: 0.6421728092279345 arg: 22
mean: 0.21935460010066632
min: -0.3075906112405947 arg: 28
std: 0.21407119089822982


data_agglomerative/experiment_q19_clean_answers_full.json
[[{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'not correct', 'idx': 882}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}]]
silhouette scores
[ 0.11197985 -0.03329899  0.18726639  0.4913599   0.04268591  0.41120132
 -0.10815057  0.0990683   0.39546873 -0.08567795  0.93215755  0.07926587
  0.          0.86863806  0.86769797  0.30891479  0.18887644 -0.33084277
  0.02404004  0.30223634  0.28981283  0.34664069 -0.22405436 -0.28598299
 -0.18686684  0.18004355  0.56071998  0.19361572]
max: 0.932157548483177 arg: 10
mean: 0.2009577061754831
min: -0.33084277381721094 arg: 17
std: 0.3265643198842137


data_agglomerative/experiment_q19_clean_answers_only_lemma.json
[[{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': 'not correct', 'idx': 882}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}]]
silhouette scores
[ 0.42166493  0.42681669  0.66098399  0.43787074 -0.34691015  0.09191576
  0.43650421 -0.0382216  -0.17298419  0.40649739  0.93221026  0.2646865
  0.          0.89074242  0.82772141  0.08309027  0.63226917  0.00782138
  0.58630705 -0.06998499  0.58761614  0.24317196  0.0263374  -0.25821837
 -0.29097959  0.20829041  0.15203265  0.44960861]
max: 0.9322102602155821 arg: 10
mean: 0.27131644384151554
min: -0.3469101547687391 arg: 4
std: 0.35058733901420447


data_agglomerative/experiment_q19_clean_answers_only_lowercase.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}], [{'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'Option 1 is the correct answer.', 'idx': 872}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}]]
silhouette scores
[ 0.2102577  -0.09507401  0.21321362  0.1800433   0.30219441  0.02747653
 -0.18073625  0.35663675  0.28406565  0.57575299  0.24571415  0.03097294
  0.39421627  0.3072205  -0.38346731  0.11274538  0.         -0.02541938
  0.14739087  0.04598949  0.27318708  0.40742243  0.35063821  0.34170346
  0.20069993  0.13475844  0.          0.3670183 ]
max: 0.5757529861681636 arg: 9
mean: 0.1723079085083268
min: -0.3834673139202336 arg: 14
std: 0.20113642488422434


data_agglomerative/experiment_q19_clean_answers_only_stopwords.json
[[{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'not correct', 'idx': 882}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}]]
silhouette scores
[-2.80745917e-01 -4.17119654e-02  1.87266390e-01  4.61088115e-01
  4.26859111e-02 -2.72656100e-01 -1.08150566e-01 -3.42681204e-02
 -1.87629363e-01 -8.56779511e-02  9.41658070e-01 -2.01804047e-01
 -3.38120670e-02  8.67627260e-01  8.85081550e-01 -3.03344133e-01
  3.60795247e-01 -3.25194387e-01  2.40400375e-02  3.02236345e-01
  2.89812834e-01  5.12606288e-01  4.97505954e-01  2.41523479e-04
 -1.41276912e-01 -1.29684805e-01  5.60719981e-01  1.93615722e-01]
max: 0.9416580704336257 arg: 10
mean: 0.1421794605777321
min: -0.32519438675511986 arg: 17
std: 0.36651498435624835


data_agglomerative/experiment_q19_clean_answers_stopwords_lemma.json
[[{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'not correct', 'idx': 882}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}]]
silhouette scores
[ 0.11197985 -0.03329899  0.18726639  0.4913599   0.04268591  0.41120132
 -0.10815057  0.0990683   0.39546873 -0.08567795  0.93215755  0.07926587
  0.          0.86863806  0.86769797  0.30891479  0.18887644 -0.33084277
  0.02404004  0.30223634  0.28981283  0.34664069 -0.22405436 -0.28598299
 -0.18686684  0.18004355  0.56071998  0.19361572]
max: 0.932157548483177 arg: 10
mean: 0.2009577061754831
min: -0.33084277381721094 arg: 17
std: 0.3265643198842137


data_agglomerative/experiment_q19_raw.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': 'not correct', 'idx': 882}], [{'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}]]
silhouette scores
[ 0.73293573  0.40542342  0.61125263  0.64689301  0.39175646  0.15639273
 -0.23100402 -0.05490046 -0.27194587  0.60304977  0.85661335  0.1988051
  0.          0.93120775  0.81298812  0.37549313  0.59378809  0.12491721
  0.66071557 -0.02879869  0.08129835 -0.04538625  0.39549927  0.0773041
 -0.11024447 -0.22384041  0.12079712  0.52006857]
max: 0.9312077478596639 arg: 13
mean: 0.29753854701526183
min: -0.2719458732413413 arg: 8
std: 0.3511781443482408


