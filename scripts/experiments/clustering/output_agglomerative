data_agglomerative/experiment_q00_clean_answers_full.json
[[{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.86415123  0.78567446  0.16671958  0.1055112   0.          0.43924022
  0.26971171  0.37861507  0.10909548  0.84708892  0.43231207  0.10830876
 -0.15191849 -0.17667277  0.43691422 -0.08170958  0.43546104  0.56579267
  0.04721208  0.63842686 -0.19105191  0.45126341  0.65536655  0.
  0.80582321 -0.00603379 -0.02634737  0.09641194  0.19280873 -0.10047663
  0.15254908 -0.04423643  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.24866701525564947
min: -0.19105190699461527 arg: 20
std: 0.31490576327288916


data_agglomerative/experiment_q00_clean_answers_only_lemma.json
[[{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}]]
silhouette scores
[ 0.71511465  0.57585095  0.12880572 -0.14895021  0.          0.10121308
  0.1897864   0.40985221  0.15370259  0.71511465  0.34254195  0.08276271
 -0.0324656   0.15752146 -0.09188927 -0.18659705  0.00207294  0.22385718
  0.14139765 -0.23495085 -0.01373639  0.16136486  0.72281816 -0.28619045
  0.65641673 -0.04732858 -0.13753149  0.0406696   0.3097024   0.02569298
  0.41653726  0.12927914 -0.02819022]
max: 0.7228181599071285 arg: 22
mean: 0.15740136873888724
min: -0.2861904515577551 arg: 23
std: 0.2754581085129156


data_agglomerative/experiment_q00_clean_answers_only_lowercase.json
[[{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}]]
silhouette scores
[ 1.          0.33906622  0.31147198  0.3896024   0.50762669  0.02635475
  0.34088596  0.23057421  0.0578719   1.          0.12473275 -0.12188111
  0.23482722 -0.07891885 -0.18588596  0.15925534  0.1153429   0.1278618
 -0.03349541  0.1881989   0.26717071  0.23552708  0.54734939  0.23899027
  0.49019061 -0.01221678  0.07153584  0.31626339  0.34077365  0.36530942
 -0.18629615 -0.0971158  -0.03592121]
max: 1.0 arg: 0
mean: 0.22045612409224455
min: -0.18629615021842535 arg: 30
std: 0.27705564275125366


data_agglomerative/experiment_q00_clean_answers_only_stopwords.json
[[{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.86415123  0.78567446  0.17083764  0.09977374  0.          0.42562068
  0.22836134  0.31618471  0.08510531  0.84708892  0.43231207  0.10629846
 -0.1462578  -0.1588197   0.43691422 -0.07601636  0.43546104  0.56579267
  0.04721208  0.63842686 -0.1695268   0.39615517  0.65536655  0.
  0.80582321 -0.00603379 -0.03453565  0.09641194  0.19280873 -0.10238857
  0.00505768 -0.00428257  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.24057507401355163
min: -0.16952680138214796 arg: 20
std: 0.31310501650045935


data_agglomerative/experiment_q00_clean_answers_stopwords_lemma.json
[[{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.86415123  0.78567446  0.16671958  0.1055112   0.          0.43924022
  0.26971171  0.38242702  0.10909548  0.84708892  0.43231207  0.10830876
 -0.15191849 -0.17667277  0.43691422 -0.08170958  0.43546104  0.56579267
  0.04721208  0.63842686 -0.19105191  0.41529509  0.65536655  0.
  0.80582321 -0.00603379 -0.02634737  0.09641194  0.19280873 -0.10047663
  0.104884   -0.05229731  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.24600391442239436
min: -0.19105190699461527 arg: 20
std: 0.31508435247412653


data_agglomerative/experiment_q00_raw.json
[[{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}]]
silhouette scores
[ 1.          0.24294385  0.09838997 -0.19785707  0.          0.11874415
  0.20971934  0.34821627  0.11226698  1.          0.42506516  0.06669354
 -0.02926467  0.19203349  0.08103834 -0.17809382 -0.32395339 -0.10293765
 -0.06257275 -0.10649304  0.15762382  0.06163966  0.62141993 -0.28069784
  0.40785411 -0.07968703 -0.12220911  0.18955195  0.32474266  0.00228989
  0.43765285  0.10514986 -0.12265801]
max: 1.0 arg: 0
mean: 0.1392912561585287
min: -0.32395338664574835 arg: 16
std: 0.3060862636352918


data_agglomerative/experiment_q01_clean_answers_full.json
[[{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}]]
silhouette scores
[ 0.40177899  0.11602146  0.12877665  0.24562541 -0.10347547  0.31418446
  0.06740865  0.08642533  0.0617949   0.          0.39016939  0.13813291
  0.29810868  0.30205169  0.15662128  0.35060787  0.01469806  0.33313033
  0.45921927  0.46926135  0.27965573  0.2947947   0.30344458  0.
  0.02621827  0.39589877 -0.14471378 -0.09458149  0.20453536  0.16135813
  0.44027703  0.05825342 -0.20472913]
max: 0.46926134922167567 arg: 19
mean: 0.18033190161182874
min: -0.20472912741514177 arg: 32
std: 0.18229044225718866


data_agglomerative/experiment_q01_clean_answers_only_lemma.json
[[{'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}]]
silhouette scores
[ 0.97852023  0.12881623  0.22768634 -0.11455951  0.01745801  0.31715221
  0.71843327  0.09237417  0.14484753  0.26215487  0.97833874  0.48151492
  0.06190091  0.37117582  0.17023859  0.14914149  0.33621628  0.4006515
  0.07864541  0.48346591  0.281565    0.45270251  0.2204876  -0.02637557
  0.39763011  0.28816637  0.03241982  0.03077296 -0.06812383 -0.03504867
  0.41838512  0.0513893   0.26897391]
max: 0.9785202332115195 arg: 0
mean: 0.2605187138715563
min: -0.11455950938188457 arg: 3
std: 0.2606823200151062


data_agglomerative/experiment_q01_clean_answers_only_lowercase.json
[[{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'It is marked with keyword final.', 'idx': 56}]]
silhouette scores
[ 0.57884742 -0.08786626  0.10725621  0.16763097  0.1649873   0.0696047
 -0.09756538  0.17371822 -0.23068988  0.29853403  0.22636922  0.08931978
 -0.34749558  0.02170356  0.31403862  0.32396722  0.16907205  0.09461136
  0.47024523  0.68799396  0.          0.          0.15961303  0.
  0.15590749  0.12914043 -0.17110947  0.30704154  0.08080046  0.05209937
 -0.22647961 -0.18205882  0.        ]
max: 0.6879939615116254 arg: 19
mean: 0.10603748924114015
min: -0.34749558414766035 arg: 12
std: 0.221917261237168


data_agglomerative/experiment_q01_clean_answers_only_stopwords.json
[[{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}]]
silhouette scores
[ 0.2816099   0.32997507  0.12877665  0.26067474 -0.16764184  0.31418446
  0.19460676  0.06080462  0.0617949   0.          0.46829592  0.
  0.40559477  0.40302384  0.15662128  0.37977117 -0.08754578  0.40399457
  0.49662194  0.46926135  0.27965573  0.36267455  0.30344458  0.11482805
 -0.01178885  0.15470438 -0.10545502 -0.17997837  0.14141677  0.16135813
  0.45969005  0.05825342 -0.20472913]
max: 0.4966219422773811 arg: 18
mean: 0.18468177575703892
min: -0.20472912741514177 arg: 32
std: 0.20280893356091023


data_agglomerative/experiment_q01_clean_answers_stopwords_lemma.json
[[{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}]]
silhouette scores
[ 0.40177899  0.06433567  0.12877665  0.24674573 -0.10347547  0.31418446
  0.06740865  0.08642533  0.0617949   0.          0.39016939  0.13813291
  0.29038937  0.30131584  0.15662128  0.35060787  0.01469806  0.29788836
  0.45921927  0.46926135  0.27965573  0.29220069  0.30344458  0.
  0.02621827  0.37887259 -0.14471378 -0.09458149  0.20453536  0.16135813
  0.43739656  0.05825342 -0.20472913]
max: 0.46926134922167567 arg: 19
mean: 0.17679362136110333
min: -0.20472912741514177 arg: 32
std: 0.18132885932221537


data_agglomerative/experiment_q01_raw.json
[[{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}]]
silhouette scores
[ 0.23857868  0.2753563   0.08033932 -0.07600564  0.08487227  0.32548676
  0.24854479  0.32337168  0.10424874  0.          0.33030325  0.12216327
  0.35636675  0.23888769  0.19772125  0.1300043  -0.0658654   0.42383096
  0.38960239  0.40838379  0.26702425  0.44775884 -0.00283857  0.12112846
  0.30297651 -0.03378233  0.13872879  0.09968047  0.39901475 -0.10391025
 -0.11062774  0.07462294  0.33005553]
max: 0.44775883995506965 arg: 21
mean: 0.1838188726620725
min: -0.11062773818637481 arg: 30
std: 0.16443132013382183


data_agglomerative/experiment_q02_clean_answers_full.json
[[{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.61181705 -0.28077977 -0.22432962  0.07961316 -0.17507347  0.1875293
  0.7662601   0.12906425  0.06988472 -0.17871226  0.65569782 -0.14776991
  0.30645636  0.          0.06101368  0.         -0.07836327  0.02258158
  0.03674699  0.47807737  0.          0.153744    0.45021814 -0.08998941
  0.33107445  0.          0.3190434  -0.09897088  0.19333124  0.19071708
  0.15845963 -0.03092663  0.14749869]
max: 0.7662600979032402 arg: 6
mean: 0.12254284265981513
min: -0.2807797702675701 arg: 1
std: 0.2512929713717409


data_agglomerative/experiment_q02_clean_answers_only_lemma.json
[[{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.39178613  0.1508027   0.53193518  0.58128939  0.64464606  0.40335086
 -0.35474435 -0.04083153  0.08530344  0.39776556  0.12559338  0.34806433
 -0.28663694  0.          0.04279759  0.          0.39625926  0.18410326
  0.08867084  0.1904838  -0.44107356  0.20016397  0.07313326  0.29859544
  0.08774161  0.2105579   0.3464591   0.18484575  0.14568659 -0.5283205
  0.45279839  0.36032746  0.14623113]
max: 0.6446460591150398 arg: 4
mean: 0.16417531854294187
min: -0.5283204978559953 arg: 29
std: 0.27118220267936183


data_agglomerative/experiment_q02_clean_answers_only_lowercase.json
[[{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}]]
silhouette scores
[ 0.74951374  0.22125354  0.13306581  0.23943491  0.46135744  0.552107
  0.20651629  0.30202094 -0.26644984 -0.11743585 -0.20948752  0.4204324
  0.41644777  0.46057803  0.          0.31874685  0.67716651  0.01315906
 -0.28911927 -0.02146899 -0.18829118 -0.3359945  -0.04321722  0.13051375
 -0.0895836   0.          0.27238985  0.18731279  0.46461521 -0.2263321
  0.1069583  -0.26904892 -0.15117604]
max: 0.7495137380959436 arg: 0
mean: 0.12502985247273313
min: -0.3359945034689187 arg: 21
std: 0.29207361193139725


data_agglomerative/experiment_q02_clean_answers_only_stopwords.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.53707452 -0.10314419  0.40521373  0.06541782  0.49856132 -0.03124415
  0.55662882  0.2574929   0.1709099  -0.47382254  0.66638695  0.1381955
  0.11351868  0.          0.16703032  0.15203415  0.04322476  0.03772201
 -0.33154135  0.80022716 -0.14124529 -0.01952915  0.46070478 -0.18714568
 -0.02210403  0.08746088  0.32943086 -0.24425471  0.42103539 -0.13777718
  0.38845065  0.28610716 -0.0316163 ]
max: 0.8002271592232116 arg: 19
mean: 0.14725465766014087
min: -0.4738225408115939 arg: 9
std: 0.2905567644635372


data_agglomerative/experiment_q02_clean_answers_stopwords_lemma.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.55400373 -0.17641421  0.42891035  0.170574    0.50853457 -0.07403142
  0.57400543  0.03827306  0.21465924 -0.24884942  0.64054399  0.11403087
  0.49747214  0.          0.13945375  0.         -0.06154301 -0.12739184
 -0.37124919  0.85621941  0.          0.153744    0.46844213 -0.16788223
 -0.0350678  -0.0277995   0.1622745  -0.36133586  0.25782656 -0.16443569
  0.33036487  0.30698139  0.15947561]
max: 0.8562194096318622 arg: 19
mean: 0.14423604375849647
min: -0.3712491901446941 arg: 18
std: 0.2965085272746911


data_agglomerative/experiment_q02_raw.json
[[{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}]]
silhouette scores
[ 0.335674   -0.26418758  0.56163413  0.30741202  0.56115457  0.29256387
 -0.40257153  0.00666032  0.04583044  0.22083375  0.02232821  0.11339708
  0.41048401 -0.0850485  -0.00564833  0.          0.32671132  0.18134574
 -0.08149513 -0.02333243 -0.14338501 -0.15891716  0.15512874  0.35744044
  0.05269324  0.14631503  0.2635517   0.12255078  0.15359548 -0.26351798
  0.3017286   0.24601828 -0.01963568]
max: 0.5616341324525107 arg: 2
mean: 0.1132518905640056
min: -0.40257153231345216 arg: 6
std: 0.22494680981530116


data_agglomerative/experiment_q03_clean_answers_full.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}]]
silhouette scores
[-0.35178081  0.06471453  0.55158963  0.11918303  0.16931005  0.23076206
 -0.14529672 -0.01707469  0.60763099 -0.07545583 -0.12940826  0.
  0.36676949 -0.07490085  0.12431641 -0.15981846  0.21076636  0.17694585
  0.10214769  0.61933321  0.1388747   0.09007086 -0.03107754 -0.13678552
  0.16459656  0.22581254  0.04896638  0.27010586  0.30102145  0.21643411
  0.42772696  0.14155733]
max: 0.6193332134625416 arg: 19
mean: 0.13271991781708475
min: -0.35178080998503286 arg: 0
std: 0.2214672994496668


data_agglomerative/experiment_q03_clean_answers_only_lemma.json
[[{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[ 0.07946568  0.07866871  0.88157936  0.12822652  0.17275602  0.32822234
  0.4529718   0.05556256  0.50918396 -0.12956611  0.22586979  0.14929185
  0.11445131  0.59929442  0.          0.07510378  0.8133129  -0.01388202
 -0.03458616  0.65951959 -0.082694    0.53697999 -0.19856842 -0.08529233
  0.05915235  0.          0.04221871  0.30535309  0.86003592  0.
  0.55679046 -0.04372943]
max: 0.8815793637269549 arg: 2
mean: 0.2217403954394233
min: -0.1985684151342764 arg: 22
std: 0.30081452612771004


data_agglomerative/experiment_q03_clean_answers_only_lowercase.json
[[{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'Immutable object has no mutators', 'idx': 132}]]
silhouette scores
[ 0.0089564   0.5977295  -0.09917606  0.14102127  0.31927039  0.18553968
  0.23055727  0.48460797 -0.00158888  0.39008555  0.45583813 -0.22281293
  0.57481043 -0.10895386  0.11128803  0.36407235  0.07409792 -0.20947441
  0.02173012  0.28757497  0.49726829  0.22739464 -0.08835884 -0.16004377
  0.52897959  0.36998128 -0.13778243  0.32120305  0.14039005  0.
  0.22618422  0.11472736]
max: 0.5977294951193164 arg: 1
mean: 0.17640991545892828
min: -0.22281293012324077 arg: 11
std: 0.23718683097588839


data_agglomerative/experiment_q03_clean_answers_only_stopwords.json
[[{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}]]
silhouette scores
[ 0.27355068  0.31007553  0.18021428  0.1923304   0.16571393  0.18975303
  0.31113847  0.02105615 -0.00297454  0.06854533  0.36867003  0.
  0.19998772  0.19145957  0.          0.2001764  -0.3341192   0.16869658
 -0.09562319 -0.17675808  0.17573008  0.30125654  0.07912833  0.02743016
  0.11328734  0.          0.          0.23211175  0.2977817  -0.13196868
  0.40882198  0.31159697]
max: 0.4088219834644726 arg: 30
mean: 0.12647091484541706
min: -0.3341191988711767 arg: 16
std: 0.16703600906144217


data_agglomerative/experiment_q03_clean_answers_stopwords_lemma.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}]]
silhouette scores
[-0.35178081  0.06471453  0.55158963  0.11918303  0.16931005  0.23923275
 -0.14529672 -0.01707469  0.60763099 -0.07545583 -0.12940826  0.
  0.34215666 -0.07490085  0.12431641 -0.15981846  0.21076636  0.15494857
  0.10214769  0.61933321  0.1388747   0.09007086 -0.03107754 -0.11743542
  0.16459656  0.22581254  0.06936703  0.27010586  0.30102145  0.21643411
  0.42772696  0.14155733]
max: 0.6193332134625416 arg: 19
mean: 0.13277027187605916
min: -0.35178080998503286 arg: 0
std: 0.21978876839097075


data_agglomerative/experiment_q03_raw.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}], [{'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}]]
silhouette scores
[ 0.0322999   0.07147275  0.45540117  0.15060777 -0.16612251 -0.14179212
  0.07077398  0.00878444  0.71819694  0.30590009 -0.19725825  0.
  0.          0.59555929  0.          0.85986882  0.05351964  0.84494292
  0.42879848  0.79579514  0.03200629  0.54330811  0.12272919 -0.2301588
 -0.10445124  0.07665933  0.          0.17932999  0.88342712  0.
  0.05764085  0.22660066]
max: 0.8834271150671643 arg: 28
mean: 0.20855749773663212
min: -0.23015880397898586 arg: 23
std: 0.3270008179430133


data_agglomerative/experiment_q04_clean_answers_full.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}]]
silhouette scores
[ 0.25503658  0.68269719  0.8037966   0.44743267  0.91234168  0.51501399
  0.03917942  0.33215554  0.26747479 -0.21513136  0.7978516   0.53063688
  0.24797813 -0.22870151  0.26422835 -0.17386318  0.3031589   0.48008245
  0.79923081  0.55400535  0.1019214   0.50590649  0.25662297  0.14173489
  0.22846332  0.52752602  0.36910038  0.67918843  0.27621407  0.03289563
 -0.11991628  0.45174093 -0.46570264]
max: 0.9123416826714926 arg: 4
mean: 0.3212212281047584
min: -0.46570264289630914 arg: 32
std: 0.32533000384773786


data_agglomerative/experiment_q04_clean_answers_only_lemma.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}], [{'data': 'It is not pure as it prints something to the standard output', 'idx': 161}]]
silhouette scores
[ 0.17269251 -0.20196341  0.70309499  0.67559507  0.48019443  0.67149056
 -0.30415785  0.0358645  -0.13147637 -0.54508303  0.48477715  0.08290987
  0.121836    0.23972529 -0.03517056  0.60396679 -0.04469971 -0.088237
 -0.23204165 -0.09690687 -0.18301439  0.06508499  0.75763969  0.00390803
  0.          0.53558468 -0.15304902  0.22686212 -0.07361367  0.59703862
  0.56171448  0.19402105 -0.14606218]
max: 0.7576396896870994 arg: 22
mean: 0.1508643976579135
min: -0.5450830302355504 arg: 9
std: 0.34036938940995043


data_agglomerative/experiment_q04_clean_answers_only_lowercase.json
[[{'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'It produces a side effect.', 'idx': 158}], [{'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.30029694  0.52769432  0.50034488 -0.05735798 -0.18315049  0.43445333
  0.1068791   0.09433428  0.01715373 -0.19380689  0.25599286  0.26738092
  0.45084886  0.06519049  0.38356424  0.19171691 -0.17358046  0.32403224
  0.55376843  0.35204304  0.08677844  0.56736053  0.11120901  0.3638007
  0.21167889  0.54634403 -0.10034702 -0.13318497  0.31152878  0.26968636
  0.49819531  0.52515766  0.63245829]
max: 0.6324582928525164 arg: 32
mean: 0.24571105318453304
min: -0.19380689304585322 arg: 9
std: 0.24268519191052218


data_agglomerative/experiment_q04_clean_answers_only_stopwords.json
[[{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}]]
silhouette scores
[ 0.57149226  0.67422216  0.75977059 -0.23302354  0.86569876  0.01188668
 -0.3356884  -0.13160155  0.41917293  0.22549006  0.73421314  0.41224118
  0.77675784  0.03321209  0.36940211 -0.25893028  0.16565195  0.16156205
  0.72890966  0.42701571 -0.19722626  0.27336799  0.44935443 -0.10129426
  0.21204107  0.49981989  0.01112074  0.59428353 -0.19172801  0.15780185
  0.28550079  0.40659959  0.2181284 ]
max: 0.8656987646936162 arg: 4
mean: 0.27258258041316413
min: -0.3356883995887399 arg: 6
std: 0.33398637106573814


data_agglomerative/experiment_q04_clean_answers_stopwords_lemma.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}]]
silhouette scores
[ 0.25503658  0.68269719  0.8037966   0.44743267  0.91234168  0.51501399
  0.03917942  0.33215554  0.26747479 -0.21513136  0.7978516   0.53063688
  0.24797813 -0.22870151  0.26422835 -0.17386318  0.3031589   0.48008245
  0.79923081  0.55400535  0.1019214   0.50590649  0.25662297  0.14173489
  0.22846332  0.52752602  0.36910038  0.67918843  0.27621407  0.03289563
 -0.11991628  0.45174093 -0.46570264]
max: 0.9123416826714926 arg: 4
mean: 0.3212212281047584
min: -0.46570264289630914 arg: 32
std: 0.32533000384773786


data_agglomerative/experiment_q04_raw.json
[[{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.46983613  0.43098907  0.75088361  0.39379747  0.59370433  0.38688104
 -0.1413064   0.05885832  0.19605588 -0.12955471  0.53600404  0.32490595
 -0.09970896  0.25443698  0.56649194 -0.1035813   0.14890772  0.37491911
  0.5067753   0.40522972  0.25339808  0.40966658  0.05561509  0.00868373
  0.3226729   0.28297834  0.39516602  0.33799707  0.42088927 -0.04075363
  0.30067153  0.41863265  0.40913446]
max: 0.7508836118191318 arg: 2
mean: 0.2878568892863498
min: -0.14130640122015767 arg: 6
std: 0.2240397104128466


data_agglomerative/experiment_q05_clean_answers_full.json
[[{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.42065347  0.26860511  0.37761951  0.20733392 -0.01887701  0.38489944
  0.11629747  0.40502397  0.04568633  0.41323587  0.19489479  0.08629991
  0.15689372  0.17778776  0.00200247  0.26811318 -0.02071885  0.45005442
  0.11877063 -0.02461469  0.          0.1938529   0.3321397   0.18679548
  0.22620876  0.2123171   0.03280943  0.36731292  0.          0.39741176
  0.4357484   0.21437826  0.08046528]
max: 0.45005442356247033 arg: 17
mean: 0.20331519456749506
min: -0.024614687466048356 arg: 19
std: 0.15334613471201297


data_agglomerative/experiment_q05_clean_answers_only_lemma.json
[[{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}]]
silhouette scores
[ 0.51422642 -0.08660618 -0.09432048  0.07487922  0.24564937  0.33957869
  0.13358455  0.33749396  0.33381308 -0.12314307  0.01419587  0.3303426
  0.15445816  0.04868603  0.37170305 -0.18958882  0.24619253  0.17408976
  0.25671163  0.4749951  -0.08604678  0.4704224   0.24440693  0.06335717
  0.16009365  0.18939038  0.25149815  0.31376927  0.          0.16852371
 -0.00264009 -0.15284117  0.4207932 ]
max: 0.5142264219031082 arg: 0
mean: 0.16962631094739816
min: -0.1895888198890866 arg: 15
std: 0.19128814845495923


data_agglomerative/experiment_q05_clean_answers_only_lowercase.json
[[{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}]]
silhouette scores
[ 1.          0.29488271  0.41324461  0.16826248  0.43115886  0.61463964
  0.027091    0.20622869 -0.37180143  0.55739363  0.02113904 -0.32474801
  0.17322194 -0.01129017 -0.04827321  0.01834076  0.39335008 -0.12756537
  0.27461261  1.          0.          0.24227136  0.16972854  0.48617497
 -0.24538178  0.13773303  0.48014674 -0.06048472 -0.09275982  0.3639837
  0.39089842  0.59876006 -0.31650655]
max: 1.0 arg: 0
mean: 0.20801369065140238
min: -0.37180142801014504 arg: 8
std: 0.3343449465659841


data_agglomerative/experiment_q05_clean_answers_only_stopwords.json
[[{'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}]]
silhouette scores
[-0.00543596  0.05113502  0.47471839  0.21576532  0.03849922  0.36451845
  0.15502542  0.43473414  0.          0.45314802  0.20329334  0.08989152
  0.1633147   0.18679707 -0.02802855  0.320513    0.03444436  0.46020702
  0.13837746  0.21416674  0.02331915  0.12714597  0.27391202  0.22014723
  0.280241    0.18160824 -0.16455647  0.33356098  0.          0.3584038
  0.14413752 -0.07065059  0.11756856]
max: 0.47471838654901155 arg: 2
mean: 0.17545218448114258
min: -0.1645564673700663 arg: 26
std: 0.16162167321824245


data_agglomerative/experiment_q05_clean_answers_stopwords_lemma.json
[[{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.42065347  0.26860511  0.37761951  0.20733392 -0.01887701  0.38014724
  0.11177819  0.40502397  0.04568633  0.41323587  0.19489479  0.08629991
  0.17949371  0.17778776  0.00200247  0.26811318 -0.02071885  0.45005442
  0.11877063 -0.02461469  0.          0.1938529   0.30399193  0.18679548
  0.23644274  0.2123171   0.03280943  0.36731292  0.          0.39741176
  0.4357484   0.21437826  0.08046528]
max: 0.45005442356247033 arg: 17
mean: 0.20317624670541176
min: -0.024614687466048356 arg: 19
std: 0.152516778697224


data_agglomerative/experiment_q05_raw.json
[[{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}]]
silhouette scores
[ 0.25359974  0.14037413  0.29184066  0.13839405  0.31422189  0.332684
  0.02789634  0.33030026  0.          0.17593028  0.36674323  0.25061098
  0.14944237  0.11818647  0.18506158  0.1805005   0.38866025  0.44303455
  0.2693065  -0.0601366   0.23982967  0.21723352  0.34218489  0.19701398
  0.13611174 -0.18090992  0.00436227  0.35585936  0.         -0.01377546
 -0.05324598  0.09799004 -0.09793722]
max: 0.4430345465085248 arg: 17
mean: 0.16792024426537722
min: -0.1809099213272568 arg: 25
std: 0.1549909374474683


data_agglomerative/experiment_q06_clean_answers_full.json
[[{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}]]
silhouette scores
[ 0.36564768  0.07948113  0.33708041 -0.00571326  0.0702938   0.41772614
  0.62852516  0.24793133 -0.11908775  0.24738138  0.23436051  0.11307481
 -0.13569338 -0.03883349  0.24046829  0.2300743   0.50412969  0.52638663
  0.21511633  0.21917858 -0.19781585  0.13085992  0.10600487  0.37202014
  0.34122142  0.4785301   0.51029279 -0.10527393  0.15074388 -0.28041968
 -0.12751094  0.25911195 -0.02289848]
max: 0.6285251569522028 arg: 6
mean: 0.18158771044934016
min: -0.28041968257364147 arg: 29
std: 0.22756068148513445


data_agglomerative/experiment_q06_clean_answers_only_lemma.json
[[{'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}]]
silhouette scores
[ 0.19434201 -0.00677906 -0.0696962  -0.42170795 -0.15456684  0.20256095
  0.58835138  0.00941052 -0.07529001  0.49659068  0.53862596 -0.10661012
  0.14400832  0.5414658   0.43722266 -0.1706649   0.42365489  0.22600529
 -0.0364193  -0.18586818  0.53052751 -0.02628709  0.1384457   0.3045241
  0.42924912 -0.15518243  0.0153483  -0.07267876  0.31871088  0.00956084
 -0.00142383  0.01588004  0.12711963]
max: 0.5883513780494314 arg: 6
mean: 0.12752817848980758
min: -0.421707948733444 arg: 3
std: 0.25674985828994373


data_agglomerative/experiment_q06_clean_answers_only_lowercase.json
[[{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}], [{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'It depends on the current state of the object.', 'idx': 225}], [{'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'return a non-local variable', 'idx': 226}]]
silhouette scores
[ 0.06521369 -0.14179867  0.43755315  0.44555993  0.34374763  0.59230611
  0.20139456  0.34907303  0.06834475  0.11278723  0.51844398  0.227868
  0.02326366 -0.00990764  0.16840933 -0.02010683 -0.10415364  0.15309726
  0.54541446  0.3100191   0.          0.          0.45648455  0.46313818
  0.3562498   0.17967557 -0.03961144  0.23051198  0.23934343  0.43981945
  0.          0.45270168 -0.26293318]
max: 0.5923061093911935 arg: 5
mean: 0.2061184576877045
min: -0.26293318107054975 arg: 32
std: 0.22024056458605398


data_agglomerative/experiment_q06_clean_answers_only_stopwords.json
[[{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.07777452  0.28326883  0.14991878  0.03421978 -0.05526067 -0.26745938
 -0.29455653  0.17258651  0.20227143  0.07164256  0.28914159 -0.02094911
  0.29480042  0.37177634  0.49485522  0.24977112  0.06572179  0.00378829
  0.1822812   0.36578328 -0.12990094  0.43056259 -0.10847941  0.3596842
  0.3601805   0.20020965  0.20575724  0.31394625  0.17776569  0.22661798
  0.          0.19889002 -0.0812922 ]
max: 0.49485522437766993 arg: 14
mean: 0.14622174370514326
min: -0.29455652929394505 arg: 6
std: 0.1916894040394881


data_agglomerative/experiment_q06_clean_answers_stopwords_lemma.json
[[{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}]]
silhouette scores
[ 0.36564768  0.07948113  0.33708041 -0.00571326  0.0702938   0.41772614
  0.62852516  0.24793133 -0.11908775  0.24738138  0.23436051  0.11307481
 -0.13569338 -0.03883349  0.24046829  0.2300743   0.50412969  0.52638663
  0.21511633  0.21917858 -0.19781585  0.13085992  0.10600487  0.37202014
  0.34122142  0.4785301   0.51029279 -0.10527393  0.15074388 -0.28041968
 -0.12751094  0.25911195 -0.02289848]
max: 0.6285251569522028 arg: 6
mean: 0.18158771044934016
min: -0.28041968257364147 arg: 29
std: 0.22756068148513445


data_agglomerative/experiment_q06_raw.json
[[{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}]]
silhouette scores
[-0.08404365 -0.24825229 -0.24369307 -0.52354954 -0.0670412   0.14159679
 -0.34300197  0.65303456 -0.02684296  0.27368695  0.17249373  0.10003884
  0.41458433  0.48374304  0.36474378  0.78120401  0.00338315  0.61714237
  0.         -0.20043661  0.28955398  0.38094088  0.08166352  0.57547343
  0.32770546 -0.33743024  0.08021678  0.13869207  0.10319428  0.11695893
 -0.25370557  0.06654537 -0.39063662]
max: 0.781204006079927 arg: 15
mean: 0.10448371299505892
min: -0.5235495420417786 arg: 3
std: 0.318883250133609


data_agglomerative/experiment_q07_clean_answers_full.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}]]
silhouette scores
[ 5.76060715e-01  3.08077857e-01  9.66538975e-02 -4.05249877e-02
  1.02192057e-01  0.00000000e+00  0.00000000e+00  2.45873243e-01
  2.49075593e-01  1.42088023e-01  6.62947695e-01 -7.51494054e-02
  2.34260650e-02 -3.84743094e-02  3.05434105e-02  2.77027392e-01
  7.16110491e-01  1.57169322e-01 -2.66834919e-01 -3.29505216e-01
  1.56742098e-01 -1.42731114e-01  2.68145144e-01  4.44071508e-02
  8.79157413e-02 -3.12806241e-04  7.45966593e-02  1.58438520e-01
  1.53492719e-02 -1.65478707e-01  2.88594126e-01 -1.58216024e-01
  6.63582513e-01]
max: 0.7161104911831325 arg: 16
mean: 0.1250845302078907
min: -0.32950521636837415 arg: 19
std: 0.24925212296162239


data_agglomerative/experiment_q07_clean_answers_only_lemma.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}], [{'data': 'it should be f()(1)', 'idx': 292}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}, {'data': 'return another function', 'idx': 304}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}]]
silhouette scores
[ 0.50875805  0.18305727  0.08908172  0.          0.54960804  0.
  0.          0.21666305  0.22682218  0.114701    0.56966824  0.21895601
  0.04027535  0.18906835  0.05120612  0.12537521  0.65851515  0.03272519
 -0.06667134 -0.01029438  0.52524153 -0.01606865  0.26623342  0.12127426
  0.07516598  0.23815393  0.14924319  0.34833157  0.04617741 -0.25636851
  0.25178371 -0.06933689  0.66901619]
max: 0.6690161896620515 arg: 32
mean: 0.18322310201165687
min: -0.25636851428924745 arg: 29
std: 0.22189568445393507


data_agglomerative/experiment_q07_clean_answers_only_lowercase.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}]]
silhouette scores
[ 0.05550087  0.55546494  0.04146752  0.23298258  0.40533679 -0.05849426
  0.207343    0.08123518  0.36122021  0.3497875   0.53946245  0.00943683
  0.32079449  0.19400549  0.25637856  0.30125239  0.47615923  0.21188084
  0.09308213  0.48618244  0.11876875  0.32580414  0.21683173  0.18777878
  0.17516482  0.48108395 -0.00141588  0.41647106  0.58515556 -0.09715969
  0.34359097  0.56664401  0.5213117 ]
max: 0.5851555550101158 arg: 28
mean: 0.27153057793104224
min: -0.09715969359755201 arg: 29
std: 0.1915145133638686


data_agglomerative/experiment_q07_clean_answers_only_stopwords.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}]]
silhouette scores
[ 0.59011264  0.31578571  0.08116986 -0.04595634  0.08104046  0.
  0.          0.27546463  0.19344832  0.12999422  0.67717921 -0.04211999
  0.00263384  0.02171505 -0.03265624  0.21442291  0.73458432  0.14080836
 -0.27913197 -0.33108411  0.13383723 -0.1454954   0.2720583   0.04824611
  0.04754788 -0.02753486  0.09709645  0.17388481  0.01113403 -0.18083084
  0.2704024  -0.11209595  0.68505242]
max: 0.7345843188681426 arg: 16
mean: 0.12123374096485753
min: -0.3310841074015257 arg: 19
std: 0.2528116373310097


data_agglomerative/experiment_q07_clean_answers_stopwords_lemma.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}]]
silhouette scores
[ 5.76060715e-01  3.08077857e-01  9.66538975e-02 -4.05249877e-02
  1.02192057e-01  0.00000000e+00  0.00000000e+00  2.45873243e-01
  2.07603493e-01  1.42088023e-01  6.62947695e-01 -6.96298560e-02
  2.07446028e-02 -4.14487889e-02  1.70141056e-02  2.67928748e-01
  7.16110491e-01  1.57169322e-01 -2.66834919e-01 -3.29505216e-01
  1.60590627e-01 -1.42731114e-01  2.63077892e-01  5.84919348e-02
  8.40798198e-02 -3.12806241e-04  8.99728760e-02  1.69929887e-01
  1.53492719e-02 -1.65478707e-01  2.88594126e-01 -1.58216024e-01
  6.63582513e-01]
max: 0.7161104911831325 arg: 16
mean: 0.1242257811197799
min: -0.32950521636837415 arg: 19
std: 0.24848909500997518


data_agglomerative/experiment_q07_raw.json
[[{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}]]
silhouette scores
[ 0.49114643  0.18564222  0.20456162 -0.07876895  0.45761252  0.
  0.          0.28049611  0.17169818  0.11001212  0.57899677  0.36389644
  0.01276806  0.26678047  0.12987227  0.12080217  0.66593537 -0.01993012
 -0.0888721  -0.05074771  0.30150842 -0.02622039  0.          0.16601181
  0.06256432  0.21190091  0.5060395   0.22804268  0.17543148 -0.16948171
  0.25927688 -0.00593403  0.67740924]
max: 0.677409238474177 arg: 32
mean: 0.18752881765736631
min: -0.16948170927381337 arg: 29
std: 0.21876944502210474


data_agglomerative/experiment_q08_clean_answers_full.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Just because', 'idx': 336}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.17432954  0.          0.05362856  0.1448438   0.29182035
  0.02725785  0.14707243  0.48456861  0.1087889  -0.01027581  0.06019832
  0.20015254  0.34905411  0.24440678  0.56771779  0.44367964  0.10036984
 -0.09475726  0.34297889  0.          0.28506967 -0.07518074  0.19208339
 -0.29752889  0.05542746  0.19436672  0.16505053  0.          0.51018071
  0.18713231  0.21327507]
max: 0.5677177893076119 arg: 15
mean: 0.14740787644513553
min: -0.2975288858203159 arg: 24
std: 0.19489696084551944


data_agglomerative/experiment_q08_clean_answers_only_lemma.json
[[{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'Just because', 'idx': 336}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.16064656  0.20806202  0.14332048 -0.04372663  0.23859461
 -0.08231514  0.62979976  0.54508685  0.15213283  0.13421837  0.10187584
  0.4411722   0.19048365  0.07298532  0.58346881  0.4423339   0.13185515
 -0.01015518  0.24943944  0.38662728 -0.42295253  0.13242771  0.43000951
 -0.15423741  0.04172507  0.09241852  0.28983285  0.         -0.13774513
  0.30810057 -0.14256739]
max: 0.6297997638734284 arg: 7
mean: 0.14973827393815253
min: -0.42295252557985413 arg: 21
std: 0.23836885244513564


data_agglomerative/experiment_q08_clean_answers_only_lowercase.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': "it's the regular expression", 'idx': 308}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[-0.15283778  0.11174383 -0.2030791   0.04856775  0.32964487  0.06921149
  0.39136732 -0.24112221  0.18461204 -0.15624945 -0.20070508 -0.17703108
  0.20430741  0.146368    0.23755835  0.80433616  0.42633936  0.08049832
 -0.04073555  0.2828643   0.06736747  0.06571514  0.30636765  0.1475902
  0.29014965  0.23260673  0.50778422 -0.1158825   0.          0.49141824
  0.18573973 -0.00842708]
max: 0.8043361628106027 arg: 15
mean: 0.13487776328930587
min: -0.24112220744642335 arg: 7
std: 0.23709082053956243


data_agglomerative/experiment_q08_clean_answers_only_stopwords.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Just because', 'idx': 336}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.15259519  0.30402001  0.2046927   0.01113217  0.27639267
  0.06314527  0.22997985  0.54019066  0.40667465  0.06699633  0.12601774
  0.18120836  0.32487095  0.11258936  0.45316097  0.25441032  0.14311857
  0.12100604  0.32019813  0.          0.53074678 -0.18325385  0.05310174
  0.30619     0.16365537  0.3266322   0.35144047  0.          0.46522675
  0.14635057  0.23285982]
max: 0.5401906638657533 arg: 8
mean: 0.1993799815813197
min: -0.18325385228697422 arg: 22
std: 0.1782013155788653


data_agglomerative/experiment_q08_clean_answers_stopwords_lemma.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Just because', 'idx': 336}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.         -0.17432954  0.          0.05362856  0.14397086  0.29182035
  0.04238357  0.14707243  0.48456861  0.11733575 -0.01027581  0.05293992
  0.20015254  0.34549831  0.24440678  0.56771779  0.44367964  0.10036984
 -0.09475726  0.34297889  0.          0.29945502 -0.07518074  0.19208339
 -0.29752889  0.05542746  0.19436672  0.17307368  0.          0.51018071
  0.18713231  0.21327507]
max: 0.5677177893076119 arg: 15
mean: 0.14848268624599392
min: -0.2975288858203159 arg: 24
std: 0.1949280318191869


data_agglomerative/experiment_q08_raw.json
[[{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'Just because', 'idx': 336}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': "it's the regular expression", 'idx': 308}]]
silhouette scores
[ 0.          0.25426689  0.11856585  0.43749263  0.          0.17822707
 -0.04409815  0.29224985  0.15723711  0.74649144  0.18489216  0.0993278
 -0.11956669 -0.01973692  0.05916134  0.11055046 -0.13900678  0.03544867
  0.28734845  0.11286628  0.22366083  0.52666644 -0.02518266  0.26072182
  0.13158096  0.13616921  0.22082462  0.54203469  0.          0.07719948
  0.13716737  0.30619096]
max: 0.7464914432650306 arg: 9
mean: 0.1652734750952845
min: -0.1390067789973396 arg: 16
std: 0.19206259427609948


data_agglomerative/experiment_q09_clean_answers_full.json
[[{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[ 0.14360739 -0.27819887  0.06632086  0.18394164 -0.25367854  0.2326453
  0.23651517  0.07222661  0.32371394  0.31620544 -0.22930932  0.12417285
 -0.2796361   0.32370933 -0.05138126  0.16789989  0.22130726  0.03037912
  0.03401674  0.17048625  0.27019062  0.17048625  0.          0.04042598
  0.16266609 -0.30803604  0.15927323 -0.34163264  0.3502504  -0.21447998
  0.07819965  0.          0.3164632 ]
max: 0.35025040307399224 arg: 28
mean: 0.06784092224939854
min: -0.34163263866630994 arg: 27
std: 0.20396011036407022


data_agglomerative/experiment_q09_clean_answers_only_lemma.json
[[{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}]]
silhouette scores
[ 0.2109947   0.         -0.01236515  0.32053657 -0.21913936  0.24112345
 -0.01839146 -0.03020255  0.35774477  0.30032164 -0.24664682  0.07741219
  0.05307272 -0.16488652 -0.09786084  0.0674834   0.39139042  0.1125146
 -0.09589821  0.08693263  0.36484363 -0.21637928  0.06540437  0.16064582
  0.05766091 -0.3273936   0.07619894 -0.30926839  0.          0.
  0.1178491   0.09560083  0.46406787]
max: 0.4640678743340882 arg: 32
mean: 0.05707170957590256
min: -0.3273936024667949 arg: 25
std: 0.199957956644526


data_agglomerative/experiment_q09_clean_answers_only_lowercase.json
[[{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'It returns the wrapped function.', 'idx': 369}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}]]
silhouette scores
[-0.65412027  0.24246993  0.50568899 -0.08570203  0.3463534   0.23539489
  1.          0.25704187  0.23842765  0.74225889  0.38715723  0.4832986
  0.13969294 -0.40895513  0.63034067  1.          0.64063584  0.64298606
  0.35621144  0.77143763  0.24908743  0.75881179  0.10529156  0.39891238
 -0.23195892  0.2668231   0.         -0.36029075  0.71714714  0.55239058
 -0.09070043  0.51967485  0.27133422]
max: 1.0 arg: 6
mean: 0.32203459190024697
min: -0.654120271023774 arg: 0
std: 0.38629076436829285


data_agglomerative/experiment_q09_clean_answers_only_stopwords.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}]]
silhouette scores
[ 0.25968293 -0.19487807 -0.1715378   0.00303966  0.24987112  0.00346081
  0.18671365 -0.03154851  0.23958656  0.20605728  0.         -0.07278705
 -0.07276321  0.28009694  0.          0.02673521  0.43640072  0.06331091
 -0.05694037  0.53017235  0.41845486  0.55461642 -0.25345147 -0.0916634
 -0.04902859 -0.24116036  0.17704215 -0.39220533  0.27458299 -0.14446055
 -0.02280944  0.          0.04120372]
max: 0.5546164240308952 arg: 21
mean: 0.0653270950952657
min: -0.3922053298973447 arg: 27
std: 0.22430223575505126


data_agglomerative/experiment_q09_clean_answers_stopwords_lemma.json
[[{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[ 0.14360739 -0.27819887  0.06525235  0.18129563 -0.25017619  0.2326453
  0.12712333  0.07222661  0.32371394  0.31620544 -0.22930932  0.14986854
 -0.20886667  0.32370933 -0.05547783  0.11913515  0.22130726  0.03037912
  0.03401674  0.11891353  0.27019062  0.11891353  0.          0.04042598
  0.16266609 -0.30803604  0.15927323 -0.34163264  0.32173588 -0.17282853
  0.07819965  0.          0.3164632 ]
max: 0.3237139410978536 arg: 8
mean: 0.06311338633196238
min: -0.34163263866630994 arg: 27
std: 0.19418343450582867


data_agglomerative/experiment_q09_raw.json
[[{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}]]
silhouette scores
[ 0.3102622   0.05352548  0.04441121  0.22011379  0.18358492  0.33383643
 -0.03095557 -0.09422413  0.14638855  0.007673   -0.12940133  0.27422471
 -0.11859869  0.         -0.18415032  0.06886557  0.54990356  0.19978175
  0.          0.15027033  0.54156851  0.07142062 -0.12195436 -0.05957132
 -0.01911853 -0.21860409 -0.19191169  0.         -0.25981468  0.03684056
  0.21849944  0.21166989  0.39712707]
max: 0.5499035589778761 arg: 16
mean: 0.07853523855683144
min: -0.25981467648270185 arg: 28
std: 0.2024814816881057


data_agglomerative/experiment_q10_clean_answers_full.json
[[{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'Just because', 'idx': 404}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}]]
silhouette scores
[-0.03111428  0.          0.5219843   0.42997014 -0.05385584  0.62449202
  0.02237946  0.24719896  0.37056828  0.43483963 -0.09371157  0.
  0.34585188  0.5777524   0.35118    -0.14775172  0.33555941  0.42896056
 -0.00202782  0.61444439 -0.16533779  0.37804213  0.52026616 -0.12775601
  0.17699821  0.61673796  0.37030816  0.13110975 -0.01837361  0.
 -0.14845556 -0.28763933]
max: 0.6244920184819793 arg: 5
mean: 0.20070688370424464
min: -0.28763933330272445 arg: 31
std: 0.2715713301060804


data_agglomerative/experiment_q10_clean_answers_only_lemma.json
[[{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[ 0.07488141  0.          0.57358664  0.18379878 -0.1177368   0.58403196
  0.31772527  0.3084927   0.01821239  0.18630556  0.27440663  0.
 -0.22627943  0.03961794  0.03884126 -0.11055447  0.28433757  0.
  0.1619453   0.33433749  0.04678611  0.35066581  0.22059601  0.34253427
  0.39853821  0.53387963  0.18238106 -0.04196416  0.19281456  0.
  0.11793204  0.05245658]
max: 0.584031957909444 arg: 5
mean: 0.166330322355916
min: -0.22627942554733887 arg: 12
std: 0.19793672530453668


data_agglomerative/experiment_q10_clean_answers_only_lowercase.json
[[{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}], [{'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[ 0.10466434 -0.15379256  0.64842821  0.56851815  0.02896833  0.41221213
 -0.29085814  0.09144809  0.10791542  0.44377179  0.54628536  0.03796834
  0.43605433 -0.26026573  0.15942565 -0.06308266  0.26914803 -0.18311949
  0.41309504  0.59211517 -0.20425931  0.18514991 -0.18087946 -0.24467341
 -0.25444283  0.52305153  0.27631729  0.30650414  0.75169822  0.
 -0.04986224  0.15946769]
max: 0.7516982192300194 arg: 28
mean: 0.16178035448317923
min: -0.2908581408130811 arg: 6
std: 0.3009144592882512


data_agglomerative/experiment_q10_clean_answers_only_stopwords.json
[[{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[-0.05020365  0.          0.53303057  0.42997014 -0.02643383  0.63114533
  0.00194868  0.2140167   0.33386488  0.43573115 -0.14752177  0.
  0.34382375  0.57099329  0.36276339 -0.10392217  0.27409973  0.42653226
 -0.05951363  0.62096657 -0.2085102   0.34448048  0.52685462 -0.09459117
  0.16825193  0.62817951  0.330242    0.12929894 -0.01490838  0.
 -0.19064383 -0.3241837 ]
max: 0.6311453254641833 arg: 5
mean: 0.19018004989388837
min: -0.32418370239965616 arg: 31
std: 0.27692159459967697


data_agglomerative/experiment_q10_clean_answers_stopwords_lemma.json
[[{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Just because', 'idx': 404}]]
silhouette scores
[-0.04079453  0.          0.5219843   0.42997014 -0.08050645  0.62449202
  0.02237946  0.24719896  0.37056828  0.43483963 -0.09371157  0.
  0.34585188  0.5777524   0.35118    -0.14775172  0.33555941  0.4271453
 -0.00202782  0.61444439 -0.16800405  0.37804213  0.53300179 -0.13576058
  0.17699821  0.61673796  0.37030816  0.12303234 -0.01407786  0.
 -0.19072617 -0.28763933]
max: 0.6244920184819793 arg: 5
mean: 0.1981402094837879
min: -0.28763933330272445 arg: 31
std: 0.2752311848753109


data_agglomerative/experiment_q10_raw.json
[[{'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'Just because', 'idx': 404}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}]]
silhouette scores
[ 0.1022485   0.          0.41613925  0.13031263  0.26761888  0.32832069
 -0.00392689  0.27173774  0.02276434  0.39165825  0.07369845  0.
  0.05403508  0.04308143  0.23003709  0.01525487 -0.23935039 -0.01618797
  0.19742656  0.31964729  0.18956    -0.04601571  0.11365763  0.27571634
  0.23307788  0.37998875  0.08713015  0.16075173  0.19400602  0.
 -0.10915104 -0.08058858]
max: 0.4161392499156527 arg: 2
mean: 0.12508278000047965
min: -0.23935038734648167 arg: 16
std: 0.15656216548417498


data_agglomerative/experiment_q11_clean_answers_full.json
[[{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[-0.50598118 -0.15875828 -0.16151013  0.34058814  0.21312594  0.48474039
 -0.14105472  0.69438028  0.20163264  0.25167798  0.63357711  0.2101172
  0.04926253 -0.32668399 -0.06386632  0.28788962 -0.34237293  0.39745232
  0.29172636  0.33597909 -0.22970418  0.73059748 -0.3576315  -0.37620451
 -0.17108942  0.          0.         -0.14023778 -0.14982341  0.24101852
  0.32604045  0.          0.79936653]
max: 0.7993665253652315 arg: 32
mean: 0.1019470972822406
min: -0.5059811836173403 arg: 0
std: 0.33989158854622964


data_agglomerative/experiment_q11_clean_answers_only_lemma.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}]]
silhouette scores
[ 0.          0.31695594  0.294908    0.07396904 -0.32576358  0.1791273
 -0.34535005 -0.01640346  0.24453226  0.62548409  0.36517932  0.13350207
  0.37185546 -0.29111932  0.08137406  0.44239056  0.36856627  0.40186784
  0.33710754  0.31209284 -0.23103598 -0.13942152 -0.2022321  -0.16028683
 -0.01765127 -0.12933155 -0.05256478  0.04804051 -0.16624234 -0.16889471
  0.03021795  0.10335147  0.41665899]
max: 0.6254840917963856 arg: 9
mean: 0.08790557720476992
min: -0.3453500506588692 arg: 6
std: 0.2543241313699934


data_agglomerative/experiment_q11_clean_answers_only_lowercase.json
[[{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'r yields 4', 'idx': 443}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}, {'data': 'Instgant call of inline-defined function', 'idx': 472}]]
silhouette scores
[ 0.25608956 -0.26875827  0.49080557  0.03229964 -0.11656633  0.45547866
  0.34743672 -0.01484478  0.39157381  0.6020367   0.62695053 -0.00297878
  0.63641265 -0.07680231  0.45723573  0.22061275 -0.24629538  0.29752866
  0.32309515  0.30705412  0.17395679  0.4082105   0.38573275  0.12409708
  0.1283817   0.         -0.09426637  0.11053178  0.03591425  0.00589797
  0.39338528  0.          0.41923917]
max: 0.6364126508313356 arg: 12
mean: 0.20634682688403186
min: -0.2687582689813324 arg: 1
std: 0.24448434370592168


data_agglomerative/experiment_q11_clean_answers_only_stopwords.json
[[{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'r yields 4', 'idx': 443}, {'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}]]
silhouette scores
[ 0.04619311 -0.033198    0.17262252  0.3132834  -0.18085606 -0.1545441
  0.54295537  0.72752196  0.34161272  0.53548805 -0.66381128  0.22115368
  0.35786542  0.62423173  0.33105738  0.40315096  0.41427546  0.43210412
  0.32057337 -0.11798098 -0.05725821  0.37454493  0.         -0.23502126
  0.13399783 -0.30128414 -0.1471745   0.1064602   0.65268147  0.2345461
  0.29747127  0.          0.63029289]
max: 0.7275219557113796 arg: 7
mean: 0.19160470833518808
min: -0.6638112841710125 arg: 10
std: 0.31457163392928694


data_agglomerative/experiment_q11_clean_answers_stopwords_lemma.json
[[{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[-0.50598118  0.06694719 -0.07501914  0.35672877  0.21312594  0.48474039
 -0.14105472  0.69438028  0.1289613   0.25167798  0.64133802  0.21216504
 -0.01890961 -0.32668399  0.06663356  0.3294663  -0.34237293  0.4212948
  0.31206548  0.33597909 -0.22970418  0.73059748 -0.3576315  -0.37470824
  0.01988032 -0.39698353 -0.31525503 -0.01035984 -0.14982341  0.22932967
  0.32604045  0.          0.79936653]
max: 0.7993665253652315 arg: 32
mean: 0.10231003916622397
min: -0.5059811836173403 arg: 0
std: 0.34921629481857336


data_agglomerative/experiment_q11_raw.json
[[{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[-4.57121251e-01  1.98188543e-01  1.46919868e-01  2.98345531e-01
 -1.57761238e-01 -1.62910593e-01  1.84099780e-01  2.78556219e-01
  2.94803262e-01  6.60862936e-01  3.27036362e-01  1.52971441e-01
  4.63132580e-01  3.97050530e-02  2.72986561e-01  3.36881121e-01
  3.73851240e-01  4.12915858e-01  3.29807265e-01  3.59934960e-01
 -2.62364389e-02 -2.47748649e-01 -3.30029040e-01  3.94748896e-02
 -2.57552967e-02 -1.31900158e-01 -4.09638240e-04  5.51036200e-02
  1.49383947e-01  1.77824609e-01  4.89722014e-01  0.00000000e+00
  4.68465676e-01]
max: 0.6608629361970089 arg: 9
mean: 0.15063942526230004
min: -0.45712125088929156 arg: 0
std: 0.25144693766596204


data_agglomerative/experiment_q12_clean_answers_full.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.          0.01607945  0.31778048  0.46095032  0.46515499 -0.09946569
  0.13906991 -0.04453718  0.17311409 -0.32265925 -0.08767216  0.23270254
  0.3182261   0.05707893  0.43477731  0.28368618  0.24986966  0.0968086
  0.0408102   0.33902533  0.42674781  0.3719814   0.37586563 -0.04856064
  0.50486862  0.11645362  0.43696001 -0.1552201   0.          0.
  0.60131046  0.          0.4220811 ]
max: 0.6013104623386525 arg: 30
mean: 0.18555417247473754
min: -0.3226592514016848 arg: 9
std: 0.2250109575308914


data_agglomerative/experiment_q12_clean_answers_only_lemma.json
[[{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.24403185  0.21595815  0.30768303  0.31626722 -0.02883598  0.17001145
 -0.13370024 -0.2449372  -0.09567848  0.33561629  0.21903931 -0.09056401
  0.14610384 -0.04021433  0.24463557  0.15901007  0.00559508  0.29151507
 -0.06826812  0.03710923  0.28383721  0.08712093  0.56310723  0.11040009
  0.51171233 -0.16530063 -0.07115689 -0.01609472  0.00078962  0.
  0.15683949  0.          0.48719573]
max: 0.5631072321601728 arg: 22
mean: 0.11935843042468136
min: -0.24493719920833745 arg: 7
std: 0.1976651538587293


data_agglomerative/experiment_q12_clean_answers_only_lowercase.json
[[{'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}, {'data': 'Same as previous', 'idx': 506}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}]]
silhouette scores
[ 0.32329591  0.3883753   0.02070592  0.13582717  0.50357879  0.05309182
  0.50898322  0.63471346 -0.15098157 -0.16442595  0.12004425 -0.06520126
  0.44543966  0.47269889 -0.09961888  0.30476551  0.42345427  0.42817724
  0.08283072  0.16862613  0.19756271 -0.11492956 -0.03203331  0.12379376
  0.64533343  0.01680553  0.23195798 -0.21666104  0.16151096  0.00238969
  0.46106472  0.25702321  0.04163573]
max: 0.6453334262592616 arg: 24
mean: 0.19120710342532896
min: -0.2166610351938249 arg: 27
std: 0.23803043471598442


data_agglomerative/experiment_q12_clean_answers_only_stopwords.json
[[{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.06197914 -0.0267798   0.219744    0.45812883  0.17407177  0.2487143
  0.16601231  0.02780016 -0.20464115  0.08554034  0.23377306 -0.14663772
  0.29087544  0.          0.42942023  0.3208161   0.08310453 -0.17340178
  0.05691003  0.20114263  0.18994113  0.29258045  0.40719164  0.03706641
  0.30316758  0.02753227 -0.0742032  -0.00971154 -0.15413037  0.
  0.18088812  0.          0.22887747]
max: 0.45812882907495966 arg: 3
mean: 0.11926582963590614
min: -0.20464114750762177 arg: 8
std: 0.17300907264704316


data_agglomerative/experiment_q12_clean_answers_stopwords_lemma.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.         -0.00400373  0.33209589  0.46095032  0.46515499 -0.09946569
  0.13906991 -0.04453718  0.1419223  -0.32265925 -0.08767216  0.23270254
  0.3182261   0.0516788   0.43477731  0.36183755  0.24986966  0.08558294
  0.04673338  0.35493646  0.42674781  0.37287177  0.37365301  0.04159701
  0.50486862  0.11645362  0.43696001 -0.14619126  0.          0.
  0.60131046  0.          0.42947727]
max: 0.6013104623386525 arg: 30
mean: 0.1901499524770671
min: -0.3226592514016848 arg: 9
std: 0.22525206310058324


data_agglomerative/experiment_q12_raw.json
[[{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}], [{'data': 'do not recall nothing', 'idx': 508}]]
silhouette scores
[ 0.1668045   0.          0.33669541  0.29167702 -0.08239437  0.34307113
 -0.11193819 -0.12827658  0.09243033  0.36041475  0.41111775 -0.05525509
  0.17020623  0.16385457  0.23094225  0.37413806  0.01028526  0.31259824
 -0.02865538  0.26792001  0.2679824   0.          0.41693847  0.09717654
  0.49458671 -0.19237162 -0.04866717  0.02273647 -0.0304357   0.
  0.07208848  0.          0.45586109]
max: 0.4945867108089817 arg: 24
mean: 0.14186459220209083
min: -0.19237162280722442 arg: 25
std: 0.19062880479312108


data_agglomerative/experiment_q13_clean_answers_full.json
[[{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'Definition of function; call of function', 'idx': 540}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.70443446 -0.09455275  0.40888537 -0.00806961  0.81600682 -0.40438628
  0.15016961  0.8401536   0.3642783  -0.12619613  0.7928781   0.66448047
 -0.49824604  0.77771429  0.09038311  0.3755229  -0.05167567  0.6448781
 -0.02815143  0.33228534  0.32095034  0.68201468  0.80219605  0.26557172
  0.69007937  0.08608711 -0.13014412 -0.01111636 -0.03376699 -0.04819859
 -0.03426584  0.00789351]
max: 0.840153597688565 arg: 7
mean: 0.2608779198801321
min: -0.4982460425311096 arg: 12
std: 0.37876470572249105


data_agglomerative/experiment_q13_clean_answers_only_lemma.json
[[{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'it returns 4', 'idx': 514}, {'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}]]
silhouette scores
[ 0.48610436 -0.01500646  0.28621713 -0.02689756  0.10299686  0.07766074
  0.18883527 -0.39387653  0.31459473  0.          0.53267403  0.53662028
  0.60267579  0.3108629  -0.03086828  0.19981023  0.3399084   0.37339065
 -0.02914133  0.40611375  0.29717368  0.51360139  0.75640887  0.26688228
  0.43868559  0.27975438  0.24398129  0.24415769  0.45022607  0.26588237
  0.31187619  0.41454237]
max: 0.7564088685791558 arg: 22
mean: 0.27330772340441567
min: -0.393876526611705 arg: 7
std: 0.2275048721299758


data_agglomerative/experiment_q13_clean_answers_only_lowercase.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}], [{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'the variable r will store the result of the function f', 'idx': 539}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'f is the definition and then r is the invocation', 'idx': 530}], [{'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}]]
silhouette scores
[ 0.29361315  0.03711501 -0.14982489  0.12032234  0.65401547 -0.3426987
  0.42258386  0.63596783 -0.18902644 -0.24879981  0.0402802   0.6877433
 -0.16224818 -0.13633147  0.58081128 -0.1056628  -0.12216704 -0.19115098
 -0.4160834   0.29758301  0.74873837 -0.17569198 -0.18242113  0.27416169
  0.25936815  0.40375796  0.13038     0.43975071  0.13702568  0.
  0.24559481  0.41100008]
max: 0.7487383691976509 arg: 20
mean: 0.13742831551545884
min: -0.4160834031088121 arg: 18
std: 0.32189695495744597


data_agglomerative/experiment_q13_clean_answers_only_stopwords.json
[[{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'Definition of function; call of function', 'idx': 540}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.11291667 -0.23236243  0.39044276  0.11366315  0.81475356 -0.37851277
  0.15130869 -0.69981201  0.4428689   0.          0.82162081  0.76322446
 -0.01920429  0.68448757  0.10980802  0.42216796 -0.03463375  0.65509199
  0.0131705   0.36212271  0.34076422  0.3637854   0.63647803  0.19359118
  0.33164731  0.08608711 -0.26831363 -0.05400536 -0.09151459 -0.03508104
 -0.09011515 -0.18311036]
max: 0.8216208147909235 arg: 10
mean: 0.17885423780917392
min: -0.699812010212767 arg: 7
std: 0.3595713790836591


data_agglomerative/experiment_q13_clean_answers_stopwords_lemma.json
[[{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'Definition of function; call of function', 'idx': 540}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.70443446 -0.09455275  0.39726676 -0.00806961  0.81600682 -0.40438628
  0.15016961  0.8401536   0.4252758  -0.12619613  0.7928781   0.66448047
 -0.49824604  0.77771429  0.10980802  0.3755229  -0.05167567  0.65509199
 -0.02357822  0.33228534  0.32095034  0.68201468  0.80219605  0.26557172
  0.69007937  0.08608711 -0.13014412 -0.01111636 -0.03376699 -0.03508104
 -0.03426584  0.00789351]
max: 0.840153597688565 arg: 7
mean: 0.26390005857782656
min: -0.4982460425311096 arg: 12
std: 0.3789247907668053


data_agglomerative/experiment_q13_raw.json
[[{'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}]]
silhouette scores
[-0.00569043  0.          0.36134449  0.07044918  0.25819885  0.16145698
  0.20029041  0.12506897 -0.03847302  0.08791005 -0.12268779  0.24318868
  0.20738715  0.14784401  0.0055251   0.51429374  0.30663563  0.04005771
  0.45537066  0.42981897  0.23756804  0.00483417  0.03957346  0.01803533
  0.10075619  0.30312385 -0.04637647  0.24061009  0.24295845  0.06442449
  0.42012242  0.52795974]
max: 0.5279597387204231 arg: 31
mean: 0.1750493472221207
min: -0.12268778928174678 arg: 10
std: 0.17165525912703614


