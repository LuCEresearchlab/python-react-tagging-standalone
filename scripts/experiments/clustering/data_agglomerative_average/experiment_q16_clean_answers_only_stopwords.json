[
  [
    {
      "data": "All open variables of the function are closed and the environments are clearly defined.",
      "idx": 664
    },
    {
      "data": "each function takes a different params, so we have multiple functions with the same params",
      "idx": 666
    }
  ],
  [
    {
      "data": "This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.",
      "idx": 652
    },
    {
      "data": "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.",
      "idx": 654
    },
    {
      "data": "Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.",
      "idx": 658
    },
    {
      "data": "yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)",
      "idx": 660
    },
    {
      "data": "Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.",
      "idx": 671
    }
  ],
  [
    {
      "data": "This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.",
      "idx": 651
    },
    {
      "data": "Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.",
      "idx": 653
    },
    {
      "data": "Yes because the curried version is callable like this: f(a)(b)(c)",
      "idx": 662
    }
  ],
  [
    {
      "data": "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters",
      "idx": 679
    }
  ],
  [
    {
      "data": "one function is needed for each parameter provided, creating the nested returning of functions",
      "idx": 656
    },
    {
      "data": "Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.",
      "idx": 670
    },
    {
      "data": "There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)",
      "idx": 675
    }
  ],
  [
    {
      "data": "Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)",
      "idx": 649
    },
    {
      "data": "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.",
      "idx": 657
    },
    {
      "data": "the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ",
      "idx": 663
    },
    {
      "data": "Because it splits a function with 3 arguments into 3 functions. ",
      "idx": 668
    },
    {
      "data": "It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.",
      "idx": 673
    }
  ],
  [
    {
      "data": "because there is a sequence of nested functions with a single argument",
      "idx": 647
    },
    {
      "data": "A function with multiple arguments was transformed to a sequence of functions with one argument each.",
      "idx": 665
    },
    {
      "data": "Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.",
      "idx": 667
    },
    {
      "data": "It changes a multi argument function to a sequence of one argument functions.",
      "idx": 672
    }
  ],
  [
    {
      "data": "multiple functions, and each function dealing with one argument",
      "idx": 648
    },
    {
      "data": "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.",
      "idx": 655
    },
    {
      "data": "The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.",
      "idx": 659
    },
    {
      "data": "Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).",
      "idx": 661
    }
  ],
  [
    {
      "data": "The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.",
      "idx": 674
    },
    {
      "data": "It makes the parameters could be taken one by one.",
      "idx": 677
    }
  ],
  [
    {
      "data": "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.",
      "idx": 669
    }
  ],
  [
    {
      "data": "Just because",
      "idx": 676
    },
    {
      "data": "explained with arrow function for example var f = a => b => c => a+b+c;",
      "idx": 678
    }
  ],
  [
    {
      "data": "Follows the earlier question but correctly uses semicolons",
      "idx": 650
    }
  ]
]
