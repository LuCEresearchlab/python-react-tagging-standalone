data_agglomerative_average/experiment_q00_clean_answers_full.json
[[{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}]]
silhouette scores
[ 0.86415123  0.78567446  0.21698159 -0.03761418  0.          0.47173694
  0.26971171  0.37861507  0.10909548  0.84708892  0.43231207  0.24074338
  0.         -0.00489674  0.43691422  0.          0.43546104  0.56579267
  0.04721208  0.63842686 -0.14724059  0.45126341  0.65345467  0.
  0.80582321 -0.11771407  0.2563864   0.09641194  0.19280873  0.01636983
  0.15254908 -0.04423643 -0.16747224]
max: 0.864151233023958 arg: 0
mean: 0.26805487047859683
min: -0.1674722423375081 arg: 32
std: 0.3038179806278321


data_agglomerative_average/experiment_q00_clean_answers_only_lemma.json
[[{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 0.41830003  0.49737708  0.127976    0.02758659  0.          0.2887365
 -0.05090932 -0.2909042   0.10087954  0.31798131 -0.05874877  0.12985809
 -0.19990007 -0.24801908  0.3587703   0.          0.22294412 -0.07405547
  0.01473676  0.49947187 -0.04634504  0.26902901  0.21759957  0.
  0.46040543  0.          0.17321773  0.08766588  0.         -0.10243705
  0.         -0.07278271  0.        ]
max: 0.49947187013374184 arg: 19
mean: 0.09298285051423906
min: -0.2909042008009045 arg: 7
std: 0.20440378376538276


data_agglomerative_average/experiment_q00_clean_answers_only_lowercase.json
[[{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'it requires the keyword final to be immutable.', 'idx': 23}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}]]
silhouette scores
[ 1.          0.39741177  0.10280996  0.41691986  0.41665245  0.17075866
  0.14821127  0.17400128  0.16546932  1.          0.35478524  0.
  0.18089261  0.          0.01392007  0.3439752   0.00839618  0.03366166
 -0.0457213   0.186067    0.05957837  0.15239471  0.          0.17753639
  0.08628313  0.22236408 -0.1233376   0.29109809  0.31794095  0.2796929
  0.21838567  0.08964035  0.        ]
max: 1.0 arg: 0
mean: 0.20726631085672506
min: -0.12333759790307909 arg: 26
std: 0.24446910623846085


data_agglomerative_average/experiment_q00_clean_answers_only_stopwords.json
[[{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}]]
silhouette scores
[ 0.86415123  0.78567446  0.22332225  0.09977374  0.          0.42562068
  0.22836134  0.31618471  0.08510531  0.84708892  0.43231207  0.23772794
  0.          0.01901978  0.43691422  0.          0.43546104  0.56579267
  0.04721208  0.63842686 -0.13167622  0.39615517  0.65345467  0.
  0.80582321 -0.00603379  0.245726    0.09641194  0.19280873  0.03659279
  0.00505768 -0.00428257  0.        ]
max: 0.864151233023958 arg: 0
mean: 0.2720662692301529
min: -0.1316762183988441 arg: 20
std: 0.2888019653280716


data_agglomerative_average/experiment_q00_clean_answers_stopwords_lemma.json
[[{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}]]
silhouette scores
[ 0.86415123  0.78567446  0.21698159 -0.03761418  0.          0.47173694
  0.26971171  0.38242702  0.10909548  0.84708892  0.43231207  0.24074338
  0.         -0.00489674  0.43691422  0.          0.43546104  0.56579267
  0.04721208  0.63842686 -0.14724059  0.41529509  0.65345467  0.
  0.80582321 -0.11771407  0.2563864   0.09641194  0.19280873  0.01636983
  0.104884   -0.05229731 -0.16747224]
max: 0.864151233023958 arg: 0
mean: 0.2653917696453418
min: -0.1674722423375081 arg: 32
std: 0.30417287586359665


data_agglomerative_average/experiment_q00_raw.json
[[{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}]]
silhouette scores
[ 0.2529403   0.50683727  0.19571588  0.02865194  0.          0.30880163
 -0.05063158 -0.20104382  0.02269821  0.07964301  0.38741003  0.23543343
 -0.12794784  0.15066963  0.25546547  0.          0.46662003  0.58611637
  0.20299995  0.42658271 -0.09620568  0.31113736  0.24635856 -0.14724822
  0.48199284  0.          0.15926525  0.19539923  0.16864143 -0.24630945
  0.         -0.03298329  0.        ]
max: 0.5861163722834886 arg: 17
mean: 0.14445486851807
min: -0.24630944739172184 arg: 29
std: 0.21215802975992745


data_agglomerative_average/experiment_q01_clean_answers_full.json
[[{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}]]
silhouette scores
[ 0.21116054  0.00946808  0.09545551  0.          0.09558648  0.28101471
  0.26637773  0.11967968  0.053088    0.          0.37679643  0.10750844
  0.21506261  0.33645158  0.1237274   0.2361662  -0.07885738  0.33313033
  0.52046714  0.45358763  0.27403063  0.06885265  0.03550504 -0.08604419
  0.19829944  0.32237424  0.03045384 -0.00332194  0.20453536 -0.16062519
  0.45238854  0.03762581  0.        ]
max: 0.5204671353974061 arg: 18
mean: 0.1554528890796716
min: -0.1606251908579688 arg: 29
std: 0.16667974283740097


data_agglomerative_average/experiment_q01_clean_answers_only_lemma.json
[[{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}]]
silhouette scores
[ 0.38571823  0.10192576  0.18784845 -0.05108155  0.01931483  0.23664626
  0.57670742  0.12390994  0.11699186  0.253501    0.11377759  0.43268544
  0.20624988  0.24423003  0.12677953  0.48542297  0.4762386   0.35289278
  0.55162948  0.41538867  0.          0.31674241  0.2204876   0.1839641
  0.06996593  0.45679181 -0.00190881 -0.04831301  0.30437627  0.07044132
  0.4644374   0.07031237  0.        ]
max: 0.576707419251593 arg: 6
mean: 0.22618407720860673
min: -0.05108154546458732 arg: 3
std: 0.18176271413721795


data_agglomerative_average/experiment_q01_clean_answers_only_lowercase.json
[[{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}], [{'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'It is marked with keyword final.', 'idx': 56}]]
silhouette scores
[ 0.56569892 -0.01324496  0.17177194  0.04260296 -0.24822633  0.43014225
  0.20847343  0.20321719  0.13459647  0.19877944  0.22636922  0.05011103
  0.33637286  0.51683484  0.09859518 -0.25154864  0.37191093  0.07349314
  0.47024523  0.61822372 -0.10271343  0.          0.47539121  0.
  0.         -0.0904898   0.346648    0.14021238  0.07826495 -0.06833188
  0.2748866   0.04325326  0.        ]
max: 0.6182237222812934 arg: 19
mean: 0.16065273097516786
min: -0.2515486350688617 arg: 15
std: 0.22126945259145953


data_agglomerative_average/experiment_q01_clean_answers_only_stopwords.json
[[{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}]]
silhouette scores
[ 0.22457154  0.00463549  0.08502549  0.          0.          0.22596817
  0.16786714  0.04281793  0.053088    0.          0.38368099  0.05437384
  0.11188858  0.30993701  0.06409749  0.20087482 -0.13836112  0.2978072
  0.52046714  0.45358763  0.14558883 -0.01875697  0.0186007  -0.29000562
  0.03351442  0.30091251  0.         -0.01715078  0.20453536 -0.16062519
  0.45178732  0.02261487  0.        ]
max: 0.5204671353974061 arg: 18
mean: 0.11373765986787018
min: -0.29000561547373205 arg: 23
std: 0.18028329848604596


data_agglomerative_average/experiment_q01_clean_answers_stopwords_lemma.json
[[{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}]]
silhouette scores
[ 0.21453943  0.00946808  0.09545551  0.          0.09558648  0.28101471
  0.26637773  0.11967968  0.053088    0.          0.37679643  0.10750844
  0.20642997  0.335752    0.1237274   0.2361662  -0.07885738  0.29788836
  0.52046714  0.45358763  0.27403063  0.07119352  0.03550504 -0.13008069
  0.16747143  0.28744292  0.03045384 -0.00332194  0.20453536 -0.16062519
  0.4495704   0.03762581  0.        ]
max: 0.5204671353974061 arg: 18
mean: 0.15086293748717547
min: -0.1606251908579688 arg: 29
std: 0.16633523442306755


data_agglomerative_average/experiment_q01_raw.json
[[{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}]]
silhouette scores
[ 0.30048036 -0.06184997  0.00451629  0.          0.          0.21977875
  0.13327184  0.10261672  0.18719404  0.          0.34719323  0.15581802
 -0.11458097  0.38796132  0.03603032  0.35775194  0.18994533  0.22104273
  0.46360511  0.38073389  0.          0.48944846 -0.00283857  0.14404263
  0.36486304  0.23617951 -0.10643126 -0.04488665  0.43186629  0.09047584
  0.          0.09256091  0.        ]
max: 0.48944845627434497 arg: 21
mean: 0.15172088289383723
min: -0.11458097364914369 arg: 12
std: 0.17360167204120505


data_agglomerative_average/experiment_q02_clean_answers_full.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}]]
silhouette scores
[ 0.34616759 -0.14548977  0.36012217  0.62859528  0.43979809  0.20636048
  0.5472095   0.03827306 -0.16264728  0.3170572   0.64054399  0.11496786
  0.16773903  0.          0.26100432  0.          0.0263209   0.00857148
 -0.11226891  0.76611401  0.          0.05696945  0.46844213  0.13236749
 -0.09852047 -0.06829317  0.22494608 -0.24945028  0.44554108 -0.02059942
  0.29597328  0.38196064  0.11301218]
max: 0.766114014846059 arg: 19
mean: 0.18578145442023797
min: -0.24945028452563742 arg: 27
std: 0.25366377926803496


data_agglomerative_average/experiment_q02_clean_answers_only_lemma.json
[[{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}]]
silhouette scores
[ 0.66965574  0.06195708  0.54359475  0.92217437  0.30099265  0.
  0.         -0.00161231  0.04821297  0.08172608  0.33565786  0.27379605
  0.          0.          0.04279759  0.          0.39625926  0.18410326
  0.          0.24781747  0.          0.20016397  0.30221942  0.06059267
 -0.15345691  0.2105579   0.3464591   0.09895486  0.14568659  0.
  0.45279839  0.36032746  0.14623113]
max: 0.922174368165744 arg: 3
mean: 0.19023234526282906
min: -0.15345691217380775 arg: 24
std: 0.22398663599233842


data_agglomerative_average/experiment_q02_clean_answers_only_lowercase.json
[[{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}]]
silhouette scores
[ 0.60535736  0.          0.00896333  0.41549387  0.55198667  0.
  0.24071084 -0.05892483 -0.3033534   0.1500676   0.33517874  0.16265008
 -0.01046853  0.49362977  0.          0.22250134  0.3154438   0.07723544
  0.08275319  0.75257532 -0.2991511  -0.07680482  0.26887067  0.45403247
  0.39479502  0.          0.03687132  0.06463487  0.45453753  0.04430786
  0.06821285 -0.13776195 -0.11611079]
max: 0.7525753158406213 arg: 19
mean: 0.15752225756654334
min: -0.3033534037835128 arg: 8
std: 0.25182152612875636


data_agglomerative_average/experiment_q02_clean_answers_only_stopwords.json
[[{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}]]
silhouette scores
[ 0.63608745  0.          0.08671079 -0.22746223  0.14615392 -0.29440535
  0.71030947  0.092646    0.05082754  0.42408478  0.64465194  0.14271746
  0.08838346  0.          0.10111883  0.          0.04322476  0.04214826
 -0.10652407  0.43297675  0.          0.          0.41109059 -0.02487431
 -0.08018876 -0.05679879  0.2063539  -0.09273364  0.28448688  0.12368407
  0.36787545  0.36102883  0.        ]
max: 0.7103094655103193 arg: 6
mean: 0.13677496816293544
min: -0.29440534507700067 arg: 5
std: 0.2398806272207412


data_agglomerative_average/experiment_q02_clean_answers_stopwords_lemma.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}]]
silhouette scores
[ 0.34616759 -0.14548977  0.36012217  0.62182588  0.45589487  0.16625645
  0.49886469  0.03827306 -0.00910913  0.3170572   0.64054399 -0.01952559
 -0.13750534  0.          0.          0.          0.01266176 -0.00573845
 -0.11226891  0.76611401  0.          0.05696945  0.45965328 -0.04920722
  0.18249361  0.02596326  0.22494608 -0.24945028  0.44554108 -0.02059942
  0.31047664  0.38196064  0.11301218]
max: 0.766114014846059 arg: 19
mean: 0.171997083779751
min: -0.24945028452563742 arg: 27
std: 0.2531375712595554


data_agglomerative_average/experiment_q02_raw.json
[[{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}]]
silhouette scores
[ 0.13222959  0.03203072  0.52142496  0.47812361  0.40765214  0.15112521
  0.          0.03686609  0.         -0.04002725  0.02232821  0.15465813
  0.029523    0.          0.          0.          0.2980848   0.04259515
 -0.16923551  0.11611262  0.          0.21729807 -0.07043728  0.16955049
 -0.04693633  0.11429453  0.22321246  0.07213223  0.00082401  0.
  0.34267921  0.24138946  0.17857856]
max: 0.5214249616469516 arg: 2
mean: 0.11079020844915421
min: -0.16923551497391387 arg: 18
std: 0.15790387502299466


data_agglomerative_average/experiment_q03_clean_answers_full.json
[[{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}]]
silhouette scores
[ 0.47443212 -0.14759274  0.39254946  0.36194296  0.16797024  0.08678257
  0.         -0.10135776  0.34270109  0.16389823 -0.03209636  0.
  0.24018862  0.32817173  0.         -0.07142499  0.21650513 -0.04870259
  0.04208459  0.92938401  0.14775105  0.         -0.07791061 -0.05179235
  0.11858848  0.35970666 -0.03806403  0.18599863 -0.02807176  0.
  0.42772696  0.28410184]
max: 0.9293840137273877 arg: 19
mean: 0.14604597468113467
min: -0.14759273670220738 arg: 1
std: 0.22364687435345812


data_agglomerative_average/experiment_q03_clean_answers_only_lemma.json
[[{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}]]
silhouette scores
[ 0.35290414  0.29057923  0.89848451 -0.04179169  0.31114817  0.15072833
  0.4529718   0.66356657  0.50918396  0.09826319  0.22586979  0.
  0.13383325  0.47000562  0.          0.21869605  0.8133129   0.05772301
  0.35300133  0.65951959  0.18123724  0.53697999 -0.16233256 -0.19290119
  0.38814873  0.          0.02925019  0.30191165  0.86003592  0.
  0.14109919  0.21302248]
max: 0.8984845096401197 arg: 2
mean: 0.27857660592249
min: -0.1929011887897373 arg: 23
std: 0.2830095484901237


data_agglomerative_average/experiment_q03_clean_answers_only_lowercase.json
[[{'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}]]
silhouette scores
[ 0.04121637  0.58162626  0.          0.48609567  0.23665078  0.08760545
  0.30676061  0.0811845  -0.11713262  0.54338006 -0.02984175  0.02911789
  0.49761963  0.2900464   0.22449454  0.36369408 -0.00943538  0.
  0.01312174  0.36492068 -0.28776074  0.28083951 -0.11122808 -0.1041977
  0.35358151  0.25230497 -0.13656946  0.41058088  0.12727887  0.
  0.22542465  0.57747253]
max: 0.5816262581432239 arg: 1
mean: 0.17433912015128578
min: -0.28776073699066446 arg: 20
std: 0.22966757785392194


data_agglomerative_average/experiment_q03_clean_answers_only_stopwords.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}]]
silhouette scores
[0.43135794 0.17246118 0.41534895 0.17914188 0.22536761 0.18975303
 0.39501818 0.01015603 0.45012382 0.14863018 0.00221145 0.
 0.19998772 0.12242528 0.         0.2001764  0.34680743 0.11658718
 0.18928672 0.6592767  0.17573008 0.0708209  0.07912833 0.02743016
 0.11328734 0.         0.         0.23211175 0.2837542  0.
 0.40882198 0.31159697]
max: 0.6592766982256296 arg: 19
mean: 0.1923999816639167
min: 0.0 arg: 11
std: 0.16367452136116095


data_agglomerative_average/experiment_q03_clean_answers_stopwords_lemma.json
[[{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}]]
silhouette scores
[ 0.47443212 -0.14759274  0.39254946  0.36194296  0.16797024  0.11903942
  0.         -0.10135776  0.34270109  0.16389823 -0.03209636  0.
  0.22151179  0.32817173  0.         -0.07142499  0.21650513 -0.06356163
  0.04208459  0.92938401  0.14775105  0.         -0.07791061 -0.05179235
  0.11858848  0.35970666 -0.05869854  0.18599863 -0.02807176  0.
  0.42772696  0.28410184]
max: 0.9293840137273877 arg: 19
mean: 0.14536117667529452
min: -0.14759273670220738 arg: 1
std: 0.22420973714689962


data_agglomerative_average/experiment_q03_raw.json
[[{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}]]
silhouette scores
[ 0.0322999   0.52339398  0.93114657  0.21593988  0.22829629 -0.02064157
 -0.18897062  0.00878444  0.71819694  0.06242551  0.          0.
  0.          0.13487059  0.          0.25446997  0.8934014   0.28511338
  0.24309547  0.69493436  0.12611     0.51662847 -0.23560107 -0.08763628
 -0.08512835  0.          0.17099309  0.1031841   0.78769067  0.
  0.05764085  0.08276051]
max: 0.9311465664001727 arg: 2
mean: 0.2016687027000641
min: -0.2356010689491291 arg: 22
std: 0.30737922091511255


data_agglomerative_average/experiment_q04_clean_answers_full.json
[[{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}]]
silhouette scores
[ 0.44906606  0.72798082  0.76771045  0.42069994  0.87046376  0.39829895
 -0.26107482 -0.02987337  0.         -0.26302239  0.76309564  0.52594643
 -0.12490789  0.          0.08874494 -0.05681641  0.30192384  0.64315488
  0.81611591  0.31956266 -0.03300131  0.331236    0.00532533  0.
 -0.09087053  0.59745882  0.34027861  0.41394221  0.43406133  0.03289563
  0.17299846  0.09651719  0.70460379]
max: 0.8704637619614778 arg: 4
mean: 0.28371257400381933
min: -0.26302238896934466 arg: 9
std: 0.3276779773939468


data_agglomerative_average/experiment_q04_clean_answers_only_lemma.json
[[{'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}], [{'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}]]
silhouette scores
[ 4.88556865e-01 -2.01963410e-01  4.14206881e-01  6.75595069e-01
  4.09286123e-01  6.71490562e-01  5.53280330e-02  3.08321698e-04
  1.01653061e-02 -1.73373304e-01  3.03988547e-01 -1.94564219e-01
 -5.28725128e-02  2.39725294e-01 -4.84198980e-01  3.42394645e-01
  0.00000000e+00 -8.82370036e-02 -2.32041648e-01 -9.69068717e-02
  1.86743456e-01  3.35798203e-01  7.27477675e-01  0.00000000e+00
  0.00000000e+00  2.94552120e-01  2.45699743e-01  2.26862119e-01
  2.10495308e-01  1.22941309e-01  9.05656554e-02  1.94021050e-01
  3.02835273e-01]
max: 0.7274776749675164 arg: 22
mean: 0.15226907897409062
min: -0.4841989797721666 arg: 14
std: 0.2741178181331889


data_agglomerative_average/experiment_q04_clean_answers_only_lowercase.json
[[{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}], [{'data': 'it prints on the output', 'idx': 156}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}]]
silhouette scores
[ 5.55805203e-01  9.18322689e-01  1.41420799e-01 -2.81572309e-01
  4.18048175e-01  3.49098828e-01 -6.43091234e-02  1.89676740e-01
 -2.16509433e-02  4.65087675e-01  8.92456390e-01  0.00000000e+00
  3.96485335e-01  6.51904913e-02  3.20821060e-01 -1.67162888e-01
  0.00000000e+00  2.87073070e-01  5.64562280e-01  0.00000000e+00
  0.00000000e+00  2.58494770e-01  5.84721076e-01  3.73746874e-01
  5.36736345e-04  5.22494243e-01  0.00000000e+00  0.00000000e+00
  5.10952171e-01  9.94262182e-02  4.99822238e-01  4.50288634e-01
  5.97379837e-01]
max: 0.9183226890226852 arg: 1
mean: 0.2705217051518449
min: -0.2815723093599355 arg: 3
std: 0.2903385420759886


data_agglomerative_average/experiment_q04_clean_answers_only_stopwords.json
[[{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}]]
silhouette scores
[ 0.35997247  0.69775728  0.73581302  0.45567747  0.855199    0.42590373
  0.23359101  0.19166345 -0.11719978 -0.03984357  0.7376853   0.41224118
  0.35823626  0.02201578  0.08377727  0.0581275   0.          0.65713186
  0.72890966  0.42278039  0.23978178  0.4846664  -0.02973899  0.30463356
 -0.07766194  0.51404693  0.28686987  0.57660823  0.50444607  0.15780185
 -0.04592215  0.40659959  0.6842465 ]
max: 0.8551990025715661 arg: 4
mean: 0.3419944542959819
min: -0.11719978017231997 arg: 8
std: 0.2756006453338345


data_agglomerative_average/experiment_q04_clean_answers_stopwords_lemma.json
[[{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}]]
silhouette scores
[ 0.44906606  0.72798082  0.76771045  0.42069994  0.87046376  0.39829895
 -0.26107482 -0.02987337  0.         -0.26302239  0.76309564  0.52594643
 -0.12490789  0.          0.08874494 -0.05681641  0.30192384  0.64315488
  0.81611591  0.31956266 -0.03300131  0.331236    0.00532533  0.
 -0.09087053  0.59745882  0.34027861  0.41394221  0.43406133  0.03289563
  0.17299846  0.09651719  0.70460379]
max: 0.8704637619614778 arg: 4
mean: 0.28371257400381933
min: -0.26302238896934466 arg: 9
std: 0.3276779773939468


data_agglomerative_average/experiment_q04_raw.json
[[{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}]]
silhouette scores
[ 0.42491566 -0.18915478  0.75088361  0.13156612  0.59370433  0.13873241
  0.00997879  0.19809113  0.29822965 -0.06680969  0.53600404  0.32490595
  0.34157814  0.1839411   0.31383101  0.34979605  0.          0.11427232
 -0.16028375  0.13998704  0.25339808  0.41896598  0.52189956  0.
  0.13019234  0.1763345   0.33964296  0.1112257   0.28599396 -0.07915378
  0.30067153  0.17953265  0.27345801]
max: 0.7508836118191318 arg: 2
mean: 0.22261607954700624
min: -0.1891547825387675 arg: 1
std: 0.21051645737409713


data_agglomerative_average/experiment_q05_clean_answers_full.json
[[{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}]]
silhouette scores
[ 0.45620226  0.15713281  0.57605389  0.27747903  0.14235657  0.34714005
  0.          0.34165547  0.          0.55125686  0.20563224  0.08643594
  0.20517388  0.27333592  0.17646458  0.15469286  0.0268651   0.45706153
 -0.11877063 -0.07262089  0.          0.43393416  0.24762413  0.31543059
  0.28764253  0.09549269  0.00105244  0.46433318  0.         -0.04523371
  0.43493383  0.14556888  0.20086469]
max: 0.5760538919953253 arg: 2
mean: 0.20682396637978967
min: -0.11877062960390422 arg: 18
std: 0.18678974760077513


data_agglomerative_average/experiment_q05_clean_answers_only_lemma.json
[[{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.51422642  0.          0.56919332  0.24625743  0.18084448  0.18734313
 -0.13358455  0.17137603  0.          0.59483915  0.02202566  0.34160348
 -0.18655779 -0.02598795  0.07336129  0.32848791  0.2145076   0.17408976
  0.12218557  0.4749951   0.          0.22835452  0.2023959   0.35303861
 -0.05142805  0.05140864  0.26706267  0.1475158   0.          0.08912261
 -0.00264009  0.          0.20624723]
max: 0.5948391511200297 arg: 9
mean: 0.1624328447187867
min: -0.18655779489019217 arg: 12
std: 0.19042500938861992


data_agglomerative_average/experiment_q05_clean_answers_only_lowercase.json
[[{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}]]
silhouette scores
[ 1.          0.3401958   0.4183593   0.4070943   0.84097042  0.51964645
 -0.0023194   0.09602235  0.3910638   0.5772886  -0.29144462  0.24872768
 -0.1216768  -0.05383898  0.          0.12088008 -0.21659907  0.72968796
  0.20994653  1.          0.          0.40304896 -0.10778714  0.36870511
 -0.06647419  0.78769117 -0.32047601  0.68486517  0.          0.
  0.18635646  0.35479627 -0.43495349]
max: 1.0 arg: 0
mean: 0.2445386883182331
min: -0.43495348947812124 arg: 32
std: 0.37395416771985557


data_agglomerative_average/experiment_q05_clean_answers_only_stopwords.json
[[{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}]]
silhouette scores
[ 0.34930397  0.17290856  0.53695918  0.29721211  0.18487598  0.36451845
  0.          0.37488894  0.          0.5731873   0.19800981  0.08989152
  0.1633147   0.15411818  0.14731436  0.10618842  0.06248312  0.44117975
  0.13837746  0.24100162  0.          0.34274005  0.26906315  0.34351875
  0.12485706  0.07094318  0.          0.43873052  0.         -0.13668961
  0.50928098  0.          0.24840706]
max: 0.5731872980692351 arg: 9
mean: 0.20626013767267035
min: -0.13668961044172376 arg: 29
std: 0.17649624758649782


data_agglomerative_average/experiment_q05_clean_answers_stopwords_lemma.json
[[{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}]]
silhouette scores
[ 0.45620226  0.15713281  0.57605389  0.27747903  0.14235657  0.33916793
  0.          0.34165547  0.          0.55125686  0.20563224  0.08643594
  0.21874419  0.27333592  0.17646458  0.15469286  0.0268651   0.45706153
 -0.11877063 -0.07262089  0.          0.43393416  0.21591435  0.31543059
  0.297064    0.09549269  0.00105244  0.46433318  0.         -0.04523371
  0.43493383  0.14556888  0.20086469]
max: 0.5760538919953253 arg: 2
mean: 0.20631820507614984
min: -0.11877062960390422 arg: 18
std: 0.18662637924186978


data_agglomerative_average/experiment_q05_raw.json
[[{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.25359974  0.29544058  0.59670472  0.3261627   0.20957926  0.47683933
 -0.08510117  0.31604091  0.          0.51382522  0.13740139  0.25061098
  0.06999111  0.13549412 -0.04031754  0.04931098  0.28233442  0.36482397
  0.17997162 -0.2362779   0.07301018  0.41386699  0.42366765  0.08290747
  0.13438523 -0.00757358  0.00900379  0.36839766  0.          0.06440465
  0.01670352 -0.0903855   0.37474589]
max: 0.5967047209119749 arg: 2
mean: 0.18059298166977777
min: -0.23627789693167262 arg: 19
std: 0.19541530854035838


data_agglomerative_average/experiment_q06_clean_answers_full.json
[[{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.28336402  0.33730774  0.21901344 -0.12744372  0.0702938   0.46147806
  0.65097027  0.52169412  0.02487128  0.06108994  0.36511702  0.16874001
  0.2727582   0.41840129  0.49335481  0.69201698  0.51912893  0.32488787
  0.25138938  0.27493929 -0.0595588   0.04393309  0.08588112  0.43251999
  0.57705476  0.          0.20037944  0.01249729  0.33166025  0.12802881
  0.          0.13183257  0.01181363]
max: 0.6920169758752696 arg: 15
mean: 0.24786105670894623
min: -0.1274437230673082 arg: 3
std: 0.2141651089812572


data_agglomerative_average/experiment_q06_clean_answers_only_lemma.json
[[{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}]]
silhouette scores
[ 0.1961722  -0.21889469 -0.0696962   0.150942    0.          0.10854355
  0.50113021  0.25611246  0.          0.38087502  0.09978339  0.0018505
  0.33333187  0.12898484  0.36691658  0.60040112  0.13709981  0.46747624
  0.01535283 -0.0348327   0.530667    0.19894363  0.          0.28920483
  0.42109418  0.         -0.07539829  0.12612653  0.19030482  0.00956084
  0.         -0.11261906 -0.10636516]
max: 0.600401123427196 arg: 15
mean: 0.14827479917139422
min: -0.21889469007314863 arg: 1
std: 0.20580454808923054


data_agglomerative_average/experiment_q06_clean_answers_only_lowercase.json
[[{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}], [{'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}], [{'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}], [{'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'It depends on the current state of the object.', 'idx': 225}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}], [{'data': 'return a non-local variable', 'idx': 226}], [{'data': 'It accesses memory state.', 'idx': 235}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}]]
silhouette scores
[ 0.084996    0.          0.          0.42797511  0.05681742  0.43524078
  0.24265978  0.04202351  0.16811599  0.54281744 -0.03828425  0.
 -0.06388054  0.          0.2450891   0.          0.19996431  0.
  0.42829501  0.          0.          0.          0.          0.41724598
  0.26925776  0.11497927  0.          0.11509258  0.35276269  0.31944587
  0.          0.          0.27121979]
max: 0.5428174437881457 arg: 9
mean: 0.14035859444491047
min: -0.0638805417844393 arg: 12
std: 0.1722085488827555


data_agglomerative_average/experiment_q06_clean_answers_only_stopwords.json
[[{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.34352681  0.30096979  0.14991878 -0.09755977  0.07393229  0.4389404
  0.59497075  0.45470091  0.07045768  0.07164256  0.3467208   0.15488023
  0.2632408   0.37177634  0.49485522  0.65778824  0.58990615  0.27884133
  0.02217042  0.24457292 -0.12990094 -0.05892172  0.01908851  0.40718372
  0.49051661  0.          0.00677727 -0.03490587  0.22822789  0.26620954
  0.          0.26231942 -0.0812922 ]
max: 0.6577882371278339 arg: 15
mean: 0.21822893492098278
min: -0.12990094251139814 arg: 20
std: 0.2188165254739676


data_agglomerative_average/experiment_q06_clean_answers_stopwords_lemma.json
[[{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.28336402  0.33730774  0.21901344 -0.12744372  0.0702938   0.46147806
  0.65097027  0.52169412  0.02487128  0.06108994  0.36511702  0.16874001
  0.2727582   0.41840129  0.49335481  0.69201698  0.51912893  0.32488787
  0.25138938  0.27493929 -0.0595588   0.04393309  0.08588112  0.43251999
  0.57705476  0.          0.20037944  0.01249729  0.33166025  0.12802881
  0.          0.13183257  0.01181363]
max: 0.6920169758752696 arg: 15
mean: 0.24786105670894623
min: -0.1274437230673082 arg: 3
std: 0.2141651089812572


data_agglomerative_average/experiment_q06_raw.json
[[{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[-0.02414796 -0.17435793  0.23499015  0.12220301 -0.16775779  0.06089635
 -0.17002784  0.15151745 -0.01913266  0.31805144  0.41962795  0.13664527
  0.31466057  0.13534888  0.36474378  0.57873836 -0.13480792  0.42588557
  0.          0.02199348  0.46881808  0.36732973  0.          0.27806689
  0.33884509  0.         -0.15520003  0.17864119  0.21705566  0.32202002
  0.         -0.02533576 -0.20473193]
max: 0.5787383600915258 arg: 15
mean: 0.13274482088711184
min: -0.20473193074017731 arg: 32
std: 0.21186091806506946


data_agglomerative_average/experiment_q07_clean_answers_full.json
[[{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}]]
silhouette scores
[ 5.76060715e-01  3.08077857e-01  3.43415837e-01  1.24181133e-01
  1.45803359e-01  0.00000000e+00  0.00000000e+00  2.45873243e-01
  2.91175868e-01  1.42088023e-01  6.11635081e-01  1.33679405e-01
  1.15476551e-01  3.62772558e-01  6.23512877e-02  3.80177333e-02
  6.87285919e-01  1.57169322e-01  4.43147841e-02  0.00000000e+00
  3.25171229e-01 -1.49769929e-03  2.51502134e-01  9.00713779e-02
  8.79157413e-02 -3.12806241e-04  3.01787030e-01  1.16073061e-01
  3.01533465e-01 -1.75077209e-01  2.88594126e-01  6.01173675e-02
  6.63582513e-01]
max: 0.6872859194355591 arg: 16
mean: 0.20299512136614
min: -0.17507720936484175 arg: 29
std: 0.20348724772715862


data_agglomerative_average/experiment_q07_clean_answers_only_lemma.json
[[{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}], [{'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'it should be f()(1)', 'idx': 292}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'return another function', 'idx': 304}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[ 0.50875805  0.18305727  0.23787748  0.          0.53698991  0.
  0.          0.21666305  0.38097789  0.04978058  0.53774179  0.21895601
  0.09055226  0.61963637 -0.03139353  0.12537521  0.65437828 -0.15501082
  0.08801347 -0.01029438  0.52524153  0.          0.26623342  0.12127426
  0.14234863  0.23815393  0.71272654  0.29918262  0.          0.
  0.24913789 -0.03418694  0.66901619]
max: 0.7127265440936459 arg: 26
mean: 0.22549051394566538
min: -0.1550108171513805 arg: 17
std: 0.24037514337213076


data_agglomerative_average/experiment_q07_clean_answers_only_lowercase.json
[[{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}]]
silhouette scores
[ 0.53893799  0.29457076  0.06317404  0.29930822 -0.03540031  0.
  0.44691107  0.45092422 -0.12472618  0.17024569  0.74697963  0.14289821
  0.49585043  0.03823195 -0.01526093  0.48587902  0.66429514  0.03624941
  0.          0.69331142 -0.01184805  0.482495    0.          0.07679423
  0.09730889  0.39214041  0.41883116  0.64137187  0.24839786  0.
 -0.02093225  0.43578955  0.76130462]
max: 0.7613046213643108 arg: 32
mean: 0.2701222143454277
min: -0.12472617804701545 arg: 8
std: 0.26500990000326613


data_agglomerative_average/experiment_q07_clean_answers_only_stopwords.json
[[{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}], [{'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}]]
silhouette scores
[ 0.59011264  0.          0.30525472  0.11919511  0.0698528  -0.0091785
  0.          0.26596966  0.60172086  0.1003436   0.61894665  0.12433791
  0.02533721  0.43185462  0.03572393  0.06306704  0.69915689  0.11200305
  0.16735976  0.          0.21582866 -0.0047174   0.2501102   0.0856454
  0.55209587  0.25970029  0.38915569  0.16064933  0.30120779 -0.18194808
  0.19443155  0.0109437   0.68505242]
max: 0.6991568860199137 arg: 16
mean: 0.2193701021971721
min: -0.18194807949595931 arg: 29
std: 0.22914649729587688


data_agglomerative_average/experiment_q07_clean_answers_stopwords_lemma.json
[[{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}]]
silhouette scores
[ 5.76060715e-01  3.08077857e-01  2.97425151e-01  1.24181133e-01
  8.96094593e-02  0.00000000e+00  0.00000000e+00  2.45873243e-01
  6.16407359e-01  1.42088023e-01  6.11635081e-01  1.45471277e-01
  1.36232298e-01  3.64890497e-01  8.24908199e-02  3.75815821e-02
  6.87285919e-01  1.57169322e-01  4.43147841e-02  0.00000000e+00
  2.54354712e-01 -1.49769929e-03  2.20945411e-01  9.66688499e-02
  5.84714981e-01 -3.12806241e-04  2.89190394e-01  1.40505635e-01
  3.01533465e-01 -1.75077209e-01  2.88594126e-01  6.01173675e-02
  6.63582513e-01]
max: 0.6872859194355591 arg: 16
mean: 0.22394285634303437
min: -0.17507720936484175 arg: 29
std: 0.2212538897591058


data_agglomerative_average/experiment_q07_raw.json
[[{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'return another function', 'idx': 304}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[ 0.49114643  0.18564222  0.2677933  -0.07876895  0.32199022  0.
  0.          0.2296278   0.44455524  0.01878516  0.54249993  0.28022917
  0.06574986  0.6855771   0.08786354  0.10827633  0.6588163  -0.15053913
  0.08801347 -0.05074771  0.28914799  0.          0.          0.16189276
  0.21764253  0.21190091  0.7265918   0.24490061  0.          0.
  0.25108066  0.03768637  0.67740924]
max: 0.7265917952364068 arg: 26
mean: 0.21256857956123748
min: -0.15053912961943583 arg: 17
std: 0.2376564444575062


data_agglomerative_average/experiment_q08_clean_answers_full.json
[[{'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}], [{'data': 'Just because', 'idx': 336}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}]]
silhouette scores
[ 0.         -0.07487496  0.          0.4258352   0.1055305   0.24054721
  0.          0.83250712  0.88550967  0.58910386 -0.0403221   0.
  0.17747631  0.12799751  0.09531602  0.48375362  0.38363902  0.41178885
 -0.02873869  0.19156621  0.          0.62860601  0.          0.02773615
 -0.15032815  0.          0.15528465  0.58261584  0.          0.40278357
  0.07397991  0.09385832]
max: 0.8855096715592833 arg: 8
mean: 0.20691161338126418
min: -0.1503281466553494 arg: 24
std: 0.26900570584910405


data_agglomerative_average/experiment_q08_clean_answers_only_lemma.json
[[{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.          0.          0.24894661 -0.19716436  0.          0.21922494
 -0.10002476  0.53573429  0.54508685  0.69121945  0.12996792 -0.04275461
  0.42445332  0.04524152 -0.18181391  0.509952    0.24869797  0.04742286
  0.12407628  0.1573958   0.3079921   0.51775805 -0.05084827  0.13470459
  0.          0.49369775  0.08204272  0.33920688  0.          0.37070431
  0.02266926  0.        ]
max: 0.691219450457665 arg: 9
mean: 0.17573717340035655
min: -0.19716435789510187 arg: 3
std: 0.23170464325107074


data_agglomerative_average/experiment_q08_clean_answers_only_lowercase.json
[[{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.          0.10222935  0.42221161  0.50790971  0.20990443  0.08461599
  0.33069817  0.18694322 -0.00442872  0.         -0.53249435  0.66767841
  0.20829433  0.0368341   0.23125665  0.52359148  0.37355786 -0.07901056
  0.43338364  0.11749729  0.         -0.10375732  0.16322851  0.1475902
 -0.01206504  0.72642607  0.45032805  0.          0.          0.28110664
  0.          0.25778412]
max: 0.7264260727737993 arg: 25
mean: 0.17910355760932173
min: -0.5324943480074904 arg: 10
std: 0.2500104735205649


data_agglomerative_average/experiment_q08_clean_answers_only_stopwords.json
[[{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Just because', 'idx': 336}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}]]
silhouette scores
[ 0.00000000e+00  0.00000000e+00  9.62620987e-02  1.99830479e-01
  0.00000000e+00  7.67098762e-02  0.00000000e+00  9.53680365e-01
  9.73590048e-01  2.67351491e-01  8.52620930e-02 -1.49285742e-02
  8.50875249e-02 -7.33061261e-02  8.34450976e-02  4.71775374e-01
  3.58357358e-01 -1.37742136e-01 -1.19891877e-01  5.72158257e-02
  0.00000000e+00  4.58265775e-01 -7.92162775e-02  2.21009784e-02
  0.00000000e+00  0.00000000e+00 -5.89058522e-04  3.07851470e-01
  0.00000000e+00  4.10041981e-01  7.05455098e-02 -1.29273805e-02]
max: 0.9735900484997082 arg: 8
mean: 0.14183662240392503
min: -0.13774213648399858 arg: 17
std: 0.2645564515657947


data_agglomerative_average/experiment_q08_clean_answers_stopwords_lemma.json
[[{'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}], [{'data': 'Just because', 'idx': 336}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}]]
silhouette scores
[ 0.         -0.07487496  0.          0.4258352   0.11844551  0.24054721
  0.          0.83250712  0.88550967  0.23979041 -0.0403221   0.03449049
  0.17747631  0.14931587  0.09531602  0.48375362  0.39850368  0.41178885
 -0.02873869  0.19156621  0.          0.45208554  0.          0.02773615
 -0.15032815  0.          0.15528465  0.33714596  0.          0.40278357
  0.07397991  0.09385832]
max: 0.8855096715592833 arg: 8
mean: 0.18542051129797185
min: -0.1503281466553494 arg: 24
std: 0.24373407096321673


data_agglomerative_average/experiment_q08_raw.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.          0.         -0.01227963  0.42907682  0.          0.08343927
 -0.08133694  0.31890435  0.52180288  0.69522401  0.09223242  0.15475327
  0.28319961 -0.06271453  0.07542255  0.49884034  0.35965257  0.13939534
  0.06232889  0.05389819  0.37394944  0.52770257  0.04406981  0.04987404
  0.          0.01867987 -0.03810438  0.35770118  0.         -0.03851477
  0.20462399  0.03524035]
max: 0.6952240059959154 arg: 9
mean: 0.1608456722253783
min: -0.08133694304755648 arg: 6
std: 0.20547538840643223


data_agglomerative_average/experiment_q09_clean_answers_full.json
[[{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[ 0.26346835  0.         -0.06428109  0.01851827  0.39107014  0.03391219
  0.15963046  0.          0.31707195  0.300281    0.         -0.04794144
  0.          0.31283459  0.         -0.04285468  0.43313749  0.06351024
  0.04520539  0.25409967  0.44840283  0.25409967  0.         -0.09363582
  0.06158522 -0.32898594  0.14001324 -0.40948988  0.          0.
 -0.02435635  0.          0.16332207]
max: 0.4484028311589216 arg: 20
mean: 0.08026113863158543
min: -0.40948988257088004 arg: 27
std: 0.19012034974063782


data_agglomerative_average/experiment_q09_clean_answers_only_lemma.json
[[{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'there is no passing function', 'idx': 372}]]
silhouette scores
[ 0.16344185  0.          0.1505966   0.32053657 -0.29577113  0.24112345
 -0.02939582 -0.09296949  0.33602525  0.30110843  0.          0.07741219
  0.         -0.1273938   0.          0.11621201  0.46718693  0.1125146
  0.          0.23487516  0.4474273  -0.08874125  0.07992211  0.11545384
  0.         -0.25506585 -0.03761632 -0.34765027  0.          0.
  0.02023671  0.          0.14714991]
max: 0.4671869282810781 arg: 16
mean: 0.062321786943583764
min: -0.3476502729961239 arg: 27
std: 0.18600005484115317


data_agglomerative_average/experiment_q09_clean_answers_only_lowercase.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'It returns the wrapped function.', 'idx': 369}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}]]
silhouette scores
[ 0.76800742 -0.54470048  0.44427392 -0.08570203  0.1708702   0.5657764
  0.40848818  0.20907574 -0.08170235  0.63200431  0.          0.80059972
 -0.1818579  -0.01715467  0.5303319   0.46884389  0.3441668   0.60785423
  0.35621144  0.74903509 -0.31090719  0.59818697 -0.32455165  0.27353572
  0.23195892  0.          0.08888098  0.          0.64005499  0.51184794
  0.48982637  0.53646756  0.13254493]
max: 0.8005997198524436 arg: 11
mean: 0.2730990101983978
min: -0.5447004762975667 arg: 1
std: 0.3420336933069325


data_agglomerative_average/experiment_q09_clean_answers_only_stopwords.json
[[{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}]]
silhouette scores
[ 0.25148077  0.          0.          0.00303966  0.03446508  0.00346081
  0.02142405 -0.03154851  0.27494654  0.30896707  0.         -0.04085446
  0.          0.16740722  0.          0.19275783  0.34004299  0.06331091
 -0.01709361  0.34354816  0.38125483  0.31468069  0.         -0.12043198
 -0.07645821  0.          0.17704215  0.          0.39087543  0.
 -0.02280944  0.          0.04120372]
max: 0.39087542977480494 arg: 28
mean: 0.09093065746962535
min: -0.12043198389123079 arg: 23
std: 0.14770823244503595


data_agglomerative_average/experiment_q09_clean_answers_stopwords_lemma.json
[[{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[ 0.26346835  0.          0.          0.00777692  0.28740305  0.03391219
  0.19857992  0.          0.23680347  0.22852486  0.         -0.0957331
  0.          0.29294374  0.          0.0327626   0.43313749  0.06351024
  0.04520539  0.5122476   0.44840283  0.5122476   0.         -0.09363582
  0.13711344 -0.32898594  0.14001324 -0.40948988  0.24886039  0.
 -0.02435635  0.          0.16332207]
max: 0.5122475988312847 arg: 19
mean: 0.10103134211945765
min: -0.40948988257088004 arg: 27
std: 0.2053822627323577


data_agglomerative_average/experiment_q09_raw.json
[[{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'f() returns a first class function', 'idx': 341}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'there is no passing function', 'idx': 372}]]
silhouette scores
[ 0.          0.          0.          0.06515159  0.39741284  0.05073775
  0.10842915 -0.01523884  0.37433511  0.31886839  0.          0.2147337
  0.1178141   0.          0.          0.22292486  0.45143146  0.09328807
  0.          0.35206423  0.41142195  0.06139993 -0.18850925  0.
  0.20649917 -0.1790821   0.19896213  0.          0.          0.
  0.14476039  0.          0.09504113]
max: 0.4514314625188614 arg: 16
mean: 0.10613471973477094
min: -0.1885092518753225 arg: 22
std: 0.16009529776576864


data_agglomerative_average/experiment_q10_clean_answers_full.json
[[{'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}], [{'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}], [{'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}]]
silhouette scores
[-0.03111428  0.         -0.0324535   0.49031117  0.30134357  0.27507889
  0.          0.15317504 -0.37901732  0.          0.65281657  0.
  0.3072004   0.51070578  0.33719495  0.05101855  0.39267063  0.55635148
  0.          0.39487625 -0.32682821  0.64846724  0.54104621 -0.17726535
  0.02612782  0.50070586  0.45770261  0.0604773  -0.01837361  0.
  0.24564525 -0.04837614]
max: 0.6528165670176137 arg: 10
mean: 0.18404647316959027
min: -0.3790173209293547 arg: 8
std: 0.2732002408302109


data_agglomerative_average/experiment_q10_clean_answers_only_lemma.json
[[{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}]]
silhouette scores
[ 0.03694041  0.          0.25935643  0.16761192 -0.10870928  0.11513238
 -0.04579099  0.28656016  0.01821239  0.30816683  0.37151523  0.
  0.22567082  0.12270813  0.15010912 -0.05516217  0.26788751 -0.02784474
  0.1619453  -0.02217031  0.         -0.06340054  0.29185127  0.09506808
  0.27904784  0.36928354  0.05972064  0.04139114  0.19397479  0.
  0.40721618 -0.03428167]
max: 0.4072161825308517 arg: 30
mean: 0.1210003249268706
min: -0.10870927880808401 arg: 4
std: 0.14620345775837548


data_agglomerative_average/experiment_q10_clean_answers_only_lowercase.json
[[{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}], [{'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}]]
silhouette scores
[ 0.03311527  0.          0.4088313  -0.03924188  0.12992478  0.38538925
  0.3074086   0.23888269 -0.11411103  0.68312977  0.51144556  0.51806947
  0.31371134  0.06842083 -0.02010189  0.06286871  0.13989061  0.
  0.31970705  0.30859453  0.39237503  0.33952832  0.          0.36420466
  0.04783466  0.54066789  0.37777513 -0.09706934  0.29829469  0.
  0.          0.02845365]
max: 0.6831297738592952 arg: 9
mean: 0.20462498961617256
min: -0.11411102810778914 arg: 8
std: 0.21060993648543666


data_agglomerative_average/experiment_q10_clean_answers_only_stopwords.json
[[{'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}]]
silhouette scores
[ 0.23783803  0.          0.53303057  0.42997014 -0.02643383  0.63114533
  0.          0.2140167   0.51259945  0.02498899 -0.14752177  0.
  0.18755901  0.63570861  0.11053469 -0.04941831  0.3360939   0.32966982
 -0.01214528  0.47411886 -0.02100544  0.56403862  0.52685462  0.07067303
  0.14852636  0.62817951  0.27652472  0.26366529  0.          0.
 -0.19064383  0.06880865]
max: 0.6357086113225532 arg: 13
mean: 0.21116801337321187
min: -0.19064382740973285 arg: 30
std: 0.2458429351903996


data_agglomerative_average/experiment_q10_clean_answers_stopwords_lemma.json
[[{'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}], [{'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}], [{'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}]]
silhouette scores
[-0.04079453  0.          0.0165931   0.47061989  0.30134357  0.24197411
  0.          0.15317504 -0.37901732  0.          0.65281657  0.
  0.3072004   0.51070578  0.33719495  0.05101855  0.39267063  0.55635148
  0.          0.39487625 -0.3289786   0.64846724  0.54104621 -0.19976531
  0.02612782  0.5039204   0.45770261  0.05174328 -0.01407786  0.
  0.29919222 -0.04837614]
max: 0.6528165670176137 arg: 10
mean: 0.18449157269856473
min: -0.3790173209293547 arg: 8
std: 0.2731892502356025


data_agglomerative_average/experiment_q10_raw.json
[[{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}], [{'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}]]
silhouette scores
[ 0.09689423  0.          0.35567122  0.03124895  0.08643838  0.33782278
  0.          0.12698607  0.17308236  0.10325583  0.20868339  0.
  0.46502518  0.04913762  0.08674581  0.23419477  0.22517156 -0.03995662
  0.07589137  0.21095513 -0.2386362   0.26911885  0.22643013  0.25412779
  0.29076935  0.37807611  0.29803324  0.11420473  0.          0.
  0.3907283   0.21536934]
max: 0.4650251772086142 arg: 12
mean: 0.15704592711432197
min: -0.23863619889806406 arg: 20
std: 0.15070181916654418


data_agglomerative_average/experiment_q11_clean_answers_full.json
[[{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'r yields 4', 'idx': 443}]]
silhouette scores
[ 0.         -0.21528116 -0.16151013  0.          0.21312594  0.39289768
 -0.14105472  0.69438028  0.11141378  0.25167798  0.64133802  0.10698018
  0.32775302 -0.32668399  0.56281672  0.16075691  0.48188913  0.17151018
 -0.02218819 -0.11865197 -0.22970418  0.73059748  0.          0.
  0.19736215  0.         -0.31525503 -0.01035984  0.54417128  0.27285202
 -0.23928218  0.          0.79936653]
max: 0.7993665253652315 arg: 32
mean: 0.1479066028079714
min: -0.32668399027238426 arg: 13
std: 0.3102113458991978


data_agglomerative_average/experiment_q11_clean_answers_only_lemma.json
[[{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'r yields 4', 'idx': 443}], [{'data': 'Instgant call of inline-defined function', 'idx': 472}]]
silhouette scores
[ 0.          0.19780958  0.24136993 -0.05177461 -0.15900248 -0.05725831
 -0.18402763  0.74588344  0.23382495  0.73234621  0.49019324  0.17091906
  0.36272819  0.30595014  0.38410033  0.44239056  0.46293246  0.44131299
  0.29553095 -0.15174964  0.05341012  0.32368607  0.         -0.14758534
  0.10926227 -0.23264497  0.07011642  0.          0.08290228  0.
  0.31623848  0.          0.26918094]
max: 0.7458834414833393 arg: 7
mean: 0.17418320055472303
min: -0.23264496843616905 arg: 25
std: 0.2489800306446638


data_agglomerative_average/experiment_q11_clean_answers_only_lowercase.json
[[{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}], [{'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'r yields 4', 'idx': 443}]]
silhouette scores
[ 0.          0.07017753  0.01332121  0.          0.20046031  0.6731106
  0.06569919  0.49527243  0.72152336  0.69638837  0.56968986 -0.21438704
  0.41555194  0.          0.24931974  0.66329074 -0.04433809  0.66739942
  0.51211406  0.31365952  0.          0.5797058   0.36655823  0.74282698
  0.08433074  0.32487545  0.09426637  0.10370171  0.08748287  0.01117109
  0.41242183  0.          0.58624719]
max: 0.7428269823140548 arg: 23
mean: 0.2867224669808555
min: -0.21438704380389711 arg: 11
std: 0.27906829615301687


data_agglomerative_average/experiment_q11_clean_answers_only_stopwords.json
[[{'data': 'r yields 4', 'idx': 443}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}], [{'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'r can be reassign', 'idx': 474}]]
silhouette scores
[-0.46708084 -0.07300834  0.02108941  0.35195974  0.00688695  0.44713375
  0.17766731 -0.16561773  0.17671521  0.67411623  0.77059326  0.05441911
  0.42952334 -0.16763077  0.33105738  0.35166079  0.42802473  0.17353024
  0.10151126 -0.12430717 -0.15847409  0.64009003 -0.29666735  0.
  0.09561687  0.         -0.37540075  0.00714955  0.6734115   0.
 -0.24883376  0.          0.77961014]
max: 0.7796101354486773 arg: 32
mean: 0.13984078803837025
min: -0.46708084084953283 arg: 0
std: 0.3268293781150508


data_agglomerative_average/experiment_q11_clean_answers_stopwords_lemma.json
[[{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}], [{'data': 'r yields 4', 'idx': 443}], [{'data': 'r can be reassign', 'idx': 474}]]
silhouette scores
[ 0.         -0.22689598 -0.1649334   0.          0.21312594  0.33675542
 -0.14105472  0.69438028  0.109369    0.25167798  0.64133802  0.10929542
  0.32775302 -0.32668399  0.56281672  0.17896088  0.48188913  0.17151018
 -0.02218819 -0.11865197 -0.22970418  0.73059748  0.          0.
  0.24492618  0.         -0.31525503 -0.01035984  0.54417128  0.26165343
 -0.23928218  0.          0.79936653]
max: 0.7993665253652315 arg: 32
mean: 0.14741143652739394
min: -0.32668399027238426 arg: 13
std: 0.30979098428670754


data_agglomerative_average/experiment_q11_raw.json
[[{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}], [{'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'r yields 4', 'idx': 443}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}]]
silhouette scores
[ 0.         -0.01159508  0.07504906 -0.1684787   0.16672731  0.
 -0.10469822  0.53413297  0.10842778  0.53107579 -0.44543381  0.13893427
  0.45635741  0.04579269  0.61436277  0.35393767 -0.35083632  0.45387813
  0.33433895  0.23562692  0.26808425  0.03060231  0.          0.
  0.01305234  0.          0.          0.          0.1151377   0.
  0.1751536   0.          0.4676327 ]
max: 0.6143627717079267 arg: 14
mean: 0.12234128753109555
min: -0.4454338114648455 arg: 10
std: 0.24126285623124016


data_agglomerative_average/experiment_q12_clean_answers_full.json
[[{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'r yields 4', 'idx': 477}]]
silhouette scores
[ 0.          0.11310883  0.26064796  0.42122081  0.44450218  0.21115994
  0.01602878  0.19414319  0.19210836 -0.02734878  0.24413703  0.
  0.42144612  0.07183989  0.48831262  0.267073    0.1092141   0.0417841
  0.12097483  0.17719132  0.36659601  0.3730931   0.30916815  0.
  0.5338859   0.07486117  0.1329337   0.05614237  0.          0.
  0.59949242  0.          0.48381549]
max: 0.599492421241497 arg: 30
mean: 0.20295553351325357
min: -0.02734877926138338 arg: 9
std: 0.18278974059906253


data_agglomerative_average/experiment_q12_clean_answers_only_lemma.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'r yields 4', 'idx': 477}]]
silhouette scores
[ 0.          0.          0.26827711  0.31626722 -0.02883598  0.17001145
 -0.13370024  0.25001908  0.07053423  0.2274944   0.21903931  0.
  0.14610384 -0.03179345  0.24463557  0.46640291 -0.00153379 -0.08785118
 -0.01810288  0.30325275  0.28383721  0.24715241  0.3164267   0.09546535
  0.69534946 -0.16530063  0.28656585 -0.06744596  0.00078962  0.
  0.15683949  0.          0.57112449]
max: 0.6953494608429234 arg: 24
mean: 0.14548558622723914
min: -0.16530062602106313 arg: 25
std: 0.19750449558618915


data_agglomerative_average/experiment_q12_clean_answers_only_lowercase.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}], [{'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'Same as previous', 'idx': 506}]]
silhouette scores
[ 0.16554695  0.53889206  0.247243   -0.07870042  0.72620449  0.0275969
  0.51524575  0.63852291 -0.39039886  0.36588782  0.03934909  0.15732199
  0.          0.03455817  0.05989641 -0.44330127  0.62123261  0.22771201
  0.          0.16864115  0.22965659 -0.1753495  -0.18153064  0.61074366
  0.62497133  0.2612583  -0.03625748  0.00472959 -0.1196779   0.
  0.41140324  0.35830884  0.05470552]
max: 0.7262044930813084 arg: 4
mean: 0.17164885759420068
min: -0.4433012716768527 arg: 15
std: 0.29433324466568567


data_agglomerative_average/experiment_q12_clean_answers_only_stopwords.json
[[{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}], [{'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'r yields 4', 'idx': 477}]]
silhouette scores
[ 0.00000000e+00  7.74642451e-02 -1.38736721e-01  3.12232544e-01
  4.43189324e-01  2.79545544e-01  5.46121448e-02  2.08180286e-01
  3.71617000e-01 -3.46371400e-04  2.70904124e-01  0.00000000e+00
  4.02080698e-01  4.66845844e-01  3.58305245e-01  3.56244975e-01
  6.72009935e-02  2.11962812e-01  3.18762338e-01  1.74085163e-01
  3.53155789e-01  3.33041935e-01  1.74887805e-01  1.02900181e-01
  5.17469165e-01  5.78263760e-02  1.24885713e-01  1.56722591e-01
  0.00000000e+00  0.00000000e+00  5.94002264e-01  0.00000000e+00
  4.03659392e-01]
max: 0.5940022639998638 arg: 30
mean: 0.21371822425884404
min: -0.13873672138757312 arg: 2
std: 0.17989491894573023


data_agglomerative_average/experiment_q12_clean_answers_stopwords_lemma.json
[[{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}], [{'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'do not recall nothing', 'idx': 508}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'r yields 4', 'idx': 477}]]
silhouette scores
[ 0.          0.1018956   0.28180209  0.42122081  0.44450218  0.21115994
  0.01602878  0.19414319  0.37185826 -0.02734878  0.24413703  0.
  0.42144612  0.46684584  0.48831262  0.38393561  0.1092141   0.23091136
  0.33434034  0.17719132  0.36659601  0.35302127  0.1748878   0.
  0.5338859   0.07486117  0.1329337   0.05614237  0.          0.
  0.59949242  0.          0.40365939]
max: 0.599492421241497 arg: 30
mean: 0.2293053474143931
min: -0.02734877926138338 arg: 9
std: 0.1845585577452894


data_agglomerative_average/experiment_q12_raw.json
[[{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'Same as previous', 'idx': 506}], [{'data': 'do not recall nothing', 'idx': 508}]]
silhouette scores
[ 0.          0.          0.3447022   0.29167702 -0.08239437  0.34307113
 -0.11193819  0.21872618  0.15676204  0.27576263  0.41111775  0.
  0.17020623  0.01119247  0.23094225  0.40062406  0.00969281 -0.06190338
  0.05062991  0.31016334  0.2679824   0.19090958  0.25916534  0.14356722
  0.68582913 -0.19237162  0.23247989 -0.03435721 -0.0304357   0.
  0.07208848  0.          0.56161683]
max: 0.6858291328628433 arg: 24
mean: 0.15531843675548854
min: -0.19237162280722442 arg: 25
std: 0.19756823500202098


data_agglomerative_average/experiment_q13_clean_answers_full.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}]]
silhouette scores
[ 0.52596111  0.          0.22680334 -0.24794113  0.4047667  -0.15188731
 -0.16586426  0.76484446 -0.05886774  0.          0.75480376  0.5702521
  0.         -0.09124625  0.11820392  0.0325717  -0.15065047  0.36547665
  0.37670814  0.39708523  0.13436816  0.19114031  0.45787763 -0.22203625
  0.48122681  0.05926589  0.20128621  0.2232748   0.39246237  0.
  0.22956082  0.2755849 ]
max: 0.7648444593731927 arg: 7
mean: 0.19046973695432173
min: -0.24794112966361437 arg: 3
std: 0.2696816538082382


data_agglomerative_average/experiment_q13_clean_answers_only_lemma.json
[[{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'it returns 4', 'idx': 514}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}]]
silhouette scores
[ 0.39477132  0.         -0.0606556   0.06683717  0.10299686 -0.12187655
  0.14894402  0.10113862  0.31459473  0.          0.53267403  0.36952706
  0.58408695  0.37025667 -0.05699747  0.66885232 -0.07313757  0.26883762
  0.59727094  0.40611375  0.29717368  0.21527498  0.6807357   0.08436022
  0.38654182  0.18334417  0.4630488   0.66654045  0.29965463  0.26588237
  0.31187619  0.41454237]
max: 0.6807357028751874 arg: 22
mean: 0.2776003211085697
min: -0.12187654955463147 arg: 5
std: 0.229113861881514


data_agglomerative_average/experiment_q13_clean_answers_only_lowercase.json
[[{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'the variable r will store the result of the function f', 'idx': 539}], [{'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}], [{'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}], [{'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}], [{'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'it returns 4', 'idx': 514}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}]]
silhouette scores
[ 0.09294394 -0.01922337 -0.1880308   0.          1.          0.1983923
  0.04284615  0.58576896  0.          0.          0.48705352  0.6877433
  0.14535356  0.          1.          0.46271028  0.36429561  0.63297256
  0.15960138  0.09476921  0.74637334  0.          0.         -0.27110057
  0.16797326  0.00186795  0.03577507  0.40415714  0.18777414  0.
  0.          0.21438837]
max: 1.0 arg: 4
mean: 0.22607516543967135
min: -0.27110057301525636 arg: 23
std: 0.31677358917715576


data_agglomerative_average/experiment_q13_clean_answers_only_stopwords.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}], [{'data': 'Definition of function; call of function', 'idx': 540}]]
silhouette scores
[ 0.64314159  0.          0.22146955 -0.01830648  0.4047667  -0.15188731
 -0.31381646  0.768084    0.01550365 -0.20413243  0.76506898  0.54748757
  0.         -0.09124625  0.          0.06450491 -0.18973624  0.07956
  0.30623757  0.41330767  0.13436816  0.22748456  0.57931266 -0.23118763
  0.67948275  0.046886    0.00132334  0.16181745  0.26493711  0.
  0.22956082  0.36365519]
max: 0.7680840027853449 arg: 7
mean: 0.1786764825561465
min: -0.31381645619690535 arg: 6
std: 0.29406747532491645


data_agglomerative_average/experiment_q13_clean_answers_stopwords_lemma.json
[[{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}]]
silhouette scores
[ 0.52596111  0.          0.22146955 -0.24794113  0.4047667  -0.15188731
 -0.16586426  0.76484446  0.01550365  0.          0.75480376  0.5702521
  0.         -0.09124625  0.11820392  0.03042438 -0.15065047  0.37058359
  0.37409107  0.39708523  0.13436816  0.19114031  0.45787763 -0.22203625
  0.48122681  0.05926589  0.20128621  0.2232748   0.39246237  0.
  0.22956082  0.2755849 ]
max: 0.7648444593731927 arg: 7
mean: 0.19263786674913863
min: -0.24794112966361437 arg: 3
std: 0.26790652343804217


data_agglomerative_average/experiment_q13_raw.json
[[{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}], [{'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'it returns 4', 'idx': 514}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}]]
silhouette scores
[ 0.35138015 -0.13635904 -0.00381873  0.          0.13963283  0.15668059
  0.15493163  0.13082561  0.25895321  0.          0.58068387  0.40731892
  0.58301468  0.18371104  0.          0.61762104  0.27955566  0.33344225
  0.36097938  0.25228261  0.2216497   0.23631745  0.78020912 -0.25490709
  0.45832379  0.21117905  0.41867617  0.62778574  0.2616248   0.
  0.17499322  0.06820304]
max: 0.7802091171198197 arg: 22
mean: 0.24546533428155248
min: -0.2549070934213365 arg: 23
std: 0.23144647505762755


data_agglomerative_average/experiment_q14_clean_answers_full.json
[[{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'only has one parameter', 'idx': 580}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}]]
silhouette scores
[ 0.50768425  0.09625632  0.          0.58620346  0.01682161  0.27923408
  0.27833846  0.01977371  0.54830542  0.          0.61330707 -0.11596482
  0.54489073  0.59851372  0.          0.29135603  0.19080975  0.39575373
  0.16732183  0.         -0.05692726  0.24924951 -0.00562224  0.03256126
  0.45811593  0.32946883  0.          0.06028293  0.63834067  0.
  0.2048317   0.          0.30013577]
max: 0.6383406745451301 arg: 28
mean: 0.21906189314326652
min: -0.11596481688821512 arg: 11
std: 0.23110095915936435


data_agglomerative_average/experiment_q14_clean_answers_only_lemma.json
[[{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}], [{'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}], [{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}], [{'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}], [{'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}]]
silhouette scores
[ 0.28641118  0.57792854  0.          0.45368577  0.          0.03217518
  0.00246566  0.13969915  0.10564477  0.25642387  0.50682825 -0.0236891
  0.48694817  0.          0.          0.22386587  0.0545923   0.18602515
 -0.10610057  0.          0.          0.          0.          0.04810958
  0.          0.09545927  0.          0.24419956  0.59720724  0.
 -0.28560182  0.25561241  0.20029915]
max: 0.5972072449138702 arg: 28
mean: 0.13146029033957518
min: -0.28560182000712936 arg: 30
std: 0.20280542626055806


data_agglomerative_average/experiment_q14_clean_answers_only_lowercase.json
[[{'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}], [{'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}], [{'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}], [{'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': 'only has one parameter', 'idx': 580}]]
silhouette scores
[ 0.3079228   0.          0.07856259 -0.00219893 -0.51516397  0.2514389
  0.81463808  1.          0.11990961  0.25821651  0.21319364  0.02232281
  0.0080218   0.07425722  0.20846338 -0.22932342 -0.09665716  0.16450951
  1.         -0.17063048  0.82716193  0.2396915   0.         -0.04117847
 -0.07655972  0.38403658  0.45284442 -0.01939203  0.07145247 -0.06729803
 -0.02690143  0.01557684 -0.19002804]
max: 1.0 arg: 7
mean: 0.153845118575149
min: -0.5151639736709529 arg: 4
std: 0.337332872425945


data_agglomerative_average/experiment_q14_clean_answers_only_stopwords.json
[[{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'only has one parameter', 'idx': 580}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}]]
silhouette scores
[ 0.38549349  0.17046267  0.          0.42360963  0.08202726  0.29525815
  0.34995697  0.08562197  0.49117318  0.          0.41008325 -0.05318319
  0.10028594  0.62550921  0.          0.18055901  0.21473112  0.30212068
  0.10302605  0.         -0.13820486  0.41186963  0.00267314  0.03748448
  0.55478216  0.37376995  0.06736697  0.0604681   0.52284686  0.
  0.24333348  0.          0.25168414]
max: 0.6255092146220879 arg: 13
mean: 0.1986305891660559
min: -0.13820486147644928 arg: 20
std: 0.19960221466182615


data_agglomerative_average/experiment_q14_clean_answers_stopwords_lemma.json
[[{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'only has one parameter', 'idx': 580}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}]]
silhouette scores
[ 0.50768425  0.09625632  0.          0.58620346  0.01682161  0.27923408
  0.27833846  0.01977371  0.54830542  0.          0.61330707 -0.11596482
  0.54489073  0.59851372  0.          0.29135603  0.19080975  0.39575373
  0.16732183  0.         -0.05692726  0.24924951 -0.00562224  0.03256126
  0.45811593  0.32946883  0.          0.06028293  0.63834067  0.
  0.2048317   0.          0.30013577]
max: 0.6383406745451301 arg: 28
mean: 0.21906189314326652
min: -0.11596481688821512 arg: 11
std: 0.23110095915936435


data_agglomerative_average/experiment_q14_raw.json
[[{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'The function already takes only one argument ', 'idx': 599}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}], [{'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'only has one parameter', 'idx': 580}], [{'data': "because function() take no params so it's not useful", 'idx': 598}], [{'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}], [{'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}]]
silhouette scores
[ 0.34139744  0.          0.          0.35329037  0.          0.07883613
  0.04553932 -0.17126279  0.13078319  0.30755012  0.49501558 -0.08824613
  0.47416028  0.          0.          0.24061265  0.17557486  0.27538724
 -0.04627537  0.         -0.1735348   0.09167903  0.08506764  0.02575044
  0.38054732  0.04652937  0.07665134  0.11551486  0.56791405  0.
 -0.03863333  0.20059381  0.40421013]
max: 0.5679140542902157 arg: 28
mean: 0.1331712955810591
min: -0.17353480422231346 arg: 20
std: 0.1899006243352782


data_agglomerative_average/experiment_q15_clean_answers_full.json
[[{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}], [{'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}], [{'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'Just because', 'idx': 642}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'two functions are invoked with two different params', 'idx': 632}]]
silhouette scores
[-0.30028394  0.42257012  0.29938515  0.28481842  0.55701841  0.16728284
  0.20212877 -0.19297939  0.15598888  0.          0.30240357  0.03601662
  0.          0.21652288  0.51127721  0.79292843  0.37916965  0.
  0.39667684  0.          0.19075382  0.          0.62017801 -0.15008552
  0.47766663  0.04267021 -0.04313939  0.64926163  0.04814096  0.
  0.          0.39368184  0.4113794 ]
max: 0.7929284321648996 arg: 15
mean: 0.20822521345225756
min: -0.3002839407220027 arg: 0
std: 0.2584166669791439


data_agglomerative_average/experiment_q15_clean_answers_only_lemma.json
[[{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}], [{'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}], [{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Just because', 'idx': 642}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}]]
silhouette scores
[-0.08865119  0.55576678  0.          0.43515586  0.13580912  0.0139565
  0.51103832 -0.32728074  0.54150348  0.          0.02891802  0.
  0.35428986  0.          0.04605358  0.55082122  0.43854226  0.
 -0.16298316  0.          0.25315052  0.          0.51766419  0.07335943
 -0.25975784  0.21852622  0.30551838  0.54290735  0.05491165  0.
  0.          0.51202919  0.45723585]
max: 0.5557667823547412 arg: 1
mean: 0.17298438966975754
min: -0.3272807358805356 arg: 7
std: 0.25610930559157236


data_agglomerative_average/experiment_q15_clean_answers_only_lowercase.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'two functions are invoked with two different params', 'idx': 632}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}], [{'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}], [{'data': 'Just because', 'idx': 642}]]
silhouette scores
[ 0.08428189  0.53987085  0.01819434  0.6195307   0.47791416  0.60839202
  0.19998313  0.59950031  0.          0.06689613  0.29938291  0.49198458
  0.54797893  0.07947898  0.24383406  0.57097809  0.          0.25926284
  0.24210873  0.74680897  0.50316414  0.09516423  0.05826253  0.08683956
  0.4321537   0.19293023  0.57008915  0.43021162 -0.22227367  0.
 -0.07574374  0.50934249  0.        ]
max: 0.746808974119763 arg: 19
mean: 0.28110672280027793
min: -0.222273672907859 arg: 28
std: 0.25265491812523455


data_agglomerative_average/experiment_q15_clean_answers_only_stopwords.json
[[{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}], [{'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Just because', 'idx': 642}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'two functions are invoked with two different params', 'idx': 632}]]
silhouette scores
[-0.22347561  0.49981627  0.2913389   0.14468768  0.40127633  0.21682372
  0.33108013  0.21462249  0.1358907   0.          0.32958371  0.1882814
  0.03351217  0.4836048   0.32653781  0.79533717 -0.07546132  0.
  0.47524385  0.          0.34989517  0.          0.62111073  0.14780684
  0.60802196  0.00765557  0.14813827  0.67839142  0.30400316  0.
  0.01829043  0.6281866   0.00467474]
max: 0.795337173702663 arg: 15
mean: 0.24499621482607856
min: -0.2234756144014175 arg: 0
std: 0.2477871939866388


data_agglomerative_average/experiment_q15_clean_answers_stopwords_lemma.json
[[{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}], [{'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}], [{'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'Just because', 'idx': 642}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'two functions are invoked with two different params', 'idx': 632}]]
silhouette scores
[-0.30028394  0.42257012  0.29938515  0.28481842  0.55701841  0.16728284
  0.20212877 -0.19297939  0.15598888  0.          0.30240357  0.03601662
  0.          0.21652288  0.51127721  0.79292843  0.37916965  0.
  0.39667684  0.          0.19075382  0.          0.62017801 -0.15008552
  0.47766663  0.04267021 -0.04313939  0.64926163  0.04814096  0.
  0.          0.39368184  0.4113794 ]
max: 0.7929284321648996 arg: 15
mean: 0.20822521345225756
min: -0.3002839407220027 arg: 0
std: 0.2584166669791439


data_agglomerative_average/experiment_q15_raw.json
[[{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}], [{'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}], [{'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}], [{'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}], [{'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'Just because', 'idx': 642}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'two functions are invoked with two different params', 'idx': 632}]]
silhouette scores
[-0.27632385  0.63683784  0.30431272  0.05868863  0.02941843  0.2182084
  0.42205352  0.33903063  0.52755652  0.          0.          0.3963713
  0.26647426  0.         -0.05393526  0.62563735  0.21827201  0.
  0.31961165  0.          0.39331377  0.          0.5293959   0.46335817
  0.07332121  0.24991227 -0.02520693  0.53590673  0.5139281   0.
 -0.12417253  0.60651822  0.06196197]
max: 0.6368378403686252 arg: 1
mean: 0.221528819251142
min: -0.2763238539808829 arg: 0
std: 0.24662376273449452


data_agglomerative_average/experiment_q16_clean_answers_full.json
[[{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}], [{'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}]]
silhouette scores
[ 0.37371721  0.31079594  0.12367158  0.          0.48965626 -0.05708163
  0.12058391  0.29656531  0.5839439   0.29507671  0.18232343  0.32921022
  0.618504   -0.10210512  0.68545862  0.67793717 -0.19199799  0.
  0.68321706  0.          0.45177714  0.58858454  0.          0.00681755
  0.55957232  0.51825509  0.04784979  0.          0.56357329  0.13465181
  0.         -0.04862319  0.        ]
max: 0.6854586162652618 arg: 14
mean: 0.24975560350594347
min: -0.1919979912060111 arg: 16
std: 0.2700753405919725


data_agglomerative_average/experiment_q16_clean_answers_only_lemma.json
[[{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}], [{'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}], [{'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[-0.05567235 -0.15712998  0.38852663  0.          0.54042572  0.18288676
 -0.01407837  0.18046434  0.70963916  0.48757436  0.35601993 -0.13439186
  0.50902049  0.          0.47394735  0.74220062  0.17915476  0.
  0.7818739   0.          0.0356974   0.61416002  0.15752882  0.0607397
 -0.14380428  0.62489344  0.56014127  0.          0.55951667  0.
  0.          0.          0.16243731]
max: 0.7818738980377103 arg: 18
mean: 0.2364173270458011
min: -0.1571299813210001 arg: 1
std: 0.2875195916383563


data_agglomerative_average/experiment_q16_clean_answers_only_lowercase.json
[[{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[ 0.41230469  0.59931574  0.14881978 -0.16537213  0.02446875  0.5368022
  0.0610269   0.50923072  0.37990184  0.31871193  0.28599691  0.25753336
 -0.25111034  0.07657396 -0.09546004  0.31215949  0.30756302 -0.03388367
  0.3121396   0.45081204  0.36130142  0.53818232  0.10975056 -0.05788873
 -0.01459956  0.16859172  0.28028808  0.          0.05924496  0.
  0.          0.          0.1005783 ]
max: 0.5993157434755392 arg: 1
mean: 0.1816055708281034
min: -0.251110337429663 arg: 12
std: 0.2177298307198228


data_agglomerative_average/experiment_q16_clean_answers_only_stopwords.json
[[{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}]]
silhouette scores
[ 0.3274774   0.31329997  0.06390166  0.          0.50143916 -0.04679007
  0.18680685  0.24804571  0.60808436  0.31741906  0.06514652  0.27410985
  0.65190395 -0.10779699  0.66129979  0.66100922 -0.1814148  -0.01441834
  0.68839323 -0.1722825   0.39488021  0.52511331  0.         -0.01546133
  0.52968739  0.50800062  0.15963914  0.02401764  0.53218195  0.13179046
 -0.03224123 -0.03145594  0.        ]
max: 0.6883932314564389 arg: 18
mean: 0.23550867446883852
min: -0.1814147952165106 arg: 16
std: 0.27112969537807075


data_agglomerative_average/experiment_q16_clean_answers_stopwords_lemma.json
[[{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}], [{'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}]]
silhouette scores
[ 0.37371721  0.31079594  0.12367158  0.          0.48965626 -0.05708163
  0.12058391  0.29656531  0.5839439   0.29507671  0.18232343  0.32921022
  0.618504   -0.10210512  0.68545862  0.67793717 -0.19199799  0.
  0.68321706  0.          0.45177714  0.58858454  0.          0.00681755
  0.55957232  0.51825509  0.04784979  0.          0.56357329  0.13465181
  0.         -0.04862319  0.        ]
max: 0.6854586162652618 arg: 14
mean: 0.24975560350594347
min: -0.1919979912060111 arg: 16
std: 0.2700753405919725


data_agglomerative_average/experiment_q16_raw.json
[[{'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}], [{'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}], [{'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[-0.32805165 -0.22449567  0.54394282  0.          0.12418789  0.20505467
  0.11063566  0.26929488  0.56165527  0.47777336  0.49499603 -0.09613372
  0.4770839   0.          0.58094294  0.43497921  0.44929404 -0.03073047
  1.          0.         -0.10422147  0.43530055  0.          0.13539916
 -0.06264993  1.          0.25208171 -0.00858905  0.54436056  0.
 -0.00551379 -0.0835673   0.23089378]
max: 1.0 arg: 18
mean: 0.22375525441210325
min: -0.3280516549834556 arg: 0
std: 0.3182297221379153


data_agglomerative_average/experiment_q17_clean_answers_full.json
[[{'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}], [{'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'print that', 'idx': 814}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}], [{'data': 'the output is correct.', 'idx': 805}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[-0.33916789  0.          0.47983425  0.          0.05193218 -0.0028114
  0.          0.          0.48839851  0.13121438  0.63067888  0.06641405
  0.20098363  0.06430738 -0.48699284  0.65094347 -0.09051799 -0.35185483
  0.          0.41680785 -0.12819066  0.53635274  0.0575001   0.
  0.21258878 -0.1390256  -0.20848762 -0.19492344  0.          0.62791406]
max: 0.6509434706446291 arg: 15
mean: 0.08912993349098287
min: -0.486992835122072 arg: 14
std: 0.29588232100041145


data_agglomerative_average/experiment_q17_clean_answers_only_lemma.json
[[{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}], [{'data': 'the output is correct.', 'idx': 805}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}], [{'data': 'print that', 'idx': 814}]]
silhouette scores
[-0.05748701  0.          0.04335979  0.5975055   0.23400654  0.00747343
  0.          0.03025527 -0.14584287 -0.21896357  0.01587851  0.
  0.06049817 -0.02214943  0.11335906  0.51062503 -0.30122388  0.64445544
 -0.09023276  0.40567164 -0.14145132 -0.2952339   0.38802638  0.
  0.23459796  0.          0.1239844   0.13425782  0.          0.54743848]
max: 0.6444554426437147 arg: 17
mean: 0.09396028926550537
min: -0.30122387585239063 arg: 16
std: 0.24663782223738226


data_agglomerative_average/experiment_q17_clean_answers_only_lowercase.json
[[{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'print that', 'idx': 814}], [{'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[ 0.539756    0.17326831 -0.07383822  0.3074663   0.72581581  0.29986135
  0.69036542 -0.01658605  0.313844    0.47264928  0.33396491  0.18604355
  0.16608031  0.78088145  0.          0.57744668 -0.12975325  0.22523894
  0.43611969  0.92511348  0.6594645   0.30069232  0.44635137 -0.09909027
  0.          0.23242121  0.         -0.14157544  0.94775322  0.        ]
max: 0.9477532163856552 arg: 28
mean: 0.30932516124166354
min: -0.14157543780899537 arg: 27
std: 0.31110521133859437


data_agglomerative_average/experiment_q17_clean_answers_only_stopwords.json
[[{'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'print that', 'idx': 814}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}], [{'data': 'the output is correct.', 'idx': 805}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[-0.33662909  0.         -0.09701608  0.35026043  0.03333303 -0.0155107
  0.          0.          0.49055303  0.12198901  0.22680468  0.09241695
  0.19702408  0.07079372 -0.41971344  0.24479186 -0.16918023  0.71098134
  0.          0.40575246 -0.12442657  0.          0.05514751  0.
  0.22322498 -0.1252921  -0.22912997 -0.20829166  0.          0.62855472]
max: 0.710981338732381 arg: 17
mean: 0.07088126553692418
min: -0.4197134420765218 arg: 14
std: 0.2559444857558544


data_agglomerative_average/experiment_q17_clean_answers_stopwords_lemma.json
[[{'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}], [{'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'print that', 'idx': 814}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}], [{'data': 'the output is correct.', 'idx': 805}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[-0.33916789  0.          0.47983425  0.          0.05193218 -0.0028114
  0.          0.          0.48839851  0.13121438  0.63067888  0.06641405
  0.20098363  0.06430738 -0.48699284  0.65094347 -0.09051799 -0.35185483
  0.          0.41680785 -0.12819066  0.53635274  0.0575001   0.
  0.21258878 -0.1390256  -0.20848762 -0.19492344  0.          0.62791406]
max: 0.6509434706446291 arg: 15
mean: 0.08912993349098287
min: -0.486992835122072 arg: 14
std: 0.29588232100041145


data_agglomerative_average/experiment_q17_raw.json
[[{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}], [{'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}], [{'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}], [{'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'the output is correct.', 'idx': 805}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}], [{'data': 'print that', 'idx': 814}]]
silhouette scores
[ 0.19193134  0.          0.44547544  0.77850374  0.1736363   0.0393523
  0.          0.          0.03484584 -0.19713534  0.51242271  0.
  0.2631903   0.40424428  0.15147272  0.08345755  0.          0.53113135
 -0.10227333  0.28677272  0.          0.42843062  0.36838231  0.
  0.26482461  0.         -0.21685269  0.28192159  0.          0.42716115]
max: 0.7785037386105755 arg: 3
mean: 0.17169651634338431
min: -0.2168526939661529 arg: 26
std: 0.23288535163023316


data_agglomerative_average/experiment_q18_clean_answers_full.json
[[{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'after printing c1, the system teminates', 'idx': 818}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}], [{'data': 'is a wrong result of continuation', 'idx': 848}]]
silhouette scores
[ 4.84591957e-02  0.00000000e+00  6.13196754e-01  3.97413787e-01
  1.91612165e-01 -8.15828018e-02  2.89370918e-01  1.79672738e-01
  3.87237711e-01  7.52366541e-01  1.17782968e-01  0.00000000e+00
  0.00000000e+00  2.67782848e-01  6.09797286e-01  4.12757094e-01
 -9.85549450e-03  4.06427172e-01  5.51287915e-01  3.20147642e-01
  0.00000000e+00  2.67109118e-01  6.49235265e-01  2.08410558e-02
  2.32457086e-04  2.86129381e-01  4.24863752e-01  0.00000000e+00
 -2.68029525e-01]
max: 0.752366541410475 arg: 9
mean: 0.23566399798506807
min: -0.26802952523278434 arg: 28
std: 0.25107405839306474


data_agglomerative_average/experiment_q18_clean_answers_only_lemma.json
[[{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}], [{'data': 'Because after printing c1 the process exits.', 'idx': 827}], [{'data': 'after printing c1, the system teminates', 'idx': 818}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}], [{'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'See Option 1.', 'idx': 819}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'The last output is ft2', 'idx': 829}]]
silhouette scores
[ 0.16956046  0.          0.31953082  0.37606909  0.21961304  0.
  0.28907814 -0.04174937 -0.02248986  0.40566201  0.          0.25102153
  0.          0.15438491  0.45904611  0.17785909  0.          0.31076777
  0.41642148  0.1142291   0.49678203  0.4284422   0.57610364  0.39024094
  0.07482558  0.25823926  0.38745874  0.          0.45652478]
max: 0.576103641786524 arg: 22
mean: 0.22991798289285845
min: -0.04174936882755981 arg: 7
std: 0.18527505888143908


data_agglomerative_average/experiment_q18_clean_answers_only_lowercase.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}], [{'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': 'Because after printing c1 the process exits.', 'idx': 827}], [{'data': 'See Option 1.', 'idx': 819}], [{'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}]]
silhouette scores
[ 0.26963219  0.06483721  0.          0.95142572  0.58393914  0.85902411
  0.44673355 -0.0027263  -0.01702431  0.52629894  0.          0.24317073
  0.          0.32031953 -0.32335009  0.01117063  0.35989294  0.83699221
  0.23398659  0.          0.71067952  0.7560283   0.06557474  0.35421102
  0.06941838  0.          0.47555952  0.91567482  0.50198413]
max: 0.9514257246268768 arg: 3
mean: 0.3177052844982338
min: -0.3233500884351885 arg: 14
std: 0.33681053351830004


data_agglomerative_average/experiment_q18_clean_answers_only_stopwords.json
[[{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}], [{'data': 'is a wrong result of continuation', 'idx': 848}]]
silhouette scores
[ 0.25273219  0.37987057  0.61319675  0.49461695  0.19161217  0.10791442
  0.28937092  0.28714374  0.36935062  0.75236654  0.09683994  0.55063872
  0.          0.26290993  0.58443963  0.30993151  0.06597363  0.50991637
  0.55128792  0.32014764  0.          0.26710912  0.64073961  0.18616363
  0.13226942  0.24796744  0.45167581  0.         -0.26802953]
max: 0.752366541410475 arg: 9
mean: 0.29821226455882444
min: -0.26802952523278434 arg: 28
std: 0.2295695884963182


data_agglomerative_average/experiment_q18_clean_answers_stopwords_lemma.json
[[{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'after printing c1, the system teminates', 'idx': 818}], [{'data': 'The last output is ft2', 'idx': 829}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}], [{'data': 'is a wrong result of continuation', 'idx': 848}]]
silhouette scores
[ 4.84591957e-02  0.00000000e+00  6.13196754e-01  3.97413787e-01
  1.91612165e-01 -8.15828018e-02  2.89370918e-01  1.79672738e-01
  3.87237711e-01  7.52366541e-01  1.17782968e-01  0.00000000e+00
  0.00000000e+00  2.67782848e-01  6.09797286e-01  4.12757094e-01
 -9.85549450e-03  4.06427172e-01  5.51287915e-01  3.20147642e-01
  0.00000000e+00  2.67109118e-01  6.49235265e-01  2.08410558e-02
  2.32457086e-04  2.86129381e-01  4.24863752e-01  0.00000000e+00
 -2.68029525e-01]
max: 0.752366541410475 arg: 9
mean: 0.23566399798506807
min: -0.26802952523278434 arg: 28
std: 0.25107405839306474


data_agglomerative_average/experiment_q18_raw.json
[[{'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}], [{'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}], [{'data': 'after printing c1, the system teminates', 'idx': 818}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}], [{'data': 'The last output is ft2', 'idx': 829}]]
silhouette scores
[ 0.02966964  0.          0.33836868  0.4592219  -0.04470823  0.32248596
  0.15886738  0.         -0.13128758  0.41724508  0.1750792   0.10563161
  0.          0.18638125  0.56524649  0.37759207 -0.22360005  0.45653499
  0.31162715  0.24560926  0.14723217 -0.01516301  0.64217281  0.24659943
 -0.1139636   0.19295301  0.35096895  0.          0.05161198]
max: 0.6421728092279345 arg: 22
mean: 0.18111643256742269
min: -0.22360005147053075 arg: 16
std: 0.2136047038035947


data_agglomerative_average/experiment_q19_clean_answers_full.json
[[{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'This is wrong as it never prints out ft1', 'idx': 856}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}]]
silhouette scores
[-0.02112101  0.23274738  0.69533031 -0.41859766  0.06684445  0.
  0.37956415  0.18074401  0.48650165  0.8483603   0.47797059 -0.09226917
  0.          0.50108077  0.61740387  0.18411066 -0.0317686   0.2701718
  0.54784659  0.33315159  0.30844143  0.33753243  0.50600389  0.31657549
  0.          0.15733331  0.10353331  0.31667368]
max: 0.8483602967233558 arg: 9
mean: 0.2608630426502961
min: -0.4185976578228713 arg: 3
std: 0.2695821151312915


data_agglomerative_average/experiment_q19_clean_answers_only_lemma.json
[[{'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'not correct', 'idx': 882}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}]]
silhouette scores
[ 0.          0.42681669  0.51121275 -0.50399372  0.28463418  0.09191576
  0.33292213  0.16927741  0.          0.43614527  0.93221026  0.26367749
  0.          0.88058203  0.82772141  0.19076183  0.62128279  0.00782138
  0.48572093  0.60449245  0.56874006  0.21774073  0.35575358 -0.04608185
  0.          0.01880752  0.61856456  0.15706315]
max: 0.9322102602155821 arg: 10
mean: 0.30192102846099317
min: -0.5039937209064203 arg: 3
std: 0.3215141449881849


data_agglomerative_average/experiment_q19_clean_answers_only_lowercase.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}], [{'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': 'not correct', 'idx': 882}], [{'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'See Option 1.', 'idx': 853}]]
silhouette scores
[ 0.2102577   0.1429446   0.         -0.01285117  0.22030297  0.64318696
  0.42160764  0.35997095  0.2962085   0.30168654  0.66465179  0.
  0.          0.46027729  0.36379985  0.21476005  0.          0.
  0.51427344  0.33031686  0.43229595  0.4680953   0.37635255  0.25415738
  0.11694287  0.17143737  0.          0.08192233]
max: 0.6646517856319593 arg: 10
mean: 0.2511642043970051
min: -0.012851168961801709 arg: 3
std: 0.19950498358625118


data_agglomerative_average/experiment_q19_clean_answers_only_stopwords.json
[[{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}]]
silhouette scores
[ 0.02478866  0.25147699  0.69533031  0.33129862  0.06684445  0.0499252
  0.37956415  0.25604921  0.43064899  0.8483603   0.65981996 -0.004059
  0.          0.55101192  0.6363102   0.25032019 -0.02323168  0.34859118
  0.54784659  0.33315159  0.30844143  0.34063043  0.2377926   0.06880159
  0.          0.27719819  0.10353331  0.31667368]
max: 0.8483602967233558 arg: 9
mean: 0.2959685376991104
min: -0.023231680926189373 arg: 16
std: 0.23346351062093854


data_agglomerative_average/experiment_q19_clean_answers_stopwords_lemma.json
[[{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'This is wrong as it never prints out ft1', 'idx': 856}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}]]
silhouette scores
[-0.02112101  0.23274738  0.69533031 -0.41859766  0.06684445  0.
  0.37956415  0.18074401  0.48650165  0.8483603   0.47797059 -0.09226917
  0.          0.50108077  0.61740387  0.18411066 -0.0317686   0.2701718
  0.54784659  0.33315159  0.30844143  0.33753243  0.50600389  0.31657549
  0.          0.15733331  0.10353331  0.31667368]
max: 0.8483602967233558 arg: 9
mean: 0.2608630426502961
min: -0.4185976578228713 arg: 3
std: 0.2695821151312915


data_agglomerative_average/experiment_q19_raw.json
[[{'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}]]
silhouette scores
[ 0.73293573  0.40542342  0.6065526   0.64689301  0.13742333  0.15639273
  0.15321519  0.17569169  0.          0.60004748  0.85661335  0.1988051
  0.          0.93120775  0.81298812  0.37549313  0.59378809  0.12491721
  0.57939598  0.40049813  0.24356645 -0.04538625  0.39549927  0.0773041
  0.         -0.01521749  0.04002226  0.32576672]
max: 0.9312077478596639 arg: 13
mean: 0.3396370385442941
min: -0.0453862542157852 arg: 21
std: 0.28996409735901957


