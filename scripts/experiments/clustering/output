./data/experiment_q00_clean_answers_full.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'You can change the variable name for another string.', 'idx': 26}]]
silhouette scores
[ 0.38190245 -0.05525168  0.27359212  0.01728179 -0.07630797  0.27908834
  0.06322288  0.13400168  0.13979035  0.27755655  0.36180211  0.34058169
  0.          0.07648096 -0.1074898   0.14060773  0.33491514 -0.21314365
 -0.26483042 -0.15682816  0.05857031  0.11129388  0.14079614  0.08634705
 -0.03292182 -0.28668408  0.32449421  0.20809503  0.31745744  0.0755062
 -0.00993832  0.52788234  0.15636257]
max: 0.5278823350893154 arg: 31
mean: 0.10982524408387569
min: -0.2866840822500934 arg: 25
std: 0.1945719631683931


./data/experiment_q00_clean_answers_only_lemma.json
[[{'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}], [{'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 0.38598522  0.63568681  0.19417709  0.05258787  0.21100232  0.00819941
  0.110028    0.13770597  0.03583865  0.30465891  0.3254018   0.25037008
  0.12358009  0.08551356  0.20695468 -0.07573423  0.10210603  0.34143914
 -0.08689132 -0.42996462 -0.00879733  0.48175875  0.66835392 -0.26926402
  0.62696317 -0.04614032  0.13371642 -0.05745897  0.24976274  0.111101
 -0.50141298 -0.03202543  0.14974891]
max: 0.6683539198429652 arg: 22
mean: 0.1340894336014138
min: -0.5014129841869378 arg: 30
std: 0.26091178395815806


./data/experiment_q00_clean_answers_only_lowercase.json
[[{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 0.48404158  0.11450832  0.18646775  0.23838078 -0.44553295  0.23582734
 -0.19567347  0.04736103  0.0785344   0.41146546  0.46299978 -0.00984137
  0.14879301 -0.12809908  0.03505887  0.32627473 -0.22990933 -0.12059741
  0.01783338  0.06486994 -0.26741958 -0.01397276  0.25128186  0.13739816
 -0.18096774  0.14117345 -0.09805806 -0.52995324  0.40645972  0.33607203
  0.24163868 -0.12144723 -0.04996369]
max: 0.48404157698293837 arg: 0
mean: 0.05984861750038911
min: -0.5299532434433065 arg: 27
std: 0.24459055269591234


./data/experiment_q00_clean_answers_only_stopwords.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}]]
silhouette scores
[ 0.38190245 -0.03436441  0.27947437 -0.02721924 -0.07901127  0.10014203
  0.19344054  0.13870582  0.20709658  0.27755655  0.37354112  0.33796277
  0.         -0.04865531 -0.10524741  0.13527966  0.34314708 -0.16098179
 -0.26483042 -0.16280286 -0.05987504  0.10771451  0.16241851  0.07178198
 -0.03255747 -0.31734696  0.31402357  0.22245237  0.32639819  0.00570226
 -0.00707259  0.45131325  0.15187706]
max: 0.4513132452583571 arg: 31
mean: 0.09945351132327356
min: -0.31734696383525857 arg: 25
std: 0.19447564916042812


./data/experiment_q00_clean_answers_stopwords_lemma.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}]]
silhouette scores
[ 0.38190245 -0.34668394  0.21698159  0.01728179 -0.07630797  0.27908834
  0.06322288  0.13400168  0.13979035  0.27755655  0.24122386  0.33465605
  0.          0.07648096  0.16611375  0.          0.26930419 -0.21314365
 -0.26483042 -0.11406129  0.05857031  0.11129388  0.09708248  0.02087658
 -0.27322863 -0.28668408  0.2565321   0.06244915  0.31745744  0.09193102
  0.1194987   0.52788234  0.15636257]
max: 0.5278823350893154 arg: 31
mean: 0.08613942508810672
min: -0.3466839416422606 arg: 1
std: 0.20258772044047377


./data/experiment_q00_raw.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}, {'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': 'To be immutable should have final', 'idx': 20}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}]]
silhouette scores
[ 0.76946388  0.46313892  0.21298288 -0.10794153  0.02747555 -0.10632345
  0.07445555  0.22734893 -0.01433465  0.76946388  0.18429557  0.32082083
  0.16677313  0.09295122  0.07693764 -0.01177842  0.32544161 -0.24379799
  0.3438641  -0.09761482  0.12887033 -0.0747883   0.55674605 -0.22435039
  0.50716271  0.02083966  0.16846118  0.3846675  -0.32316486 -0.14667319
  0.34404651  0.02022606  0.03552716]
max: 0.7694638813858174 arg: 0
mean: 0.14761191657407
min: -0.3231648621772842 arg: 28
std: 0.2663511977665375


./data/experiment_q01_clean_answers_full.json
[[{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}]]
silhouette scores
[ 0.7838384  -0.21246111  0.12877665  0.1860302   0.23483901  0.21709175
  0.0509426   0.12250072  0.0617949   0.          0.72364395 -0.22501213
  0.3425614   0.13582453  0.13730492  0.0345077   0.12395451 -0.37097458
  0.07319244  0.25836847  0.00767859 -0.16807625  0.22958773 -0.22786826
 -0.23407988  0.24359524  0.137261    0.12982093 -0.01405356  0.14252649
  0.31997815  0.27756899  0.30054777]
max: 0.7838383994509975 arg: 0
mean: 0.11973367522558581
min: -0.37097458134970807 arg: 17
std: 0.23929236915658308


./data/experiment_q01_clean_answers_only_lemma.json
[[{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'It is marked with keyword final.', 'idx': 56}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}], [{'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}]]
silhouette scores
[ 0.97480899  0.01612466  0.11019492 -0.06303312 -0.213238   -0.00429797
  0.61000654  0.23932797  0.125407    0.22341505  0.97220379  0.61556143
  0.27427744 -0.10125646  0.15976199  0.35430244 -0.33621628  0.44202728
  0.19894661  0.3158862   0.3015671   0.          0.14298439 -0.09028212
 -0.31766576  0.51269528 -0.31124012  0.18775766  0.055271    0.10884942
  0.42142551  0.16953632  0.17730627]
max: 0.9748089892381736 arg: 0
mean: 0.19007319475299853
min: -0.33621627887803607 arg: 16
std: 0.31098393219970444


./data/experiment_q01_clean_answers_only_lowercase.json
[[{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}], [{'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}]]
silhouette scores
[ 0.35756551  0.06147668  0.23907714  0.0879138   0.12207221  0.56126517
  0.29903477 -0.20209607  0.14006893  0.35020301  0.5200187  -0.13092156
  0.11943017  0.48291517  0.36057692  0.20083831  0.38586623 -0.11231422
  0.26752664  0.74003521  0.19739031  0.39691776  0.37089228  0.2970199
 -0.03686574  0.12620686 -0.17664997  0.05844928  0.         -0.12784918
 -0.4156138   0.01766669  0.24157456]
max: 0.7400352144993035 arg: 19
mean: 0.17574823239706533
min: -0.41561379796673953 arg: 30
std: 0.2454272711221912


./data/experiment_q01_clean_answers_only_stopwords.json
[[{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}]]
silhouette scores
[ 0.44876913 -0.10885864  0.27773762  0.14642042  0.19538841  0.21909655
  0.28334131  0.12021251  0.20846577  0.61663252  0.52855264 -0.259971
 -0.21725204  0.39207584  0.13710983  0.02480957 -0.10982327  0.54020782
  0.18752673  0.25734341  0.02212067 -0.19315152  0.22958773 -0.25077439
 -0.32474209  0.28776548  0.10045427  0.17567429 -0.08074176  0.1600189
  0.47430671  0.27936761  0.30392115]
max: 0.6166325197174279 arg: 9
mean: 0.15368461115387935
min: -0.32474208996059223 arg: 24
std: 0.24118958438005217


./data/experiment_q01_clean_answers_stopwords_lemma.json
[[{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}]]
silhouette scores
[ 0.28149952  0.05785943  0.3663533   0.1956694   0.01646534  0.21709175
  0.28269072  0.18735629  0.14090606  0.62076511  0.52639858  0.
  0.25740349  0.32021327  0.28608857  0.25209176 -0.02381553  0.37027423
  0.18326752  0.25836847  0.14602488  0.45487232  0.22958773  0.10067899
  0.30785644  0.39920226  0.0400102   0.17167322  0.00954942  0.1996843
  0.44558577  0.27009576  0.30054777]
max: 0.6207651063765488 arg: 9
mean: 0.2385550402661875
min: -0.023815528752915087 arg: 16
std: 0.15096749755070815


./data/experiment_q01_raw.json
[[{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}], [{'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}], [{'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}]]
silhouette scores
[ 0.40255191 -0.25514605  0.07048883 -0.07255227 -0.08234368  0.24734008
 -0.11403442  0.18278618  0.2618553   0.24979538  0.52593738 -0.05677326
  0.46801581  0.29728318  0.10646362  0.19215438  0.07227528  0.389761
  0.27714102 -0.05175533  0.18998419  0.57830989  0.15471217 -0.17473096
  0.23001751 -0.00836211  0.1665584   0.04007616  0.32857102  0.12243727
 -0.1854054   0.06021085  0.33094144]
max: 0.5783098878583919 arg: 21
mean: 0.14983529663740677
min: -0.2551460494808146 arg: 1
std: 0.20536587042262647


./data/experiment_q02_clean_answers_full.json
[[{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}]]
silhouette scores
[ 0.69381985  0.4309568   0.05875227  0.08596797  0.39501933  0.35357084
  0.64983805 -0.17281236  0.10276396 -0.10749781  0.52997406  0.06872505
  0.38714501  0.11440102  0.06951749  0.31288185  0.21119971  0.22597448
  0.07204356  0.1601966  -0.29847993 -0.25491151  0.62940531 -0.24912782
 -0.04678057 -0.13160704  0.37089789 -0.11288618  0.36738974  0.24214263
 -0.03501572 -0.1664724  -0.03254766]
max: 0.6938198472445047 arg: 0
mean: 0.14922558968830346
min: -0.298479925747775 arg: 20
std: 0.2686637301759281


./data/experiment_q02_clean_answers_only_lemma.json
[[{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}]]
silhouette scores
[ 0.67720296 -0.13681682  0.24150614  0.39808082  0.38643683  0.23445501
  0.42695193  0.27180469 -0.02508247  0.39964091 -0.35273469  0.21327978
  0.46957051 -0.06745737  0.18329193  0.22942136  0.4225306   0.14163507
 -0.24152294  0.46225646  0.          0.15057168  0.18839603  0.17867625
  0.06811206 -0.13923921  0.56930672  0.23737753 -0.16203418  0.
  0.20871611  0.10505258  0.15739755]
max: 0.67720295647783 arg: 0
mean: 0.1786904189720944
min: -0.3527346939897482 arg: 10
std: 0.23440605023166686


./data/experiment_q02_clean_answers_only_lowercase.json
[[{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}], [{'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.59672585  0.27109681  0.12377279  0.2714234  -0.16320032  0.30952187
  0.21397149 -0.28699857  0.29311841 -0.02294266  0.1887661   0.15493184
 -0.52937642  0.50111078 -0.19272761 -0.31753955  0.17267436  0.31587431
  0.02874514 -0.13165195 -0.03533902 -0.03709789 -0.37847941 -0.08237619
  0.35187139  0.          0.12223029 -0.15514534  0.91525342 -0.04390387
 -0.51281206  0.87148115  0.11455809]
max: 0.9152534161353897 arg: 28
mean: 0.08871323018017359
min: -0.5293764174533339 arg: 12
std: 0.3331793986867487


./data/experiment_q02_clean_answers_only_stopwords.json
[[{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.67971986  0.38974217 -0.03314729  0.03140336  0.33734307  0.22651141
  0.62014077 -0.21199742  0.10560981 -0.15551008  0.05541806  0.24098484
  0.37252613 -0.01652663  0.07089904  0.28925813  0.30499189 -0.38480879
  0.06716694  0.05683949 -0.09282236 -0.1684774   0.31119046 -0.15232165
  0.03679593 -0.12018291  0.35258621 -0.26541504  0.34736755  0.27576159
  0.39347073 -0.1641447  -0.05126338]
max: 0.6797198575019986 arg: 0
mean: 0.11360938782942763
min: -0.3848087872317818 arg: 17
std: 0.25265037240281174


./data/experiment_q02_clean_answers_stopwords_lemma.json
[[{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}]]
silhouette scores
[ 0.69381985  0.4309568   0.02006811  0.09868572  0.37319542  0.28315009
  0.64983805 -0.19966156  0.10276396 -0.08588613  0.54056993  0.06872505
  0.36336785  0.11440102  0.06951749  0.31627903  0.21119971  0.22597448
  0.07204356  0.18273924 -0.29847993 -0.25491151  0.62940531 -0.24667153
 -0.04678057 -0.12458369  0.37089789 -0.11288618  0.36738974  0.24214263
 -0.03501572 -0.1664724  -0.03254766]
max: 0.6938198472445047 arg: 0
mean: 0.14615860756205026
min: -0.298479925747775 arg: 20
std: 0.26717991193950225


./data/experiment_q02_raw.json
[[{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}], [{'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}]]
silhouette scores
[ 0.32658806  0.10933175  0.52487588  0.09440003  0.38667689  0.19758994
  0.18743839  0.40980175 -0.03910257 -0.03066634 -0.16694359  0.20139071
  0.24344268 -0.06438383  0.09190062  0.18496548  0.32874553 -0.04342721
  0.25180662  0.03775266  0.0899984   0.20005982 -0.08690847  0.01695506
 -0.23052964  0.00579317  0.47639604 -0.1202315  -0.00587464  0.
  0.48925462 -0.09170118  0.11896637]
max: 0.5248758832440641 arg: 2
mean: 0.12407156107663002
min: -0.23052963988784428 arg: 24
std: 0.1946971853284261


./data/experiment_q03_clean_answers_full.json
[[{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'Immutable object has no mutators', 'idx': 132}]]
silhouette scores
[-0.47934732  0.08677454  0.06206517 -0.11918303  0.02531805  0.27506158
 -0.28536078 -0.08246776  0.51117967 -0.04059769 -0.13749955  0.20808275
  0.17272615  0.17974213  0.24061026  0.05268612 -0.39379098  0.12454208
  0.1901956   0.92143856  0.28487145 -0.0592062  -0.1764975  -0.15759437
 -0.02609987 -0.21101114  0.20744477  0.21169731  0.57226006 -0.21643411
  0.48247074 -0.15976717]
max: 0.9214385606284625 arg: 19
mean: 0.07075967288438018
min: -0.4793473239337102 arg: 0
std: 0.28884322003003493


./data/experiment_q03_clean_answers_only_lemma.json
[[{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}]]
silhouette scores
[ 0.13576805 -0.40763074 -0.02473697 -0.06388788 -0.14924402  0.31366857
 -0.08932976  0.00919665  0.64496013  0.3153041  -0.25620553 -0.02052424
 -0.0615971   0.49420063  0.         -0.13610801 -0.32585183  0.158041
  0.45525915 -0.68910858  0.          0.67175176 -0.17987373 -0.06873256
 -0.10717596 -0.35151355 -0.05268258  0.26866757  0.9274974   0.25926176
  0.41590838 -0.27032423]
max: 0.927497399683258 arg: 28
mean: 0.05671743372110083
min: -0.6891085759648443 arg: 19
std: 0.34224573815534176


./data/experiment_q03_clean_answers_only_lowercase.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'Immutable object has no mutators', 'idx': 132}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[ 0.0339713  -0.14662093 -0.12406637 -0.01900867  0.31702087  0.13451057
  0.33401039  0.31072393  0.41912996  0.51745479 -0.05705891 -0.20801097
 -0.16728571  0.23005531 -0.22449454  0.42581536  0.29251     0.0045469
  0.09736953  0.1688167   0.1067844   0.42379699  0.01305253  0.31986544
 -0.07297199  0.34931107  0.18346381  0.05674558  0.21669693  0.41676928
 -0.15621876 -0.28582645]
max: 0.5174547858950901 arg: 9
mean: 0.12221432280272634
min: -0.28582645342641405 arg: 31
std: 0.22345032780925508


./data/experiment_q03_clean_answers_only_stopwords.json
[[{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'Immutable object has no mutators', 'idx': 132}]]
silhouette scores
[-0.22942449 -0.34694362  0.18686251 -0.30005069  0.21700452  0.31353823
 -0.35890382 -0.07586015  0.33554675  0.14718701 -0.23123834  0.17435494
  0.20271178 -0.29606598  0.11416375 -0.01779063 -0.13801219  0.01346631
  0.13542404  0.69585931  0.0023662   0.3666419   0.08279687  0.16582038
  0.26420127 -0.30331438  0.22789038  0.37001625  0.69163076 -0.20164241
  0.5443754  -0.110875  ]
max: 0.6958593074486956 arg: 19
mean: 0.0825542767297173
min: -0.3589038188121806 arg: 6
std: 0.2844361141439375


./data/experiment_q03_clean_answers_stopwords_lemma.json
[[{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'Immutable object has no mutators', 'idx': 132}]]
silhouette scores
[-0.47934732  0.08677454  0.06206517 -0.11918303  0.02531805  0.26650228
 -0.28536078 -0.08246776  0.51117967 -0.04059769 -0.13749955  0.20808275
  0.1500181   0.17974213  0.24061026  0.06995448 -0.39379098  0.10890583
  0.1901956   0.92143856  0.28487145 -0.0592062  -0.1764975  -0.17606399
 -0.02609987 -0.21101114  0.20744477  0.21169731  0.57226006 -0.21643411
  0.48247074 -0.15976717]
max: 0.9214385606284625 arg: 19
mean: 0.06925639579521375
min: -0.4793473239337102 arg: 0
std: 0.2888108285787626


./data/experiment_q03_raw.json
[[{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}]]
silhouette scores
[-0.01386103  0.17368635  0.93865379 -0.05282508 -0.1265877   0.48940936
  0.13200741  0.0385392   0.75844811  0.36622026 -0.02609785  0.23122822
 -0.13894491  0.63005769  0.         -0.42522423  0.8934014   0.48017975
  0.04425088  0.75432901 -0.33344937  0.51662847 -0.26928999  0.08507043
  0.14733728  0.10015917 -0.08160203  0.28925582  0.86940124  0.18327449
  0.56473164  0.26334868]
max: 0.938653785396346 arg: 2
mean: 0.23380426353531578
min: -0.4252242336157645 arg: 15
std: 0.36044092717770126


./data/experiment_q04_clean_answers_full.json
[[{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}]]
silhouette scores
[ 0.48339888  0.71061791  0.66583561  0.43215961  0.83759392  0.38893412
  0.29002548 -0.49678122 -0.03026719  0.19439843  0.67613884  0.41921294
  0.17083235 -0.05543791  0.66457196  0.24256214  0.08578048 -0.07929687
  0.81740952  0.33812802 -0.22215232  0.11714829  0.01644756 -0.28539612
  0.21680294  0.55793593  0.14953172  0.32333614  0.62263899 -0.46128072
  0.42531698  0.38653457 -0.25030838]
max: 0.8375939191819554 arg: 4
mean: 0.25310219993099253
min: -0.4967812236772974 arg: 7
std: 0.3508603072688184


./data/experiment_q04_clean_answers_only_lemma.json
[[{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'because it has side effect with print', 'idx': 138}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}]]
silhouette scores
[ 0.57854871 -0.5618052   0.57115203  0.22878273  0.50164828  0.35288458
 -0.13565556  0.21103083 -0.16070917  0.10327743  0.43628448  0.34560608
 -0.07833083 -0.30264035  0.49924735  0.50581297 -0.00177872  0.1520392
  0.58380629 -0.05792813  0.15562519  0.22967063  0.06724102  0.15248413
  0.02386935  0.53832123 -0.06290198 -0.12512943  0.19930304 -0.01050489
  0.05908003  0.28717303  0.23783296]
max: 0.5838062879146733 arg: 18
mean: 0.16737385780197228
min: -0.5618052037634267 arg: 1
std: 0.272865240890617


./data/experiment_q04_clean_answers_only_lowercase.json
[[{'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'It produces a side effect.', 'idx': 158}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'probably create side effect then is not pure', 'idx': 168}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}], [{'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}]]
silhouette scores
[-0.05391616  0.87450343  0.43199055 -0.2366631  -0.42274964  0.49294756
  0.49420724 -0.11175387 -0.07235228  0.51261215  0.88611496  0.15764456
  0.62024885 -0.32371093  0.31034694  0.44942362 -0.09715321  0.2560293
 -0.06167166  0.34161547  0.0149092   0.43704989  0.24621986 -0.07839159
  0.46232114 -0.23331458  0.14628154 -0.1102142  -0.36061536  0.23464253
  0.55898544  0.43825041  0.76413023]
max: 0.8861149599325774 arg: 10
mean: 0.21115055495353596
min: -0.42274963524202097 arg: 4
std: 0.35299748854593044


./data/experiment_q04_clean_answers_only_stopwords.json
[[{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}], [{'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}]]
silhouette scores
[ 0.58566581 -0.74306025  0.70612441 -0.06434643  0.78009561  0.17913836
  0.3309391  -0.24403434 -0.17399226 -0.29593773  0.73441902  0.52744456
  1.         -0.14845878  0.48469166 -0.16799001  0.18146936  0.30841522
  0.          0.27418897  0.10154476 -0.14169443  0.41092552 -0.2152793
  0.3986852  -0.46313287  0.13040109 -0.30272622 -0.320195   -0.32744298
  0.32924972  0.27608042  1.        ]
max: 1.0 arg: 12
mean: 0.1554905516096221
min: -0.7430602478200502 arg: 1
std: 0.42482254745239945


./data/experiment_q04_clean_answers_stopwords_lemma.json
[[{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}]]
silhouette scores
[ 0.48339888  0.71061791  0.66583561  0.43215961  0.83759392  0.38893412
  0.29002548 -0.49678122 -0.03026719  0.19439843  0.67613884  0.41921294
  0.17083235 -0.05543791  0.66457196  0.24256214  0.08578048 -0.07929687
  0.81740952  0.33812802 -0.22215232  0.11714829  0.01644756 -0.28539612
  0.21680294  0.55793593  0.14953172  0.32333614  0.62263899 -0.46128072
  0.42531698  0.38653457 -0.25030838]
max: 0.8375939191819554 arg: 4
mean: 0.25310219993099253
min: -0.4967812236772974 arg: 7
std: 0.3508603072688184


./data/experiment_q04_raw.json
[[{'data': 'it prints on the output', 'idx': 156}, {'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}]]
silhouette scores
[ 0.13301656  0.45322176  0.77133238  0.06982248  0.66409452 -0.05074874
 -0.19845187  0.1587521  -0.27791737  0.0324874   0.60522267  0.44138893
  0.45053822  0.12531059  0.46181369  0.26648345  0.09952524  0.3421575
  0.5161727   0.41844816  0.12889253  0.20124277  0.52133607 -0.03366175
  0.16751391  0.08232106 -0.01914951  0.3558461  -0.03127533  0.18871742
  0.10370123 -0.20910386  0.00779433]
max: 0.771332375656774 arg: 2
mean: 0.21051046447496927
min: -0.27791737327556176 arg: 8
std: 0.2559962502439321


./data/experiment_q05_clean_answers_full.json
[[{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}]]
silhouette scores
[ 0.43163256 -0.31912388  0.51315582  0.30987838  0.14502722  0.4068286
  0.         -0.20631282  0.09716507  0.51716781  0.1642611  -0.06750503
  0.13898196 -0.13798042  0.06359514  0.0055426   0.03370766  0.56073025
 -0.01804178  0.1067357   0.0208113   0.12470292  0.22959267  0.2778662
  0.26072445 -0.09549269  0.07894508  0.54957707  0.28201924  0.23443605
  0.51718757 -0.14402909  0.41584138]
max: 0.5607302465421071 arg: 17
mean: 0.166594790701636
min: -0.319123880675197 arg: 1
std: 0.23131980788104733


./data/experiment_q05_clean_answers_only_lemma.json
[[{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[-0.33874243  0.08899846  0.2669233  -0.20990416  0.01700017  0.31718747
 -0.15608098 -0.11603861  0.17008297  0.16821922  0.13804333 -0.3303426
  0.10346455  0.19195587  0.33802146  0.36473297  0.10969258  0.35764259
 -0.06031957  0.13891122  0.19029583  0.62264707  0.22167859 -0.16936494
  0.03464512  0.11009873 -0.23544079  0.09863788  0.3645187  -0.15118408
  0.13904277  0.03997882  0.39567418]
max: 0.6226470749785418 arg: 21
mean: 0.09759623342509588
min: -0.33874242674533983 arg: 0
std: 0.22149135070447154


./data/experiment_q05_clean_answers_only_lowercase.json
[[{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}, {'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}], [{'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}]]
silhouette scores
[ 1.          0.26265936 -0.11574212 -0.29529833 -0.43876399 -0.11812419
 -0.14850705 -0.03457611  0.45718875 -0.49623693  0.         -0.05340963
 -0.14867043 -0.22576634  0.35057351 -0.01583791  0.48105591 -0.1847695
 -0.34878738  1.          0.01968633 -0.24947815  0.33094205  0.60817901
 -0.08433854 -0.41407026  0.44426631 -0.09946043  0.13055039  0.44097284
 -0.24405129  0.16590983 -0.11220607]
max: 1.0 arg: 0
mean: 0.05648150412463453
min: -0.49623693246233597 arg: 9
std: 0.37232392661375985


./data/experiment_q05_clean_answers_only_stopwords.json
[[{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}]]
silhouette scores
[ 0.40518341 -0.32982335  0.55294451  0.30080771  0.19384818  0.36559965
  0.         -0.19509089  0.10998213  0.54807404  0.15006875 -0.07296698
  0.11315783 -0.08204621  0.00359974 -0.05116532  0.05401987  0.55359313
 -0.00306931  0.28224359  0.01533827  0.1618438   0.21951348  0.28822773
  0.24796829 -0.07094318  0.04212044  0.55249816  0.29432584  0.25253356
  0.51267923 -0.1262069   0.45063789]
max: 0.5535931343523356 arg: 17
mean: 0.1739241541799743
min: -0.32982335476383307 arg: 1
std: 0.23324354446310103


./data/experiment_q05_clean_answers_stopwords_lemma.json
[[{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}]]
silhouette scores
[ 0.43163256 -0.31912388  0.51315582  0.31128772  0.14502722  0.37595877
  0.         -0.20529424  0.09716507  0.51716781  0.1642611  -0.06750503
  0.12542268 -0.13798042  0.06359514 -0.01113508  0.03370766  0.56073025
 -0.01804178  0.1067357   0.0208113   0.12470292  0.22255981  0.2778662
  0.25467566 -0.09549269  0.08285874  0.54957707  0.28068188  0.23443605
  0.51718757 -0.14053341  0.41584138]
max: 0.5607302465421071 arg: 17
mean: 0.16460422848472245
min: -0.319123880675197 arg: 1
std: 0.23047621621771058


./data/experiment_q05_raw.json
[[{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}]]
silhouette scores
[ 0.2940064  -0.35989095  0.63928733  0.3261627   0.20957926  0.47683933
 -0.11797219 -0.0892197   0.00219384  0.52654316  0.13740139  0.01120746
 -0.29708883 -0.23829714  0.23751949 -0.20645759  0.1303539   0.36482397
  0.02532551 -0.17964875  0.16207941  0.43147952  0.42366765 -0.00333816
 -0.05183271 -0.00757358  0.24120224  0.35996815  0.30535134 -0.02264304
  0.02919022  0.13587739  0.03658359]
max: 0.6392873267932366 arg: 2
mean: 0.11917213939293211
min: -0.35989094935857935 arg: 1
std: 0.24468567158156965


./data/experiment_q06_clean_answers_full.json
[[{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}]]
silhouette scores
[ 0.24657212  0.3674009   0.41834246 -0.27324257  0.26032056  0.55436667
  0.25094879  0.46890319  0.02073811 -0.0754062   0.29324185  0.
  0.2015199   0.4026444  -0.01440656  0.67571133  0.45834108 -0.49571665
  0.2994238   0.11375037  0.1281421   0.31865242 -0.16245357  0.20615282
  0.1073831  -0.11146379 -0.14375635 -0.2839329   0.35941758  0.07348779
  0.04199384  0.1678793   0.03638471]
max: 0.6757113316330465 arg: 15
mean: 0.14882850287734237
min: -0.4957166507286557 arg: 17
std: 0.25586573146612296


./data/experiment_q06_clean_answers_only_lemma.json
[[{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.5332243   0.37984255  0.24010337 -0.02639073  0.42655633  0.4644935
  0.3098874  -0.20119775  0.01075612 -0.03125211  0.42472734  0.08781925
  0.27410073  0.55984543  0.39405401  0.39287146  0.35540325 -0.12915827
  0.15534637  0.30227416 -0.06790322 -0.08954592  0.25938662  0.23111992
  0.5122547   0.31578921  0.22594327 -0.16120971  0.46571138 -0.18307453
 -0.15940498  0.04055976  0.08752598]
max: 0.5598454345217949 arg: 13
mean: 0.19395330996895208
min: -0.20119775352283528 arg: 7
std: 0.2324618385012842


./data/experiment_q06_clean_answers_only_lowercase.json
[[{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}], [{'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.         -0.10076305  0.02100302  0.44368356  0.20064828  0.43393004
  0.21237994 -0.44194541  0.2100787   0.23552608 -0.08577584  0.11227395
  0.21721514 -0.23717871  0.19105368 -0.46271943 -0.04506131  0.50915845
 -0.10665849 -0.26446473 -0.21708689  0.18483463  0.         -0.18578523
 -0.38494011  0.1155586   0.2237495  -0.05609937  0.2723321   0.40191087
 -0.18646914  0.32307256  0.3283725 ]
max: 0.5091584538361311 arg: 17
mean: 0.056419209385621484
min: -0.46271942666497873 arg: 15
std: 0.25824646192053435


./data/experiment_q06_clean_answers_only_stopwords.json
[[{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}]]
silhouette scores
[ 0.10547953  0.4043345   0.21118525  0.25329759  0.31983718 -0.21530595
  0.58714282 -0.00896131  0.07934665  0.15065798  0.31650886  0.10922187
  0.13252034  0.33719897  0.42939486 -0.26255581  0.31634908  0.20523711
  0.19583322  0.33108637 -0.05754118  0.17250192 -0.01533441  0.32640042
  0.32345021  0.16828463  0.13274661  0.04049234 -0.15182989  0.11354301
 -0.0058727   0.25147857  0.02079476]
max: 0.5871428242155675 arg: 6
mean: 0.16111889060144913
min: -0.26255581062239985 arg: 15
std: 0.18486088410125873


./data/experiment_q06_clean_answers_stopwords_lemma.json
[[{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}]]
silhouette scores
[ 0.24657212  0.3674009   0.41834246 -0.27324257  0.26032056  0.55436667
  0.25094879  0.46890319  0.02073811 -0.0754062   0.29324185  0.
  0.2015199   0.4026444  -0.01440656  0.67571133  0.45834108 -0.49571665
  0.2994238   0.11375037  0.1281421   0.31865242 -0.16245357  0.20615282
  0.1073831  -0.11146379 -0.14375635 -0.2839329   0.35941758  0.07348779
  0.04199384  0.1678793   0.03638471]
max: 0.6757113316330465 arg: 15
mean: 0.14882850287734237
min: -0.4957166507286557 arg: 17
std: 0.25586573146612296


./data/experiment_q06_raw.json
[[{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.17919947  0.40857833 -0.11918018 -0.0201992   0.1064936   0.36970338
  0.20783452  0.33470157 -0.14208127  0.37281713  0.18108493 -0.08154501
  0.06350442  0.3431378   0.34842933  0.71185632  0.23841656  0.4596985
 -0.26778416  0.43515105  0.41233841  0.38331387 -0.30093758 -0.14119673
  0.38013302 -0.00678155 -0.05110848 -0.29938354  0.49737065  0.06849276
 -0.07659769  0.09708686 -0.04195347]
max: 0.7118563237739016 arg: 15
mean: 0.15304829177199408
min: -0.3009375839666095 arg: 22
std: 0.2555476344925327


./data/experiment_q07_clean_answers_full.json
[[{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}]]
silhouette scores
[ 0.64914367  0.3649728  -0.18839654  0.02898915  0.08952311 -0.09240383
 -0.11634244 -0.24587324 -0.04267458  0.09341193  0.81873958 -0.22254834
  0.01709297  0.68126403  0.00710566 -0.03041486  0.87493795  0.14459949
  0.20339576  0.          0.35506013 -0.04224757  0.25150213 -0.00847859
 -0.21048959  0.15286366  0.62509704 -0.1656285   0.08322352 -0.37629415
  0.34901827 -0.08564204  0.87654747]
max: 0.8765474651972638 arg: 32
mean: 0.14663800059866852
min: -0.3762941498213287 arg: 29
std: 0.3356815414233438


./data/experiment_q07_clean_answers_only_lemma.json
[[{'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}, {'data': 'return another function', 'idx': 304}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': "function 'f' takes no parameters.", 'idx': 299}]]
silhouette scores
[ 0.6156841   0.11985797  0.16296256 -0.12945751  0.78140488 -0.21468289
 -0.14235003 -0.26996743  0.16415273 -0.0627723   0.68876515  0.34813527
 -0.01696689  0.40510169  0.08326138 -0.12537521  0.78067548 -0.27448972
  0.29333    -0.11015023  0.71136841 -0.05886023 -0.20864923  0.14105671
  0.0213627  -0.08094592  0.42904387  0.21546634  0.19053398 -0.24036328
 -0.11544311 -0.01712946  0.84248833]
max: 0.84248833315556 arg: 32
mean: 0.1493044884258991
min: -0.2744897220279259 arg: 17
std: 0.33372955468374305


./data/experiment_q07_clean_answers_only_lowercase.json
[[{'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}, {'data': 'return another function', 'idx': 304}], [{'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}]]
silhouette scores
[ 0.59342117  0.47897759  0.08392482  0.47663552  0.27177652 -0.13171146
  0.30804187 -0.07217293 -0.56626361 -0.25192126  0.55511498  0.06456607
  0.42937948 -0.1785244   0.42848598 -0.34690869  0.34023767 -0.24324682
 -0.12603503  0.73930135  0.20080405  0.04875782  0.38091472  0.12724399
 -0.22958189  0.47857299  0.44599616  0.56179912  0.12125766  0.006467
  0.26162891  0.15168262  0.64617158]
max: 0.73930134961364 arg: 19
mean: 0.1834785919905799
min: -0.5662636140347044 arg: 8
std: 0.3197622511437079


./data/experiment_q07_clean_answers_only_stopwords.json
[[{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}]]
silhouette scores
[ 6.47758245e-01  3.15785711e-01  2.67106321e-01  6.20524389e-02
  8.81249073e-02  0.00000000e+00 -9.08781085e-02 -2.75464633e-01
 -2.75811610e-03  9.18460499e-02  8.18739578e-01 -2.27887396e-01
 -4.49278273e-04  4.85448431e-01  4.69134278e-02  4.21678035e-02
  8.74564502e-01  1.04592089e-01 -9.43450589e-02  0.00000000e+00
  2.91143490e-01 -6.89873690e-02  2.50110196e-01 -2.63583113e-02
 -2.51423001e-01 -2.75348596e-02  4.26809422e-01 -6.30969698e-02
  1.92115907e-01 -2.42707363e-01  2.70402401e-01  1.54673907e-02
  8.76400870e-01]
max: 0.8764008701646713 arg: 32
mean: 0.14532299139173466
min: -0.2754646329254496 arg: 7
std: 0.30573758857077893


./data/experiment_q07_clean_answers_stopwords_lemma.json
[[{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}], [{'data': 'it should be f()(1)', 'idx': 292}]]
silhouette scores
[ 0.64914367  0.3649728  -0.18839654  0.02898915  0.08952311 -0.09240383
 -0.11634244 -0.24587324 -0.02305561  0.09341193  0.81873958 -0.22254834
  0.01874142  0.68002239  0.00266019 -0.01748116  0.87493795  0.14459949
  0.20339576  0.          0.35423181 -0.04224757  0.25150213 -0.02248617
 -0.21048959  0.15286366  0.61728872 -0.1656285   0.08322352 -0.37629415
  0.34901827 -0.08564204  0.87654747]
max: 0.8765474651972638 arg: 32
mean: 0.1468158734819579
min: -0.3762941498213287 arg: 29
std: 0.3349965343831102


./data/experiment_q07_raw.json
[[{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}, {'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}, {'data': 'It returns the wrapped function', 'idx': 301}, {'data': 'return another function', 'idx': 304}]]
silhouette scores
[ 0.63733526  0.27594921  0.1517035  -0.11916486  0.2399348  -0.33501234
 -0.23470309 -0.27721174 -0.35375869  0.06199375  0.69300216  0.36084905
  0.06920572  0.68697263  0.16202878  0.01756987  0.79088949 -0.15053913
  0.01732959 -0.16101106  0.16998072 -0.08575107 -0.00803149  0.17280393
 -0.17841529  0.25608684  0.70660124  0.13695401  0.10905501 -0.23115438
  0.21100398 -0.10122368  0.85349498]
max: 0.8534949828517666 arg: 32
mean: 0.13772023356895327
min: -0.3537586945028467 arg: 8
std: 0.3322416405573529


./data/experiment_q08_clean_answers_full.json
[[{'data': "it's the regular expression", 'idx': 308}, {'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Just because', 'idx': 336}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}]]
silhouette scores
[-0.00744207 -0.31829534 -0.46480471  0.01644656 -0.36654771  0.30661406
 -0.1217939   0.24343286  0.5114275   0.27594651  0.06543864  0.12224141
  0.38654404  0.37198017  0.19501601  0.51665149  0.26631085 -0.10749861
 -0.25238306  0.36157003  0.09796048  0.48170104 -0.13985461 -0.0426299
  0.31812784  0.0942667   0.15495493  0.312693   -0.06590083  0.33650787
  0.19358009 -0.21605055]
max: 0.5166514853094357 arg: 15
mean: 0.1101940866901209
min: -0.4648047082730374 arg: 2
std: 0.2594934341740133


./data/experiment_q08_clean_answers_only_lemma.json
[[{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Just because', 'idx': 336}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}, {'data': 'pass a function and return f+1', 'idx': 338}]]
silhouette scores
[ 0.         -0.2577761   0.08765542 -0.07515175  0.13507259  0.25151714
 -0.1306163   0.23251598  0.49490925  0.21058848 -0.25208669 -0.09306277
  0.18123804  0.1086408   0.19109535  0.23476884  0.50086651  0.1298851
  0.00807315  0.22006288  0.2335076   0.29627638  0.01933868  0.44295624
  0.15619758 -0.13549916  0.11656271  0.28839706  0.         -0.39981095
  0.36105976 -0.06500097]
max: 0.5008665149849094 arg: 16
mean: 0.10913065277157233
min: -0.3998109548392116 arg: 29
std: 0.2119961670125565


./data/experiment_q08_clean_answers_only_lowercase.json
[[{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': "it's the regular expression", 'idx': 308}, {'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Just because', 'idx': 336}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}]]
silhouette scores
[-0.09105272  0.32958905  0.63339843  0.01437099 -0.02793364  0.47449991
 -0.03988468  0.17425081  0.42540832  0.3992324   0.55280222  0.39831598
  0.27898324  0.27835248  0.0449581   0.72050999  0.14056202  0.00832258
  0.0126874   0.43235835  0.03949383  0.24536566  0.42515927  0.5372642
 -0.13212388 -0.07709088  0.16769033 -0.12302679  0.17607434  0.72764592
 -0.35977924  0.00935686]
max: 0.7276459198144476 arg: 29
mean: 0.21236752668884418
min: -0.3597792415607872 arg: 30
std: 0.2686093422567838


./data/experiment_q08_clean_answers_only_stopwords.json
[[{'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}], [{'data': "it's the regular expression", 'idx': 308}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'Just because', 'idx': 336}]]
silhouette scores
[-0.02859476 -0.35220041  0.2783163  -0.2747913   0.08080542  0.11557688
 -0.02577012  0.51913597  0.66512795  0.58584213 -0.06271732 -0.24202892
  0.57740881  0.05383803  0.01383777  0.3910985   0.16798663 -0.48573386
 -0.21727515  0.20090671 -0.1540109   0.64620207 -0.0501222   0.19462111
  0.18214256  0.05965339 -0.21938273  0.5239946  -0.09527878 -0.38955875
  0.00677581  0.        ]
max: 0.6651279481827943 arg: 8
mean: 0.08330641966371843
min: -0.48573385773139804 arg: 17
std: 0.3080738154740244


./data/experiment_q08_clean_answers_stopwords_lemma.json
[[{'data': "it's the regular expression", 'idx': 308}, {'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Just because', 'idx': 336}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}]]
silhouette scores
[-0.00744207 -0.31829534 -0.46480471  0.01644656 -0.36737901  0.30661406
 -0.13544962  0.24343286  0.5114275   0.28778201  0.06543864  0.10843802
  0.38551501  0.37198017  0.19501601  0.51665149  0.26631085 -0.10749861
 -0.25238306  0.36157003  0.09796048  0.50030941 -0.13985461 -0.0426299
  0.31812784  0.0942667   0.15495493  0.323609   -0.06590083  0.33650787
  0.19358009 -0.21605055]
max: 0.5166514853094357 arg: 15
mean: 0.110570350171587
min: -0.4648047082730374 arg: 2
std: 0.26125638034674176


./data/experiment_q08_raw.json
[[{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': "it's the regular expression", 'idx': 308}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'Just because', 'idx': 336}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}], [{'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}]]
silhouette scores
[ 0.         -0.19576137  0.18209375  0.14679812  0.25268713  0.22121665
 -0.13250654  0.48027017  0.58509214 -0.55772105 -0.22531442  0.04739509
  0.22216509  0.11264322  0.14884524  0.57414084  0.42726739  0.1165931
  0.04419404  0.19020772  0.27897521  0.03908745 -0.40030524  0.25028205
 -0.00531528  0.05724325  0.23677792  0.26824347  0.         -0.14955743
 -0.12704624 -0.05551519]
max: 0.5850921364424124 arg: 8
mean: 0.09478675867076856
min: -0.5577210495274517 arg: 9
std: 0.2497626764730626


./data/experiment_q09_clean_answers_full.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'any f call results in a function', 'idx': 370}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}]]
silhouette scores
[ 0.28318622  0.13174772  0.09453947  0.32809401  0.06990549  0.25242358
  0.0200514  -0.11638912  0.25354746  0.13287489 -0.13828332  0.09256509
  0.          0.1012909   0.0088568   0.06682472  0.47455961  0.01485012
  0.03441997  0.35479549  0.41457     0.35479549 -0.11053255 -0.03116133
 -0.49325515  0.04608842 -0.34920132  0.09022474  0.34045314  0.28295645
 -0.10233903  0.26957259  0.42635201]
max: 0.4745596142189769 arg: 16
mean: 0.10904193911009355
min: -0.4932551499478494 arg: 24
std: 0.21522199073079232


./data/experiment_q09_clean_answers_only_lemma.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'It returns the wrapped function.', 'idx': 369}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}]]
silhouette scores
[ 0.25995213  0.1151578  -0.0985314   0.52807055 -0.20860113  0.45234871
 -0.17125815 -0.25492603  0.53339601  0.46877473 -0.30047545 -0.02886558
 -0.05307272 -0.19056363 -0.17284778  0.08817495  0.58520797  0.03554042
 -0.05156469 -0.35414085  0.54034129  0.4458905   0.00856356 -0.13415556
  0.08582243 -0.09177146 -0.07885426  0.          0.20252341  0.
 -0.0021531   0.17080428  0.54629544]
max: 0.5852079682364675 arg: 16
mean: 0.08712370833604072
min: -0.35414084575297944 arg: 19
std: 0.2755067509949565


./data/experiment_q09_clean_answers_only_lowercase.json
[[{'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'Returns a function.', 'idx': 347}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It return a function', 'idx': 356}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'It returns the wrapped function.', 'idx': 369}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}]]
silhouette scores
[-0.48021957 -0.14477584  0.39702548  0.17667734  0.11205851  0.26434424
  0.63420777  0.30975576  0.11584607  0.39837523 -0.09085543  0.30577045
 -0.11671229 -0.0438513   0.48083224  0.60186781  0.0751319   0.49376636
 -0.2260847   0.66123159  0.10886618  0.54566246 -0.23996127  0.40198349
  0.39959731  0.01160612  0.12565392  0.10798491  0.13466232  0.55044132
 -0.29241449 -0.12505257  0.24327484]
max: 0.6612315886456009 arg: 19
mean: 0.17868776269773828
min: -0.4802195727173569 arg: 0
std: 0.29053165940903264


./data/experiment_q09_clean_answers_only_stopwords.json
[[{'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}]]
silhouette scores
[ 0.30758807  0.24490548  0.22652604  0.13361216  0.05400775  0.04945269
  0.07291089 -0.12613617  0.27904432  0.08938347 -0.33546721  0.17756861
 -0.09428482  0.10441056 -0.07374723  0.10256649  0.51152106  0.10718525
 -0.04823419  0.28143305  0.48957758  0.29590546 -0.14338431 -0.02271749
 -0.21042473 -0.35773999 -0.25208689 -0.33823645  0.3804111  -0.21066031
  0.00914741  0.27834819  0.48205402]
max: 0.5115210599573304 arg: 16
mean: 0.07467999578308983
min: -0.3577399870970464 arg: 25
std: 0.23895000320105844


./data/experiment_q09_clean_answers_stopwords_lemma.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}, {'data': 'there is no passing function', 'idx': 372}], [{'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}]]
silhouette scores
[-0.3384748   0.13126215  0.04012092  0.32809401  0.01233937  0.25242358
  0.0737321  -0.19123666  0.25634505  0.07229937 -0.32232885  0.05080587
 -0.16398759  0.11878239 -0.03247384  0.11377098  0.68630595  0.01485012
 -0.03555645  0.2953108   0.7207905   0.2953108  -0.08211324 -0.04549676
 -0.45884742  0.04608842 -0.45313685  0.09022474  0.36252106 -0.2377936
 -0.10233903  0.26438476  0.61291048]
max: 0.7207904976591756 arg: 20
mean: 0.07196631228514523
min: -0.4588474249235745 arg: 24
std: 0.28358311582788603


./data/experiment_q09_raw.json
[[{'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'any f call results in a function', 'idx': 370}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}], [{'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'It returns the wrapped function.', 'idx': 369}, {'data': 'there is no passing function', 'idx': 372}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}]]
silhouette scores
[ 0.3102622   0.01621002  0.03651424  0.10605358  0.22917913  0.17287055
 -0.21855931 -0.13449677  0.07929573  0.04090766 -0.12792968  0.24490415
 -0.11859869  0.01920008 -0.03607475 -0.30536507  0.54990356  0.1541477
  0.0407989   0.72704446  0.54156851  0.70159174 -0.06340749 -0.11049444
  0.18637523 -0.24359185 -0.18849835  0.          0.01553833  0.03684056
  0.14915489 -0.04818659  0.27447372]
max: 0.727044456333916 arg: 19
mean: 0.09204945239449379
min: -0.3053650742204189 arg: 15
std: 0.2498682011205992


./data/experiment_q10_clean_answers_full.json
[[{'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'Just because', 'idx': 404}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}]]
silhouette scores
[-0.12127134 -0.22761992  0.46905038  0.10991235  0.19890731  0.73395169
  0.21402701  0.02086306  0.15418242  0.21027092  0.18849582 -0.50757498
  0.09197832  0.6126971   0.00331622 -0.07353922  0.36496265  0.04450058
 -0.11666485  0.50512871  0.02703059  0.66146809  0.47066208  0.08326429
  0.27669776  0.62012471  0.33729617  0.098967    0.22188831 -0.07142635
 -0.32704638 -0.09921642]
max: 0.7339516905001858 arg: 5
mean: 0.1617276279684648
min: -0.5075749828848235 arg: 11
std: 0.2884780677226647


./data/experiment_q10_clean_answers_only_lemma.json
[[{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'Just because', 'idx': 404}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}]]
silhouette scores
[-0.03388545 -0.0585539   0.57382488  0.0457906  -0.01196804  0.64163669
  0.31492991  0.03658443  0.28438064  0.13925379 -0.06688641  0.2056972
  0.08775748  0.26169904  0.42272438 -0.02619857  0.2272283  -0.24771549
  0.34640467  0.19388421 -0.22550188  0.30138357 -0.34498475  0.15072682
  0.00639289  0.50153264 -0.22089736 -0.36139287  0.18669728  0.01936579
  0.37402868  0.0139668 ]
max: 0.6416366932462033 arg: 5
mean: 0.11680956104224614
min: -0.3613928689121205 arg: 27
std: 0.2484076512361126


./data/experiment_q10_clean_answers_only_lowercase.json
[[{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}], [{'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'Just because', 'idx': 404}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}], [{'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}], [{'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}]]
silhouette scores
[ 0.03162017  0.3038825   0.31506857  0.03924188 -0.05468677  0.29975421
  0.22353252  0.12633816 -0.33225925  0.54710061  0.3664275  -0.07792967
  0.30634793  0.00239116 -0.1135415   0.05256795 -0.08647077  0.23074023
  0.15163978  0.2699851   0.00912868  0.54723488  0.53209519  0.38666419
 -0.23117467  0.38401526 -0.14845436 -0.11885817  0.29456482  0.
 -0.18308668  0.13666563]
max: 0.5472348830435868 arg: 21
mean: 0.13157953317936946
min: -0.3322592512364969 arg: 8
std: 0.23206278285383117


./data/experiment_q10_clean_answers_only_stopwords.json
[[{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'Just because', 'idx': 404}], [{'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}]]
silhouette scores
[ 0.16500521 -0.26854122  0.54075321  0.14978827  0.11829695  0.799712
  0.23040082 -0.29872944  0.08293135  0.21197844  0.43476152 -0.42025198
 -0.04987738  0.57781502  0.13599712 -0.1716527   0.33483235  0.1517985
  0.37501144  0.48321129  0.10031355  0.61746347  0.46184237  0.10089815
  0.31259965  0.68440932  0.21978203  0.19178851  0.2786525  -0.06959583
 -0.35842832 -0.06880865]
max: 0.7997120036500932 arg: 5
mean: 0.18919242250599688
min: -0.4202519820318103 arg: 11
std: 0.2988211577066163


./data/experiment_q10_clean_answers_stopwords_lemma.json
[[{'data': '1 is not passed to g', 'idx': 376}, {'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': 'Just because', 'idx': 404}], [{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}], [{'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}]]
silhouette scores
[ 0.06182916 -0.15131764  0.32299372 -0.36964933 -0.26229704  0.11526785
  0.19302249  0.32620928  0.59886129  0.21027092  0.30962308 -0.46012395
  0.17067807  0.6126971   0.0400159  -0.09900248  0.40060242 -0.0264713
  0.08837293  0.50512871  0.02703059  0.66146809 -0.08167957  0.12479235
  0.27669776  0.11363772  0.30900211 -0.08641965  0.21773331 -0.03221308
  0.39518328 -0.09921642]
max: 0.661468087488993 arg: 21
mean: 0.13789773933018595
min: -0.46012395040297316 arg: 11
std: 0.2682609378936243


./data/experiment_q10_raw.json
[[{'data': 'because in f(1) the first argument is ignored, yielding a function', 'idx': 375}, {'data': 'The first x contains the value 2, and the second x contains a function (if f(1) does not throw an exception because f does not accept arguments)', 'idx': 390}, {'data': "No. In the second case we expect an error, because as in Option 1 we call f, passing a value to the function, but function f does not require a parameter. I don't remember exactly how JavaScript manage this situation, if it throws an exception or it don't care about the passed argument (I expect it throws an error), but in the second case it returns a function not a value (while x = f()(1) returns a value... 2).", 'idx': 402}, {'data': 'The first one returns an integer, the second time return the wrapped function (argument 1 is not read)', 'idx': 403}], [{'data': 'No, the result of the former code  2 but in the last code, `g` is a function but then it invokes the `f`, no the `g`.', 'idx': 386}, {'data': 'In the first case the `x = 2`. In the second case, we try to apply one argument to a function with no arguments.', 'idx': 395}, {'data': "No. The first x will be 2 (because of currying). The second f will just be a function (as said before), no matter what we pass to f, provided JS doesn't crash (as it actually should), when passing an argument to a function that accepts not argument (i.e. f).", 'idx': 398}], [{'data': 'Just because', 'idx': 404}], [{'data': '1 is not passed to g', 'idx': 376}, {'data': 'If the question was expected to be: let g = f(); let x = g(1) then yes they would. In this case after declaring g, x is assigned to f(1) with would yield an error in the same manner as in question one.', 'idx': 378}, {'data': "g=function(x){return x+1;}; and x=function(x){return x+1;}; since f doesn't take parameters. It would be correct if x=g(1) instead of x=f(1).", 'idx': 392}, {'data': "not sure if it's type correctly, if we had x = g(1) then yes, the result would be the same, this way, though, its not.", 'idx': 397}, {'data': "Its correct if change 'let x = f(1)' to 'let x = g(1)'", 'idx': 405}], [{'data': 'Since, x will have just a reference to function f.', 'idx': 381}, {'data': 'x will contain a reference to the inner anonymous function', 'idx': 384}, {'data': 'In first case x is equal to the value 2 but in the second case x contains a reference to a function', 'idx': 407}], [{'data': 'no, x contains 2, while the second x contains an anonymous function', 'idx': 388}, {'data': "x in the second case it's an anonymous function", 'idx': 394}, {'data': 'both g and (second) x hold the anonymous function. (first) x holds the 2.', 'idx': 396}, {'data': 'Well, assuming there are no typos in the text, then the first x would contain 2, while the second one would contain the inner function.', 'idx': 399}], [{'data': "No that is not correct. This code is not valid because f(1) shouldn't take parameters. Instead it would be the same value (i.e. the value would be 2) if the second case was let g = f(); let x = g(1)", 'idx': 379}, {'data': 'After let x = f()(1), x contains 2. After let g = f(), g contains the function that returns the successor. After let x = f(1), x contains the same value of g, i.e. a function (the extra parameter passed to f is ignored).', 'idx': 382}, {'data': 'No, in the first case x contains the value 2, while in the second g is not used and f(1) returns a function which is stored in the variable x.', 'idx': 383}, {'data': 'after x = f()(1) the value would be 2. After the other calls the value of x would be a function', 'idx': 391}, {'data': 'No, the first x stores the value 2, while the second x stores the internal lambda of f. ', 'idx': 393}], [{'data': 'No, it would be the same if the last statement was x = g(1), in the code above the second x contains a Function taking an argument and increasing it by one; the first x instead contains 2.', 'idx': 387}, {'data': "x will contain 2, as f()(1) returns 2. g will contain a function that increments the argument by one, and the second x will either make the code crash (as f doesn't take arguments) or assign the same function. To have the two x equals, the last piece of code should be 'let x = g(1)'.", 'idx': 389}, {'data': "x will be assigned to 2 first, and then it will be assigned to 'function(x)'. We must've let x = g(1) if we wanted the same value.", 'idx': 401}], [{'data': 'In order for it to contain the same value, we need to change the second part to: let g = f(); let x = g(1);', 'idx': 377}, {'data': 'After let g = f() it will contain the same value but after let x = f(1) the value will change', 'idx': 380}, {'data': 'The variable contains the same value as after let g = f(); let x = g(1); g(1) will return 2, not f(1)', 'idx': 385}, {'data': 'It would contain the same value if: let g = f(); let x = g(1); ', 'idx': 400}]]
silhouette scores
[ 0.26563126 -0.00289324  0.62020101 -0.26104152 -0.10480897  0.8589661
  0.36216387  0.02148795  0.14901115  0.13284693  0.14318424 -0.07724872
  0.46187972  0.22761795  0.56366186 -0.18684305  0.24418281 -0.17378157
  0.29876189  0.1852589  -0.1504573   0.16163476  0.11399271 -0.35613322
  0.04138643  0.55467562  0.24164623  0.1576246   0.22451161  0.
 -0.30675143  0.08162093]
max: 0.8589660978538757 arg: 5
mean: 0.14037467207810758
min: -0.35613321594372216 arg: 23
std: 0.2740377348064247


./data/experiment_q11_clean_answers_full.json
[[{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'r yields 4', 'idx': 443}, {'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}]]
silhouette scores
[ 0.18281536  0.03218966  0.01989487  0.23205092  0.36001026 -0.07327509
  0.07937347  0.03715288  0.26712889 -0.292909   -0.34219262  0.12470803
  0.48802733  0.32758894  0.52862712  0.30871273 -0.33789556  0.45044355
  0.29814272  0.37447942  0.06732035 -0.38567186  0.21181701  0.28362204
  0.15150466  0.12202202  0.35316576  0.12329609 -0.21911772  0.24101852
  0.38769203  0.         -0.28178908]
max: 0.5286271227762162 arg: 14
mean: 0.12484708251007452
min: -0.3856718566731726 arg: 21
std: 0.2501753267177797


./data/experiment_q11_clean_answers_only_lemma.json
[[{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': 'r yields 4', 'idx': 443}], [{'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}]]
silhouette scores
[ 0.          0.32325366  0.08747524  0.01808271  0.16382391 -0.12398549
 -0.09669878  0.77432853 -0.13954268  0.33705229  0.32771266  0.14501175
  0.75068114 -0.04826987  0.6844681   0.06955414  0.19982664  0.39472342
  0.26487995  0.33849384  0.04076808  0.38302938  0.1697119  -0.27431129
 -0.41054441  0.23431418 -0.19820347  0.10213705 -0.06459686  0.35001838
  0.51739999  0.          0.41949227]
max: 0.7743285308089871 arg: 7
mean: 0.17394201150280858
min: -0.41054440661744107 arg: 24
std: 0.2775591799258176


./data/experiment_q11_clean_answers_only_lowercase.json
[[{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'r yields 4', 'idx': 443}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}], [{'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': 'r can be reassign', 'idx': 474}]]
silhouette scores
[ 0.10431566  0.31538914  0.50552125 -0.04816831 -0.14708998  0.08640302
  0.31786796  0.37128111  0.56170407  0.19955072  0.26744681 -0.27386812
  0.62497672 -0.06511068  0.44598089  0.66637388 -0.19576243  0.38583055
  0.30871159  0.10777859  0.08859459  0.39779817 -0.05787606  0.80454422
  0.42310915  0.5779205   0.28773692  0.12536368  0.34730464 -0.06861782
  0.32377309  0.          0.12013806]
max: 0.8045442165388609 arg: 23
mean: 0.23966429020195718
min: -0.2738681182897828 arg: 11
std: 0.26096175430071855


./data/experiment_q11_clean_answers_only_stopwords.json
[[{'data': 'r yields 4', 'idx': 443}, {'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}]]
silhouette scores
[ 0.26326117 -0.033198    0.04113216  0.38326617  0.52909975  0.18697014
  0.42769439 -0.12376209  0.268962   -0.19592762  0.16493394  0.22115368
  0.41141437  0.26973912  0.51647359  0.40315096  0.20150212  0.43210412
  0.32057337  0.34976324  0.17463686  0.0006675   0.          0.11433156
  0.26206994  0.23963176  0.2786487   0.34854446  0.24603595  0.2345461
  0.36987041  0.         -0.1254367 ]
max: 0.5290997542080758 arg: 4
mean: 0.21763191353037153
min: -0.19592761665272848 arg: 9
std: 0.18394491382398084


./data/experiment_q11_clean_answers_stopwords_lemma.json
[[{'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}], [{'data': 'r yields 4', 'idx': 443}, {'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "yes, it's correct, and the output is 4.", 'idx': 465}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': 'r can be reassign', 'idx': 474}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'Instgant call of inline-defined function', 'idx': 472}]]
silhouette scores
[ 0.18246836  0.0195367   0.02254608  0.23205092  0.36001026 -0.09233661
  0.09509886  0.0416268   0.19392528 -0.28403912 -0.35218978  0.12470803
  0.48802733  0.32758894  0.53173814  0.31266074 -0.33865067  0.45044355
  0.29814272  0.37447942  0.0717517  -0.39148149  0.21181701  0.24776863
  0.16529817  0.11402815  0.33853524  0.10743823 -0.21911772  0.22932967
  0.38769203  0.         -0.28241967]
max: 0.5317381435635706 arg: 14
mean: 0.12025684542549189
min: -0.3914814875418554 arg: 21
std: 0.2493678880678846


./data/experiment_q11_raw.json
[[{'data': "first lambda is defined and then it's invoked with param 3", 'idx': 462}, {'data': 'Yes, it is a lambda which the argument 3 is applied and return 4', 'idx': 471}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 473}], [{'data': 'It invokes lambda function and assgin  the return value to a variable. It is called IIFE, Immediately Invoked Function Expression.', 'idx': 454}, {'data': 'You can use a lambda directly and without naming it.', 'idx': 460}, {'data': 'You can directly call a lambda with an argument.', 'idx': 461}], [{'data': 'This is a direct invocation of an anonymous function.', 'idx': 445}, {'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the same line.', 'idx': 447}, {'data': 'In this case we already evaluate the anonymous function, by passing at the end x = 3 and assign the result to r.', 'idx': 449}, {'data': 'In the right  end of the assignment expression, we are creating a new anonymous function on which we apply the value 3.', 'idx': 463}], [{'data': 'This is a valid way to define and then invoke an anonymous function in JS', 'idx': 451}, {'data': 'Instgant call of inline-defined function', 'idx': 472}], [{'data': "it's an correct expression of immediately invoked function expression", 'idx': 444}, {'data': 'it is wrong, the function f would have to be called from r(is not a lambda)', 'idx': 446}, {'data': 'yes, it is correct, we create a function that we assign to the variable r, and then we pass them three as a parameter.', 'idx': 456}, {'data': 'This is a correct way to declare a function without a name an call it immediately. That function will not be reusable afterwards', 'idx': 458}, {'data': 'r can be reassign', 'idx': 474}], [{'data': 'This is correct as it uses an anonymous function where x is set to 3. r will be set to 4.', 'idx': 448}, {'data': 'The anonymous function is immediately invoked with the argument 3. At the end of the assignment, r will contain the value 4.', 'idx': 450}, {'data': 'We pass argument 3 to the anonymous function. if we print r we will get 4. ', 'idx': 464}, {'data': "We are just calling the anonymous functions inside the () immediately with 3, which returns in storing 4 in r. I assume that by 'correct', you mean that this is valid JS code.", 'idx': 466}], [{'data': 'it results in invoking an anonymous function with the parameter 3, resulting in 4.', 'idx': 452}, {'data': 'It use an anonymous function and it immediately invoke it with 3. r now is 4.', 'idx': 453}, {'data': 'it is an immediately invoked function expression. (function ...)(3) would be immediately called and return 4', 'idx': 459}, {'data': "You create an anonymous function and inmediatly afet you call it with '(3)', so in r is just saved the output of the function, in this case 4.", 'idx': 468}], [{'data': "It's an IIFE anonymous function and will assign r to 4.", 'idx': 469}, {'data': 'I think it is licit in JavaScript to define an anonymous function, wrap it inside paranthesis and call it immediately. In this case, at the end of the statement r is queal to 4.', 'idx': 470}, {'data': 'Yes, r will contains the result of function call with the parameter 3. I will expect to find the value 4 in variable r', 'idx': 475}], [{'data': "yes, it's correct, and the output is 4.", 'idx': 465}], [{'data': 'r yields 4', 'idx': 443}, {'data': "Yes, it's a lambda increasing the argument by one and being directly called, the value of r is 4.", 'idx': 455}, {'data': 'Yes. In this case, we are calling a lambda that increments its argument by one immediately. r will contain the number 4.', 'idx': 457}, {'data': "If correct means that it is a lambda that is parsed and executed correctly then yes, it is correct. The anonymous function is immediately invoked, thus 'r' will contain the value 4", 'idx': 467}]]
silhouette scores
[-0.22756751  0.05775903  0.09240719  0.17480156  0.17183325  0.19146189
 -0.15275771  0.24231016 -0.15321454  0.51001011  0.24727128  0.15297144
  0.28587692 -0.19833041  0.31128166 -0.08404023  0.25579335  0.41291586
  0.33847738  0.35993496  0.07449285  0.34042723  0.          0.16953914
 -0.26839469  0.19630005  0.11146547  0.1865484   0.34692191  0.3604458
  0.54099864 -0.07400999 -0.25296778]
max: 0.5409986424173145 arg: 30
mean: 0.1430594753740858
min: -0.26839469162488705 arg: 24
std: 0.2174698831426893


./data/experiment_q12_clean_answers_full.json
[[{'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'Same as previous', 'idx': 506}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}]]
silhouette scores
[ 0.         -0.15158111  0.26064796  0.39429735  0.39730563 -0.08831463
  0.0392445   0.21854275  0.38170152  0.30348778 -0.17007403  0.29472367
 -0.5600255   0.27886745  0.3916574   1.          1.          0.22634501
 -0.15738746 -0.1975687   0.41304756 -0.29692785 -0.08667288  0.
  0.21169231 -0.01200551  0.42608484 -0.1568086   0.09842382 -0.11462385
  0.63540724 -0.04898302  0.13943475]
max: 1.0 arg: 15
mean: 0.15363449740861523
min: -0.5600255039072451 arg: 12
std: 0.33310414224392193


./data/experiment_q12_clean_answers_only_lemma.json
[[{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'Same as previous', 'idx': 506}, {'data': 'do not recall nothing', 'idx': 508}]]
silhouette scores
[ 0.          0.19177119  0.07465054 -0.06439613  0.3501443   0.28300038
 -0.17628748  0.18295146  0.24221523 -0.19720073  0.21403446  0.16696787
  0.37360407  0.13986378  0.0614832   0.23939051 -0.01833795  0.15030661
  0.03013787 -0.0106432   0.23874067  0.02298222 -0.13388805  0.10156446
  0.3820602   0.34723918  0.47315383  0.08068975  0.16848391 -0.15333375
  0.47117434 -0.00332436  0.32852575]
max: 0.47315382811156437 arg: 26
mean: 0.13811285292841885
min: -0.1972007268725843 arg: 9
std: 0.17958031827582074


./data/experiment_q12_clean_answers_only_lowercase.json
[[{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}, {'data': 'Same as previous', 'idx': 506}], [{'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}], [{'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}], [{'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}]]
silhouette scores
[ 0.16554695  0.41946164 -0.04206366 -0.07870042  0.5068185   0.83634296
 -0.65605457  0.81885017  0.09818752 -0.17349658  0.16130888  0.10499491
  0.          0.15542835  0.0660549   0.23112131  0.14358195 -0.27894926
  0.40640526 -0.11717471  0.17359381 -0.168361   -0.22000566  0.4514272
  0.21313616  0.01788205 -0.03625748 -0.17357051  0.11013663 -0.13749267
  0.0358346   0.08720636  0.02808145]
max: 0.8363429603113653 arg: 5
mean: 0.0954325769619563
min: -0.6560545711651347 arg: 6
std: 0.29298096012661057


./data/experiment_q12_clean_answers_only_stopwords.json
[[{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as previous', 'idx': 506}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'r yields 4', 'idx': 477}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}]]
silhouette scores
[-0.00648964 -0.08312557 -0.27535847  0.26642814  0.49328849  0.2570393
 -0.2072795  -0.36453517  0.2161349   0.19898875  0.21300829  0.27126847
  0.40657466  0.16183378  0.30568172  0.38613906  0.17849205 -0.00351686
 -0.09030906  0.16621625  0.31060051  0.3821526   0.20280099 -0.02717654
  0.30084669  0.          0.27590731 -0.27908269  0.1462415  -0.11070156
  0.67389509 -0.04561202  0.29083242]
max: 0.6738950929963207 arg: 30
mean: 0.13973284545261835
min: -0.364535171887366 arg: 7
std: 0.23387264490538665


./data/experiment_q12_clean_answers_stopwords_lemma.json
[[{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}], [{'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'Same as previous', 'idx': 506}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}], [{'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'r yields 4', 'idx': 477}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}]]
silhouette scores
[ 0.         -0.15408466  0.28717082  0.39429735  0.39730563 -0.08831463
  0.0392445   0.21854275  0.35739008  0.30348778 -0.17007403  0.29168287
 -0.5600255   0.27406068  0.44341346  0.48252834  0.24352668  0.21650864
 -0.20153161  0.22477465  0.41304756  0.38835161 -0.08102147  0.02211877
  0.20646405 -0.01200551  0.41289635  0.0111046   0.22742757 -0.08841929
  0.63540724 -0.04898302  0.1540056 ]
max: 0.6354072381846698 arg: 30
mean: 0.15879690411916483
min: -0.5600255039072451 arg: 12
std: 0.2477223552512788


./data/experiment_q12_raw.json
[[{'data': 'r yields 4', 'idx': 477}, {'data': 'This is correct as it uses a lambda expression where x is set to 3 and r will be set to 4.', 'idx': 482}, {'data': 'The arrow function is immediately invoked with the argument 3. The body of the arrow function is an expression, which is allowed in JavaScript. At the end of the assignment, r will contain the value 4.', 'idx': 484}, {'data': "Yes, again it's a call of a lambda increasing the argument by one. Being called on 3 the value of r is 4. Just the notation for the lambda is changed.", 'idx': 489}], [{'data': 'r will be 4, the lambda is created and called ', 'idx': 480}, {'data': 'Like before, it use an anonymous function, in this case a lambda, and immediately invoke it with 3. r now is 4.', 'idx': 487}, {'data': 'Yes. In this case, we are immediately calling (just after its definition) a lambda that increments its argument by one. r will contain the number 4.', 'idx': 491}, {'data': 'The same case as in the option 1, but this time with a lambda. Will be saved the value 4 in r;', 'idx': 502}], [{'data': 'Same as Option 1, except now we use lambdas.', 'idx': 479}, {'data': 'Same as before, but just another syntax to write lambdas in JS, so this code should also be valid JS code.', 'idx': 500}, {'data': 'Same as previous', 'idx': 506}, {'data': 'do not recall nothing', 'idx': 508}], [{'data': 'the expression is wrong since let is a javascript keyword, and this lambda expression is in scala', 'idx': 478}, {'data': 'Is the correct  way to declare a lambda expression and use it immediately', 'idx': 492}, {'data': 'the immediately called function is written as a lambda and this is a valid and correct way to write it. The function will be invoked immediately and return 4', 'idx': 493}, {'data': 'Similarly to the previous Option 1, I think it is licit in JavaScript to define a lambda function, wrap it inside paranthesis and call it immediately (this is the definition of lambda function, I suppose). In this case, at the end of the statement r is queal to 4.', 'idx': 504}], [{'data': 'You can write a lambda with arrow syntax and then directly call it.', 'idx': 495}, {'data': "it's a lambda definition and then invoked", 'idx': 496}, {'data': 'when writing lambdas on a single line and with a single argument parenthesis and `return` can be left out. ', 'idx': 498}], [{'data': 'This is a valid way to define and then invoke an arrow function in JS', 'idx': 485}, {'data': 'yes, it does the same operation as above, but with an arrow function', 'idx': 490}, {'data': 'I think the internal part is the correct JavaScript syntax for arrow functions. And the rest of the assignment and passing the parameter are also correct.', 'idx': 494}, {'data': "Also in this case it's correct, you can use the arrow function and produce the same result, which is 4.", 'idx': 499}], [{'data': 'It omits the return keyword and uses the arrow operator. Here the function is (x=>x+1) and inputs the 3 so that the finally r is 4.', 'idx': 488}, {'data': "Same as before, the function is correct, as the arrow function is immediately invoked and 'r' will contain the value 4.", 'idx': 501}, {'data': "It's an IIFE arrow function and will assign r to 4. ", 'idx': 503}, {'data': "Yes it's correct. Variable r will contains the value 4. This time the function is defined with arrow expression but the meaning is the same as the previous option.", 'idx': 509}], [{'data': 'In this case we already evaluate the lambda function, by passing at the end x = 3 and assign the result to r.', 'idx': 483}, {'data': 'It is correct, 3 is applied to anonymous function and saved to r', 'idx': 505}], [{'data': 'This is a basic lambda function that is additionally called with the parameter 3 in the same line.', 'idx': 481}, {'data': 'it uses the arrow function which is equivalent to the standard function declaration to define a lambda which is then invoked with parameter 3, result again in 4', 'idx': 486}, {'data': 'in the right hand of the assignment we define a new function summing 1 to its argument. We subsequently apply 3 to this function.', 'idx': 497}, {'data': 'it applys a lambda function on parameter 3. ', 'idx': 507}]]
silhouette scores
[ 0.01432842  0.21011599 -0.29485647  0.30485252  0.36278184 -0.13916847
 -0.05854132 -0.25750852  0.26721312  0.02166254 -0.07217508  0.18162532
  0.15199508  0.12376409  0.08887869  0.1920048   0.09851763  0.13371979
 -0.02761358 -0.03704019  0.21296375  0.0681067  -0.17203771 -0.29263969
  0.33464246  0.18901971  0.44987198  0.05268069  0.16637985  0.05844402
  0.44756168 -0.0575943   0.35827089]
max: 0.4498719813994372 arg: 26
mean: 0.09334018866451967
min: -0.29485646715338754 arg: 2
std: 0.1955255602069756


./data/experiment_q13_clean_answers_full.json
[[{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'the variable r will store the result of the function f', 'idx': 539}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}]]
silhouette scores
[ 5.67579651e-01  4.86810766e-01 -4.05907213e-01  1.36804002e-01
  7.70253596e-01  5.02564858e-01  5.77510483e-02  5.73032137e-01
  1.43901523e-01  0.00000000e+00  6.10256692e-01  7.08197505e-01
  5.59880649e-01  7.78034231e-01  4.91764034e-04  1.23788987e-01
  6.00404327e-02  3.79816275e-01  1.50083762e-01  4.60678096e-01
  7.27824137e-01 -4.77371213e-01  7.95882485e-01  2.26094136e-01
  4.15088998e-01 -1.18598467e-01 -1.52941870e-01 -2.19100781e-01
 -1.77370355e-01  3.43308630e-02  2.15638646e-02  3.42645924e-01]
max: 0.7958824849770727 arg: 22
mean: 0.2525658276881728
min: -0.4773712126601691 arg: 21
std: 0.35092480615273935


./data/experiment_q13_clean_answers_only_lemma.json
[[{'data': 'it returns 4', 'idx': 514}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}]]
silhouette scores
[ 0.49116084 -0.03092392 -0.07334815  0.18982676  0.13711739 -0.10913644
  0.15015489  0.55073069 -0.13817981 -0.37024486  0.32485649  0.09295939
  0.31984746  0.34341229  0.0521037  -0.17329144  0.          0.3771616
  0.13392703  0.38092862  0.16499601  0.39637278 -0.00579856 -0.25887348
  0.12980791 -0.4407933  -0.37008015  0.60810466  0.34154467  0.10188157
  0.31187619  0.50039417]
max: 0.6081046592903726 arg: 27
mean: 0.12901546852524037
min: -0.44079329588779104 arg: 25
std: 0.2727252995631811


./data/experiment_q13_clean_answers_only_lowercase.json
[[{'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'the variable r will store the result of the function f', 'idx': 539}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}]]
silhouette scores
[ 0.28469473 -0.03589391 -0.22907768 -0.10288309 -0.515272   -0.66090267
  0.58090147 -0.06162555 -0.2692617  -0.22246841  0.18449463  0.20765743
 -0.16251703  0.16325076  0.42330128  0.21406897  0.41362382 -0.3291039
  0.17190507  0.32925909 -0.23435835  0.03038836  0.43458665 -0.5311723
 -0.0187331   0.14538502  0.01279535 -0.30028632  0.25525064  0.1976756
 -0.17143896  0.52437688]
max: 0.5809014677601628 arg: 6
mean: 0.022769400343644483
min: -0.6609026679722232 arg: 5
std: 0.3119598643520966


./data/experiment_q13_clean_answers_only_stopwords.json
[[{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'the variable r will store the result of the function f', 'idx': 539}]]
silhouette scores
[ 0.17227446  0.13733206 -0.16636561  0.11366315 -0.7702536  -0.12132118
 -0.27109126  0.57577019  0.16309413  0.          0.61208122  0.65791124
  0.55465498  0.         -0.00789167  0.02305487  0.26633596  0.4063137
  0.13088175  0.40208923  0.6144017  -0.47156593  0.18858781  0.13094069
  0.36702533 -0.52425376 -0.16170081 -0.20214196 -0.00469618  0.02503531
  0.0492872   0.35711634]
max: 0.6579112431049154 arg: 11
mean: 0.10145529239620296
min: -0.7702535959061648 arg: 4
std: 0.3349284276824592


./data/experiment_q13_clean_answers_stopwords_lemma.json
[[{'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}], [{'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}, {'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'the variable r will store the result of the function f', 'idx': 539}], [{'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'it returns 4', 'idx': 514}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}]]
silhouette scores
[ 0.56757965  0.48681077 -0.40858642  0.136804    0.7702536   0.50256486
  0.05775105  0.57303214  0.16309413  0.          0.61025669  0.70819751
  0.55988065  0.77803423 -0.01443719  0.12378899  0.06004043  0.38478964
  0.1521374   0.4606781   0.72782414 -0.47737121  0.79588248  0.22609414
  0.415089   -0.11859847 -0.15294187 -0.21910078 -0.17737035  0.02503531
  0.02156386  0.34264592]
max: 0.7958824849770727 arg: 22
mean: 0.25254444946024557
min: -0.4773712126601691 arg: 21
std: 0.35148090651147684


./data/experiment_q13_raw.json
[[{'data': 'This is an invocation of a function stored in a variable f. To invoke this function, we need to use the variable name rather than the function name.', 'idx': 513}, {'data': 'This is a valid way to define and then invoke an anonymous function in JS. (that is still an anonymous function, even if assigned to a variable)', 'idx': 519}, {'data': 'It is possible to store a function in a variable and use it after', 'idx': 526}, {'data': 'You can name the lambda function and invoke it later.', 'idx': 528}, {'data': 'Definition of function; call of function', 'idx': 540}], [{'data': "Unless it's not possible to insert the keyword 'function' to declare a lambda, the above code is correct.", 'idx': 525}, {'data': 'You can store a lambda in a variable and then call it using the variable.', 'idx': 529}, {'data': 'It is correct because you are saving a function in to f, and them you are calling it.', 'idx': 536}], [{'data': 'Yes, f is a lambda taking one argument and increasing it by one. then r = f(3) calls the lambda on 3 and gets back 4.', 'idx': 523}, {'data': 'we are saving lambda in variable f and then we are invoking lambda using reference f and passing argument 3. variable r will have value 4. ', 'idx': 532}, {'data': 'yes, you can define f as a function and then assign it to variable r by passing 3 as argument, r is going to be 4 as a result.', 'idx': 533}], [{'data': 'The anonymous function is stored in variable f. In the second line, it is called passing 3 as an argument. At the end of the assignment, r will contain the value 4.', 'idx': 518}, {'data': 'In this case it first create a named function f, then it is invoked with 3. r now is 4.', 'idx': 521}, {'data': 'Yes, here the function is stored in a variable named `f`. And then invokes f with input value 3, so that r is 4.', 'idx': 522}], [{'data': 'it returns 4', 'idx': 514}, {'data': "it is equal to defining a named 'function f(x) { ... }' and invoking it afterwards, resulting in 4.", 'idx': 520}, {'data': "f points to an anonymous function 'function(x)' and will assign r to 4.", 'idx': 537}, {'data': 'We store an anonymous function inside a variable (f). In this case, calling f and passing a value to it, we call the anonymous function stored in f (we treat the anonymous function as a value) and we expect that at the end of the statements, r will be equal to 4.', 'idx': 538}], [{'data': 'r yields 4', 'idx': 511}, {'data': 'Yes the code is correct and r will store 4', 'idx': 535}], [{'data': 'This is a basic anonymous function that is additionally called with the parameter 3 in the next statement.', 'idx': 515}, {'data': 'The anonymous function was stored in a variable and then was invoked using f(3).', 'idx': 516}, {'data': 'Since we assign to f the anonymous function and then call it with the parameter the anonymous function has to to take.', 'idx': 517}, {'data': "yes, that's correct,we create a function f and then call it passing it three as a parameter", 'idx': 524}, {'data': 'In the first statement we bind an anonymous function to a name `f`. In the second statement we use the function by applying it to the argument 3.', 'idx': 531}], [{'data': 'f can be assigned to an anonymous function and this would not throw any error.', 'idx': 527}, {'data': "We don't have anonymous functions anymore, in the sense that f now points to what was an anonymous function in the previous options. So, we can call f with different values below. Anyway, this specific code still returns 4.", 'idx': 534}], [{'data': 'first line is the correct expression in javascript, and second line pass the vale to the function then store it in r', 'idx': 512}, {'data': 'f is the definition and then r is the invocation', 'idx': 530}, {'data': 'the variable r will store the result of the function f', 'idx': 539}, {'data': 'f refers to a function. r is the output when the function applys on parameter 3.', 'idx': 541}, {'data': 'f contains the lambda function and r the result of the call of this lambda with the x variable set to 3', 'idx': 543}]]
silhouette scores
[ 0.36362871 -0.21753299  0.30846255 -0.08960942 -0.20860813 -0.25376368
  0.0252936   0.06054442  0.20378392  0.02949376  0.23288311  0.63500746
  0.4619809   0.35301675  0.24584694 -0.10047517  0.35930967 -0.09232307
 -0.27364219  0.07970988  0.25474735  0.36914153  0.13063414  0.01011598
  0.43787005 -0.05562293 -0.03124868 -0.41033507  0.39066643  0.20467167
  0.03874959 -0.05418216]
max: 0.6350074617166808 arg: 11
mean: 0.10650671584151349
min: -0.410335074497509 arg: 27
std: 0.2462664819099574


./data/experiment_q14_clean_answers_full.json
[[{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}]]
silhouette scores
[ 0.62202921 -0.15806444 -0.07469108  0.63126188  0.04531013  0.27923408
 -0.27781878 -0.13627167  0.68473028 -0.08367455  0.64225713 -0.20961397
  0.54489073  0.63903528 -0.12093223  0.41796525  0.24412195  0.31695046
  0.2454948   0.16393578 -0.41758315 -0.10509541 -0.12727322 -0.14933379
 -0.01275572  0.45598832 -0.15639336 -0.03928569  0.7300149   0.35589047
 -0.08134135 -0.24359099  0.48453155]
max: 0.7300148975414164 arg: 28
mean: 0.15484614550804288
min: -0.41758315271729046 arg: 20
std: 0.3345232392036016


./data/experiment_q14_clean_answers_only_lemma.json
[[{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}]]
silhouette scores
[ 0.15326237 -0.23490146 -0.08876152  0.386776   -0.38279157  0.31021565
  0.07267422 -0.10742038 -0.10564477  0.31269292  0.04519108 -0.2083285
 -0.05867477  0.14552521  0.36763399  0.08992714  0.13218691  0.19239706
 -0.0208679   0.14794049 -0.16904877 -0.16874552  0.04835963 -0.14339008
  0.01797402 -0.27427949  0.11015869  0.04057564 -0.06900014 -0.16735507
 -0.17635516 -0.23520131  0.47142844]
max: 0.47142843997894857 arg: 32
mean: 0.013156152874649945
min: -0.38279157243588247 arg: 4
std: 0.2059559167092102


./data/experiment_q14_clean_answers_only_lowercase.json
[[{'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'only has one parameter', 'idx': 580}], [{'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}], [{'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "because function() take no params so it's not useful", 'idx': 598}]]
silhouette scores
[ 0.32494376  0.          0.23973213 -0.28031119 -0.19464395  0.33490692
  0.34501485 -0.00440232  0.41724885  0.00405705  0.19265491  0.05111762
  0.31053734  0.22287963 -0.35936538  0.02885363  0.28036066  0.36768541
  0.17588978  0.20868974  0.71742665  0.03801414  0.27082722  0.02733119
  0.01052901 -0.27532758  0.47876863  0.12269004  0.10304018  0.41512317
 -0.08098729  0.18787295 -0.02725852]
max: 0.7174266495025635 arg: 20
mean: 0.14102724954609144
min: -0.35936537501109456 arg: 14
std: 0.23150318102583445


./data/experiment_q14_clean_answers_only_stopwords.json
[[{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}], [{'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}]]
silhouette scores
[ 0.65509959 -0.03392248 -0.13014387  0.67843847  0.06819087  0.46103093
 -0.18251928  0.21531188  0.84214563 -0.13678057  0.11267066 -0.14783546
 -0.0111391   0.64917204 -0.21437058  0.34764135  0.19224716  0.13689548
  0.17382703  0.14526545 -0.53247626 -0.23258529 -0.16902955 -0.04550458
  0.01638163 -0.35838393  0.09956964  0.10708811  0.68335684  0.39650054
  0.09945754 -0.04928675  0.4734612 ]
max: 0.8421456298495195 arg: 8
mean: 0.13059922281549327
min: -0.5324762591845029 arg: 20
std: 0.32466383382584363


./data/experiment_q14_clean_answers_stopwords_lemma.json
[[{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}], [{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}]]
silhouette scores
[ 0.62202921 -0.15806444 -0.07469108  0.63126188  0.04531013  0.27923408
 -0.27781878 -0.13627167  0.68473028 -0.08367455  0.64225713 -0.20961397
  0.54489073  0.63903528 -0.12093223  0.41796525  0.24412195  0.31695046
  0.2454948   0.16393578 -0.41758315 -0.10509541 -0.12727322 -0.14933379
 -0.01275572  0.45598832 -0.15639336 -0.03928569  0.7300149   0.35589047
 -0.08134135 -0.24359099  0.48453155]
max: 0.7300148975414164 arg: 28
mean: 0.15484614550804288
min: -0.41758315271729046 arg: 20
std: 0.3345232392036016


./data/experiment_q14_raw.json
[[{'data': 'Currying is the technique of transforming one function with multiple arguments into a sequence of functions with a single argument. If this premise does not hold since there is only a single argument, there is no currying.', 'idx': 579}, {'data': "I think we defined currying as 'turning a multiple argument function into a single argument one', so when the function already has a single argument we cannot curry it.", 'idx': 587}, {'data': "Currying reduces the number of arguments of a function and nests them into other new functions. In this case we already have a single-parameter function, so it's not curryable.", 'idx': 593}, {'data': 'Currying is used when there are multiple argument and not a single one', 'idx': 607}], [{'data': 'Currying is used to transform a function with many arguments into many functions with one argument. This is not a useful example of currying ', 'idx': 582}, {'data': 'currying is used in order to avoid passing multiple arguments to a function but in this case is not needed.', 'idx': 588}], [{'data': 'Currying is used to split a multi-argument function into multiple functions. This looks like a curryied function but has no purpose. ', 'idx': 600}, {'data': 'We are not splitting parameters into multiple functions, we are just adding a function that returns a and takes no argument, which is not the goal of currying.', 'idx': 603}], [{'data': "There is no point in currying the identity function. In this case the second function isn't really needed and thus this example doesn't *properly* respresent currying.", 'idx': 583}], [{'data': 'f takes only one arguments so currying is unuseful. Instead of returning directly the value it return a function that, if invoked, returns the value.', 'idx': 589}, {'data': 'Currying allows you to partially evaluate a function, not evaluating one of its arguments. In the code above f takes an argument and the curried version takes the same argument, returning a lambda that returns the value instead of returning the value directly. A better curried version of f would be for example function f() {return a => a}', 'idx': 591}, {'data': 'Currying is typically used when a function accepts more than 1 parameter, so this is a TRICKY question, but I would say that the bottom/second version is currying, because it returns a function that returns some value and it only returns that value when we call that function returned.', 'idx': 602}, {'data': 'Curry splits args; there is only one arg; this is more like lazy value evaluation', 'idx': 608}, {'data': 'currying is a technique to decompose a function in a sequence of n function', 'idx': 610}], [{'data': "The 'uncurried' version already has only one parameter and there is no point in currying it further.", 'idx': 586}, {'data': 'Currying is multiple functions with one parameter. Since it only needs one input parameter, the former version is enough.', 'idx': 590}, {'data': 'F is a function with just one parameter, and currying is used to convert multiple argument function into a sequences of one argument functions.', 'idx': 604}, {'data': 'In both instances we will pass only one parameter to function f(a), which is not what currying tries to achieve.', 'idx': 605}], [{'data': 'An identity function is not equivalent to a generator.', 'idx': 581}, {'data': "The returned function doesn't take any arguments at all.", 'idx': 585}, {'data': "no, in the first one we don't use it, in the second one is not being used correctly", 'idx': 592}, {'data': "because function() take no params so it's not useful", 'idx': 598}, {'data': 'The function already takes only one argument ', 'idx': 599}], [{'data': 'This code is curried as it returns a function, which returns a.', 'idx': 584}, {'data': "Not properly because the original function doesn't need to be curried since it takes only one argument", 'idx': 594}, {'data': 'the uncurried function is not uncurried. It take 1 arguments, while an uncurried function would have at least 2 arguments and would then be curried in multiple functions with 1 arguments each', 'idx': 595}, {'data': "The 'curried' version adds an unnecessary call which is not the purpose of currying.", 'idx': 597}, {'data': "The curried version doesn't add a new function with a parameter. ", 'idx': 611}], [{'data': 'only has one parameter', 'idx': 580}, {'data': "It should, but it seem pointless to have the internal step with no parameters, because it means that the internal function binds the 'return a;' function to an empty environment.", 'idx': 596}, {'data': "yes, from directly returning a, we are going through an intermediary step, but in this case it's quite trivial and not meaningful.", 'idx': 601}, {'data': 'Yes, because we store the environment (the state of a variable) inside a function that we returns.', 'idx': 606}, {'data': 'It takes a parameter and returns a function which take no parameter.', 'idx': 609}]]
silhouette scores
[ 0.01841851 -0.20434911 -0.16789712  0.15382447  0.          0.3536886
 -0.25156816  0.06239427  0.48325652  0.35929432  0.05160255 -0.18999403
 -0.14212237 -0.1619235   0.08832251  0.34575364  0.1967881   0.24797853
 -0.04627537 -0.10385412 -0.35064935  0.08681003  0.05485797 -0.17292791
  0.36773758 -0.19222831 -0.10214247  0.14898698 -0.27309794 -0.22225627
 -0.15233855 -0.20958308  0.43506924]
max: 0.48325651602917286 arg: 8
mean: 0.015502307764333196
min: -0.35064935215193227 arg: 20
std: 0.22798252258506457


./data/experiment_q15_clean_answers_full.json
[[{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}, {'data': 'Just because', 'idx': 642}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}]]
silhouette scores
[-0.23433506  0.45809495  0.39498611 -0.17721147  0.31773045 -0.16565959
 -0.12048676 -0.31823458 -0.0783935   0.3334062   0.          0.09957357
 -0.06653116  0.44914065  0.00370344  0.82531269  0.01616274 -0.03424639
  0.26193048 -0.21487677  0.05511072 -0.09736042  0.11549832  0.01388653
  0.55750193  0.33880476 -0.00890245 -0.34149035  0.2634131  -0.01131171
 -0.26398644  0.29858203  0.43642895]
max: 0.8253126947538532 arg: 15
mean: 0.09412851441343113
min: -0.341490347514032 arg: 27
std: 0.27644331672164846


./data/experiment_q15_clean_answers_only_lemma.json
[[{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}], [{'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'Just because', 'idx': 642}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}]]
silhouette scores
[-0.07310291  0.64119017  0.11065733  0.08630829  0.07395784  0.2201596
 -0.09460139  0.33064945  0.23094744 -0.25516657 -0.00642857  0.05331599
  0.55477686  0.35930134 -0.25838519  0.58033351  0.64527134  0.
  0.33400982  0.          0.47645681  0.3574058   0.15503831  0.17005437
  0.17982666  0.19811049 -0.08202612  0.09694153  0.23744775  0.
  0.05909326  0.50935701  0.44393847]
max: 0.645271343126287 arg: 16
mean: 0.19196480886237308
min: -0.2583851896813224 arg: 14
std: 0.23955922384310452


./data/experiment_q15_clean_answers_only_lowercase.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'two functions are invoked with two different params', 'idx': 632}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'Just because', 'idx': 642}]]
silhouette scores
[ 0.19150928  0.44229861  0.4385745  -0.03434664 -0.14962827 -0.57313819
 -0.19998313  0.47071365 -0.23904416  0.          0.33825486  0.07950534
  0.23570384 -0.19390037  0.40356428 -0.39306871  0.3373567  -0.02628421
 -0.15448308  0.85894825  0.11490212 -0.38813817  0.40923209  0.22693299
  0.45080185 -0.60258541  0.32960395  0.53409068 -0.2896671   0.
 -0.1208665   0.39123115  0.04211739]
max: 0.8589482459583101 arg: 19
mean: 0.08879416901642019
min: -0.6025854132569551 arg: 25
std: 0.3410785931349389


./data/experiment_q15_clean_answers_only_stopwords.json
[[{'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'Just because', 'idx': 642}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}]]
silhouette scores
[-0.05730071  0.47398327  0.36876991  0.07296545  0.23572328 -0.37778528
 -0.14723664  0.33758504  0.26423685 -0.16640443  0.25002546  0.24850075
  0.27284149  0.18925536  0.13890981  0.65295524  0.48573785 -0.25491682
  0.25117944  0.          0.61326226  0.14645979  0.24778909  0.0274963
  0.08932045  0.2452284  -0.18807243  0.22738998  0.36723007 -0.13434354
  0.12714256  0.46718596  0.38521905]
max: 0.6529552431321912 arg: 15
mean: 0.17758585597476811
min: -0.377785281216358 arg: 5
std: 0.24338466624744956


./data/experiment_q15_clean_answers_stopwords_lemma.json
[[{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}], [{'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}], [{'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}, {'data': 'Just because', 'idx': 642}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}], [{'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}, {'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}]]
silhouette scores
[-0.23433506  0.45809495  0.39498611 -0.17721147  0.31773045 -0.16565959
 -0.12048676 -0.31823458 -0.0783935   0.3334062   0.          0.09957357
 -0.06653116  0.44914065  0.00370344  0.82531269  0.01616274 -0.03424639
  0.26193048 -0.21487677  0.05511072 -0.09736042  0.11549832  0.01388653
  0.55750193  0.33880476 -0.00890245 -0.34149035  0.2634131  -0.01131171
 -0.26398644  0.29858203  0.43642895]
max: 0.8253126947538532 arg: 15
mean: 0.09412851441343113
min: -0.341490347514032 arg: 27
std: 0.27644331672164846


./data/experiment_q15_raw.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.', 'idx': 617}, {'data': 'yes, it is correct we can pass values step by step and use curryng properly.', 'idx': 626}, {'data': 'The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.', 'idx': 631}, {'data': 'Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.', 'idx': 637}], [{'data': 'The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f', 'idx': 616}, {'data': 'It represents currying as the function f(a,b) has been converted into two functions with each one argument.', 'idx': 618}, {'data': "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.", 'idx': 620}, {'data': 'Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.', 'idx': 624}], [{'data': "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.", 'idx': 621}, {'data': 'Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).', 'idx': 627}, {'data': 'Yes because from a function that takes two arguments we have two functions with one argument for each', 'idx': 628}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 613}, {'data': "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.", 'idx': 623}, {'data': 'Because it splits a multi-argument function into more functions. ', 'idx': 634}], [{'data': 'two functions, and each function dealing with one argument', 'idx': 614}, {'data': 'In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.', 'idx': 625}, {'data': 'two functions are invoked with two different params', 'idx': 632}], [{'data': 'What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.', 'idx': 615}, {'data': 'Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)', 'idx': 619}, {'data': 'We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.', 'idx': 636}, {'data': 'It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.', 'idx': 639}, {'data': 'It takes a parameter and returns a function which take the other parameters.', 'idx': 643}], [{'data': 'The internal function is correctly bound by the environment of the external one.', 'idx': 630}], [{'data': 'Just because', 'idx': 642}], [{'data': "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.", 'idx': 622}, {'data': 'yes, this way we can first set a independently, then we can call later the sum function with some value b.', 'idx': 635}, {'data': 'Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.', 'idx': 640}], [{'data': 'The function is curried by breaking it down to a series of two functions taking one argument each.', 'idx': 633}, {'data': "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.", 'idx': 638}, {'data': 'Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body', 'idx': 641}, {'data': 'in the curried function we decomposing the unhurried function', 'idx': 644}], [{'data': 'the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.', 'idx': 629}, {'data': 'Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter', 'idx': 645}]]
silhouette scores
[-0.28151117 -0.4557447   0.23739202  0.19239848  0.03667708  0.21438445
 -0.00789781  0.36972538  0.73470725 -0.12976921 -0.01400455  0.1563884
 -0.23660829  0.36156757  0.62847347  0.40977547  0.6896702   0.
  0.36582648  0.18248558  0.53695637  0.12158593 -0.05570596  0.27182307
  0.11221511  0.33074595 -0.27330299 -0.00675013  0.37028266  0.
  0.14836172  0.55907142  0.48163618]
max: 0.7347072513661966 arg: 8
mean: 0.1833592553862295
min: -0.4557446996969189 arg: 1
std: 0.2865181522992055


./data/experiment_q16_clean_answers_full.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}]]
silhouette scores
[-0.26759328 -0.40511328 -0.03401049 -0.05742291  0.47727564  0.47034983
  0.07585492  0.41665775  0.66120904 -0.02445313  0.38999486  0.38156482
  0.4694417   0.43031832  0.59435584  0.83734619 -0.00677818 -0.02716139
  0.28519921  0.07448095  0.2201954   0.31528935  0.2149837   0.2517995
  0.30469135  0.37373638  0.12480422 -0.02172877 -0.20277858  0.04368548
 -0.02238636 -0.20757528  0.05901576]
max: 0.8373461878211057 arg: 15
mean: 0.18773480552691632
min: -0.40511327889245324 arg: 1
std: 0.2798689573065523


./data/experiment_q16_clean_answers_only_lemma.json
[[{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': 'Just because', 'idx': 676}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}], [{'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}]]
silhouette scores
[-0.29838363 -0.22476203  0.38852663  0.         -0.10871678  0.50585315
  0.33286103  0.09374612  0.71903284 -0.51824671  0.35601993  0.439293
  0.50902049 -0.26179923  0.55958967  0.02637365 -0.37908792 -0.03210351
  0.5378938   0.18748044  0.27660472  0.62101087 -0.14359652 -0.20495896
  0.3154151   0.37377056  0.35706645 -0.05688071  0.         -0.07223433
  0.02309201 -0.11026383 -0.29362737]
max: 0.7190328368849506 arg: 8
mean: 0.11872693636345262
min: -0.5182467140997131 arg: 9
std: 0.32227771786997905


./data/experiment_q16_clean_answers_only_lowercase.json
[[{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}], [{'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}], [{'data': 'Just because', 'idx': 676}]]
silhouette scores
[-0.08830201  0.32201553  0.34188247 -0.37697217 -0.28912652  0.23489859
 -0.08428208  0.13994388  0.16725238 -0.23389422  0.0141476   0.57634223
 -0.0134703   0.25406489 -0.02141586 -0.23872146 -0.05442034  0.14102963
  0.0841112   0.66602534  0.61457732  0.24920406  0.26794888  0.47492728
 -0.08673974  0.38153416 -0.30999706 -0.18173975 -0.05339202  0.
  0.25763711 -0.07388822  0.45887879]
max: 0.6660253376560384 arg: 19
mean: 0.10727453191505366
min: -0.37697217481342665 arg: 3
std: 0.27367108849464683


./data/experiment_q16_clean_answers_only_stopwords.json
[[{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'Just because', 'idx': 676}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}]]
silhouette scores
[ 0.11118225  0.20477885  0.09116649  0.05543906  0.43545699  0.26939015
 -0.15271346  0.32755944  0.28751985 -0.51474507  0.22800278  0.
 -0.36746395 -0.01988984  0.06228753  0.80813911  0.29877009 -0.04614156
  0.48296137  0.13676323  0.17299691  0.54186434 -0.09772214  0.00497771
  0.01438505  0.45018229  0.23183461 -0.04099347  0.57982308 -0.06652845
 -0.27117904 -0.03698952 -0.38327154]
max: 0.8081391057736285 arg: 15
mean: 0.1150861553097738
min: -0.5147450725095144 arg: 9
std: 0.2866003464794549


./data/experiment_q16_clean_answers_stopwords_lemma.json
[[{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': 'Just because', 'idx': 676}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}]]
silhouette scores
[-0.26759328 -0.40511328 -0.03401049 -0.05742291  0.47727564  0.47034983
  0.07585492  0.41665775  0.66120904 -0.02445313  0.38999486  0.38156482
  0.4694417   0.43031832  0.59435584  0.83734619 -0.00677818 -0.02716139
  0.28519921  0.07448095  0.2201954   0.31528935  0.2149837   0.2517995
  0.30469135  0.37373638  0.12480422 -0.02172877 -0.20277858  0.04368548
 -0.02238636 -0.20757528  0.05901576]
max: 0.8373461878211057 arg: 15
mean: 0.18773480552691632
min: -0.40511327889245324 arg: 1
std: 0.2798689573065523


./data/experiment_q16_raw.json
[[{'data': 'This represents currying as the function is properly curried into three functions each having one argument. The code can also be half-executed.', 'idx': 652}, {'data': "The 'uncurried' version has three parameters. With currying, we require just one parameter in each of the functions. The innermost function carries out the same behavior of the uncurried version.", 'idx': 654}, {'data': 'Each function in the sequence of the curried function partially applies one of the arguments of the uncurried function.', 'idx': 667}, {'data': 'Yes it properly represent currying, as a function with three parameters is split into three functions, one for each parameter, and one returns the next one. The same logic as before (with 2 parameters) can be applied for any number of parameters.', 'idx': 671}], [{'data': 'Since as explained in Question 2 of Curry: the curried version are indeed multiple functions with one parameter.', 'idx': 653}, {'data': 'Multiple input parameters with currying. It can be invoked  as `f(1)(2)(3)`.', 'idx': 658}, {'data': 'Same as before, but this time f contains 3 instead of 2 parameters and the curried version has one more nested function.', 'idx': 670}], [{'data': 'There are three args and we nested two function one inside the other, we will call the function with f(a)(b)(c)', 'idx': 675}], [{'data': 'one function is needed for each parameter provided, creating the nested returning of functions', 'idx': 656}, {'data': 'All open variables of the function are closed and the environments are clearly defined.', 'idx': 664}, {'data': 'The same motivation of Option 2. In the first call we store the value of the first operand, in the second call we store the value of the second, and in the third call we execute the sum. From a function with many parameters, to functions with only one parameters.', 'idx': 674}, {'data': 'It makes the parameters could be taken one by one.', 'idx': 677}], [{'data': 'because there is a sequence of nested functions with a single argument', 'idx': 647}, {'data': 'multiple functions, and each function dealing with one argument', 'idx': 648}, {'data': 'A function with multiple arguments was transformed to a sequence of functions with one argument each.', 'idx': 665}, {'data': 'each function takes a different params, so we have multiple functions with the same params', 'idx': 666}, {'data': 'It changes a multi argument function to a sequence of one argument functions.', 'idx': 672}], [{'data': "Yes, we went from calling f with 'f(a,b,c)' to 'f(a)(b)(c)', effectively turning f into a single argument function (that returns another single argument function that returns another single argument function). Those two calls produce the same effects.", 'idx': 655}, {'data': "Like before, from a function with multiple arguments (3) to multiple function (3) with one argument. Instead of calling f(1, 3, 8) now you can call f(1)(3)(8). It's half executing a function.", 'idx': 657}, {'data': 'The function f(a, b, c) is turned into multiple functions each taking one argument. So the call of f goes from being f(1, 2, 3) to f(1)(2)(3). The two functions do the same computation.', 'idx': 659}, {'data': 'Yes. Again, a single multiple-arguments function is converted into multiple single-argument functions. To obtain f(a,b,c), we now have to call f(a)(b)(c).', 'idx': 661}, {'data': 'explained with arrow function for example var f = a => b => c => a+b+c;', 'idx': 678}], [{'data': 'This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b)(c). In this case we use an anonymous function to do the currying.', 'idx': 651}, {'data': 'yes, the second function is correct and we can use curryng. example calling f(2)(3)(4)', 'idx': 660}, {'data': 'Yes because the curried version is callable like this: f(a)(b)(c)', 'idx': 662}], [{'data': 'Same as Option 2 but now with 3 arguments. We now call f as f(1)(2)(3) instead of f(1,2,3)', 'idx': 649}, {'data': 'Because it splits a function with 3 arguments into 3 functions. ', 'idx': 668}, {'data': 'It does, because now instead of calling one function with 3 parameters we can call 3 functions with a single parameter.', 'idx': 673}], [{'data': 'the 3 arguments of the uncurried function are divided into 3 functions that take 1 argument each. ', 'idx': 663}, {'data': "yes, we can set a value for a and b independently, and after we can call the sum for the 3 numbers, without the need to directly pass 3 numbers that we can't change as in the uncurried version.", 'idx': 669}, {'data': "It's correct. Curried version has 3 functions taking 1 parameters each instead of the uncurried version that has 1 function taking 3 parameters", 'idx': 679}], [{'data': 'Follows the earlier question but correctly uses semicolons', 'idx': 650}, {'data': 'Just because', 'idx': 676}]]
silhouette scores
[-0.14064776  0.46332895  0.42260892 -0.14669921  0.28205396  0.46778069
  0.33606254  0.2665165   0.18865516 -0.4674532  -0.42469465  0.43847483
 -0.01191407 -0.09387639 -0.01738496  0.2960947   0.03464694 -0.00515189
  0.68509146  0.24475436  0.12193626  0.67662683  0.25903906 -0.16721708
  0.35187066  0.48257027  0.55550884 -0.0286049   0.         -0.17891055
  0.02993248 -0.12449955  0.03961347]
max: 0.6850914582183467 arg: 18
mean: 0.14654886864771646
min: -0.46745319561040266 arg: 9
std: 0.2884732336353092


./data/experiment_q17_clean_answers_full.json
[[{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[-1.46429368e-01 -2.39810371e-02 -4.36282707e-01  1.13682815e-01
  1.84915386e-01  1.70398652e-02 -1.80257178e-01  1.43143044e-01
  1.50911279e-01  1.06763476e-01  6.93860140e-01 -6.51681391e-02
  2.09163957e-01 -5.59166104e-05 -3.34491701e-01  6.09269314e-01
 -6.48535992e-01 -3.56780639e-01 -2.40752803e-01  2.52098449e-01
 -1.23953524e-01  6.53744575e-01 -3.13183454e-01  0.00000000e+00
  2.02814094e-01  1.00928299e-01  1.99583431e-02  8.24905051e-02
 -3.22174530e-01  2.88523053e-01]
max: 0.6938601401190969 arg: 10
mean: 0.021241986874995508
min: -0.6485359916222893 arg: 16
std: 0.3055988710281776


./data/experiment_q17_clean_answers_only_lemma.json
[[{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'print that', 'idx': 814}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[-8.82510177e-02 -5.91873562e-02  3.80631630e-04  6.37943804e-01
  2.62243208e-01  2.06928715e-01  0.00000000e+00 -1.19424724e-01
  1.51374504e-01  7.69015385e-02  3.59319483e-01 -1.07086194e-01
  1.90847865e-01 -1.20455186e-01 -2.98577045e-01  5.64811471e-01
  1.03080121e-01  6.94300709e-01 -6.14270578e-03  1.82757403e-01
 -2.26411809e-01 -4.72486097e-01 -1.62600301e-01  0.00000000e+00
  2.14996149e-01 -3.34613277e-01  2.46252594e-02  1.34257825e-01
  0.00000000e+00  2.77172167e-01]
max: 0.694300709301217 arg: 17
mean: 0.06955683803127508
min: -0.4724860965525273 arg: 21
std: 0.2650897799726017


./data/experiment_q17_clean_answers_only_lowercase.json
[[{'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'The program is terminated in function c.', 'idx': 813}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[ 0.60994473  0.15719117 -0.0696605   0.36257597  0.176728    0.52924628
  0.42678068  0.02893645 -0.27393816  0.2855439   0.30543128  0.24120749
  0.26030812  0.47011452  0.2131527   0.58640364 -0.14762257  0.31985284
  0.10083875  0.61931245  0.15931552  0.17346435 -0.0146159  -0.12166242
  0.51276899  0.27968616  0.27921431 -0.13618706  0.21755013 -0.17366826]
max: 0.6193124473151064 arg: 19
mean: 0.21260711846076255
min: -0.27393816048797914 arg: 8
std: 0.24227308421589613


./data/experiment_q17_clean_answers_only_stopwords.json
[[{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[-0.16017491 -0.02484838 -0.34156168  0.21741585  0.16969767  0.01076271
 -0.11656775  0.16957719  0.18699132  0.10422312  0.51379456 -0.04159009
  0.21749985  0.00943899 -0.29883629  0.52486707 -0.60575812 -0.35538976
 -0.19517672  0.2512329  -0.15416242  0.54798094 -0.29934923  0.
  0.18329174  0.0852485  -0.01131361  0.04769858 -0.27762558  0.27125241]
max: 0.5479809443457306 arg: 21
mean: 0.02095396194063344
min: -0.6057581170353828 arg: 16
std: 0.26919978019831514


./data/experiment_q17_clean_answers_stopwords_lemma.json
[[{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': 'print that', 'idx': 814}, {'data': "Yes it's correct.", 'idx': 815}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}]]
silhouette scores
[-1.46429368e-01 -2.39810371e-02 -4.36282707e-01  1.13682815e-01
  1.84915386e-01  1.70398652e-02 -1.80257178e-01  1.43143044e-01
  1.50911279e-01  1.06763476e-01  6.93860140e-01 -6.51681391e-02
  2.09163957e-01 -5.59166104e-05 -3.34491701e-01  6.09269314e-01
 -6.48535992e-01 -3.56780639e-01 -2.40752803e-01  2.52098449e-01
 -1.23953524e-01  6.53744575e-01 -3.13183454e-01  0.00000000e+00
  2.02814094e-01  1.00928299e-01  1.99583431e-02  8.24905051e-02
 -3.22174530e-01  2.88523053e-01]
max: 0.6938601401190969 arg: 10
mean: 0.021241986874995508
min: -0.6485359916222893 arg: 16
std: 0.3055988710281776


./data/experiment_q17_raw.json
[[{'data': 'it follows the CPS expression', 'idx': 784}, {'data': 'By the invocation, first is a, then anonymous function 1, then b then anonymous function 2 then c. So that the sequence is `a(1,f1)->f1(2)->b(2,f2)->f2(4)`', 'idx': 794}, {'data': 'Yes. The stacktrace for this code would be a (first two instructions with k=1) -> b (first two instructions with k=2) -> c (first two instructions with k=4). After that instruction, the program is interrupted.', 'idx': 797}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 783}, {'data': 'the first execution is a, followed by the body of the function as second parameter, followed by b, followed by its body, followed by c, which terminates after process.exit(1)', 'idx': 792}, {'data': "The stack call is: a -> function(two, ...) -> b -> function(four, ...) -> c -> exit. Since the program exit after printing 'c1' the output is correct.", 'idx': 799}], [{'data': 'I am not sure what kind of explanation I should give here since this is the way the code is executed. We begin with function a() then its continuation which calls function b and then we call the continuation of b and that calls c which calls process.exit() and then the program terminated.', 'idx': 787}, {'data': 'This is correct as the program is terminated on process.exit(1).', 'idx': 788}, {'data': 'The program is terminated in function c.', 'idx': 813}], [{'data': 'The process exits inside the call to c, therefore all the remaining console logs arent executed', 'idx': 791}, {'data': 'The output is missing the second console.log of each function.', 'idx': 795}, {'data': "Because after the console.log('c1'); the process.exit(1); will terminate the program, so the rest of console.log that remain won't be executed.", 'idx': 808}, {'data': 'Yes. At any invocation we call the console.log inside the function (a,b,c) and the console.log inside the callback alternatively.', 'idx': 810}, {'data': "Seq is correct, c call kills program, so no function returns and logs '...2'", 'idx': 812}], [{'data': 'It is correct a prints a1 then calls function(two) that first prints ft1 then calls b that prints b1 and then calls function(four) that prints ff1 and calls c that prints c1 and terminates', 'idx': 786}, {'data': "a is called with 1 and logs 'a1', then calls the function passed as a second parameter with argument 2. This function logs 'ft1' and then calls b with 2. Function logs 'b1' and then calls the function passed as a second parameter with argument 2+2=4. That function logs 'ff1' and then calls c passing 4 as argument. C logs 'c1' and then terminates the program.", 'idx': 790}, {'data': 'a first prints a1 and then applies the anonymous function which prints ft1 and calls b. b first prints b1 and then calls the anonymous function which prints ff1 and calls c. c prints c1 and   terminates the execution of the program.', 'idx': 803}], [{'data': 'because it starts by executing a. It prints a1 then call the function passed to a. This prints ft1 that execute b. This prints b1 than call the function passed to b. It prints ff1 than call c. This prints c1 than the process exit.', 'idx': 793}, {'data': 'First you call function a, which prints a1. Then you have the continuation with (arg+1). The continuation prints ft1. Then it calls b which prints b1. The continuation is called which prints ff1. Then c is called which prints c1 and then process.exit(1) terminates the program.', 'idx': 801}, {'data': "console.log('a1'), console.log('ft1'), console.log('b1'), console.log('ff1'), console.log('c1'), process.exit(1)", 'idx': 802}, {'data': "It start by calling a, so ti prints 'a1'. Then it logs 'ft1' inside k. Then it calls b, which prints 'b1'. Then k inside b is evaluated, which prints 'ff1'. It call c which prints 'c1' and then it exits with code 1, thus it stops printing.", 'idx': 807}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 811}], [{'data': "We start by invoking a, and print 'a1', we continue into an anonymous function printing 'ft1', then go into b printing 'b1', then into the other anonymous function printing 'ff1', then we invoke c and print 'c1'. After said print we reach process.exit and the program terminates.", 'idx': 785}, {'data': "Because when function c is called we print 'c1' and then process.exit(1) terminates the program.", 'idx': 804}], [{'data': 'Because after a1 and ft1 ', 'idx': 809}], [{'data': 'This a case of kick-forward style where where the pipeline stages are glued together with lambdas, and the program will stop when logging c1.', 'idx': 789}], [{'data': 'print that', 'idx': 814}], [{'data': 'the output is correct.', 'idx': 805}, {'data': 'I think this is correct because c calls exist, so we will not be printing anything after that, including what comes after the calls to k.', 'idx': 806}, {'data': "Yes it's correct.", 'idx': 815}]]
silhouette scores
[-0.11585635 -0.03019549  0.01535325  0.44261088  0.20847363  0.1293481
  0.          0.27647789  0.08718946 -0.00657678 -0.05046723 -0.18058526
  0.22648198 -0.22405723 -0.23562706  0.51933667  0.40677005 -0.10714473
  0.32317793  0.52003543 -0.27132132  0.24423171 -0.4273637   0.
  0.23251156  0.15457208 -0.1053931   0.1760308   0.          0.48651674]
max: 0.5200354321962616 arg: 19
mean: 0.08981766405090771
min: -0.42736370351841246 arg: 22
std: 0.24488732826901197


./data/experiment_q18_clean_answers_full.json
[[{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'The last output is ft2', 'idx': 829}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}]]
silhouette scores
[ 0.33864519  0.33982956  0.39319923  0.43786986  0.13510043  0.33638227
  0.32510082  0.22630721 -0.11382678  0.5519673   0.14874434  0.11794288
  0.44000943  0.07624611  0.5024322  -0.19678282  0.32418366  0.5558105
  0.35979717  0.21414909  0.0458205   0.41185354  0.56164707  0.13700369
 -0.06908501 -0.08513575  0.39648832  0.          0.10466948]
max: 0.5616470702515312 arg: 22
mean: 0.2419437751726467
min: -0.19678282198610492 arg: 15
std: 0.21065916965926548


./data/experiment_q18_clean_answers_only_lemma.json
[[{'data': 'See Option 1.', 'idx': 819}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'The last output is ft2', 'idx': 829}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}]]
silhouette scores
[-2.64260141e-01  3.11764510e-01  3.00842284e-01  1.00000000e+00
  2.63120530e-01 -1.14545170e-01  3.12613599e-01 -1.44989038e-01
  1.52814149e-01  4.05662014e-01 -2.37968584e-01 -9.18225103e-02
  3.71812540e-01  9.32198031e-02  5.09568084e-01  3.34070030e-01
  8.60266623e-02  3.74473891e-01  4.16421478e-01  1.50845902e-01
  5.34205140e-01  4.77358968e-01  6.04009583e-01 -2.31995767e-01
 -3.96883327e-02  1.51587568e-01  1.00000000e+00 -8.58375241e-04
  4.55451076e-01]
max: 1.0 arg: 3
mean: 0.24757723770962664
min: -0.2642601409679325 arg: 0
std: 0.3194795886597034


./data/experiment_q18_clean_answers_only_lowercase.json
[[{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'The last output is ft2', 'idx': 829}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}], [{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}]]
silhouette scores
[ 0.02416267  0.19530614  0.35169401  0.95142572  0.32629315 -0.0555311
  0.49175168  0.04901766  0.10718356  0.4295309   0.18360812 -0.12587056
  0.07601903  0.54720235 -0.08939186  0.12838426  0.53411834 -0.36795164
 -0.06262439 -0.40084799  0.72741248  0.85215401  0.20331583  0.53440952
 -0.15258208 -0.13180149  0.47555952  0.91567482  0.5536275 ]
max: 0.9514257246268768 arg: 3
mean: 0.25073276499467584
min: -0.4008479858379676 arg: 19
std: 0.35972955993247663


./data/experiment_q18_clean_answers_only_stopwords.json
[[{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'The last output is ft2', 'idx': 829}, {'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}]]
silhouette scores
[ 0.32814837  0.34291039  0.39319923  0.43116405  0.13510043  0.3376965
  0.32510082  0.19019454 -0.01968912  0.5519673   0.18791607  0.12466577
 -0.18797454  0.03729163  0.50941876 -0.22114692  0.35683681  0.56755775
  0.35979717  0.21414909  0.0458205   0.41185354  0.59857587  0.13331677
 -0.17570394 -0.0764335   0.41496202 -0.16925439  0.10466948]
max: 0.5985758667958669 arg: 22
mean: 0.2155900149034823
min: -0.22114692457435414 arg: 15
std: 0.2359248599428426


./data/experiment_q18_clean_answers_stopwords_lemma.json
[[{'data': 'after printing c1, the system teminates', 'idx': 818}, {'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}], [{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': 'The last output is ft2', 'idx': 829}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': 'is a wrong result of continuation', 'idx': 848}], [{'data': 'See Option 1.', 'idx': 819}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}]]
silhouette scores
[ 0.33864519  0.33982956  0.39319923  0.43786986  0.13510043  0.33638227
  0.32510082  0.22630721 -0.11382678  0.5519673   0.14874434  0.11794288
  0.44000943  0.07624611  0.5024322  -0.19678282  0.32418366  0.5558105
  0.35979717  0.21414909  0.0458205   0.41185354  0.56164707  0.13700369
 -0.06908501 -0.08513575  0.39648832  0.          0.10466948]
max: 0.5616470702515312 arg: 22
mean: 0.2419437751726467
min: -0.19678282198610492 arg: 15
std: 0.21065916965926548


./data/experiment_q18_raw.json
[[{'data': 'This is wrong as the program exits before it can print out ff2', 'idx': 822}, {'data': 'The process exits inside the call to c, therefore all the lines after c1 will not be part of the output', 'idx': 825}, {'data': 'Because after printing c1 the process exits.', 'idx': 827}, {'data': "c(four,null) execute process.exit(1) which doesn't allow to print other things further", 'idx': 836}], [{'data': "After printing 'c1' the program terminates and so the following output is not printed.", 'idx': 833}, {'data': "After process.exit(1) the program terminates so it can't print anything else after c1 is printed.", 'idx': 835}, {'data': 'The execution is similar to the one in the previous exercise. In this case C2 will not be printed because c terminates the execution before printing.', 'idx': 837}, {'data': 'The program will be terminated after c1 is printed.', 'idx': 842}, {'data': "Because the program terminates after calling console.log('c1') so it is not possible to call console.log ('c2') and the other console.log.", 'idx': 844}], [{'data': 'after printing c1, the system teminates', 'idx': 818}], [{'data': 'See Option 1.', 'idx': 819}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 821}, {'data': 'the option 1 was right', 'idx': 826}, {'data': 'Option 1 is the correct answer.', 'idx': 838}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 849}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 823}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 839}, {'data': 'I think this is wrong for the same reason the previous option was', 'idx': 840}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 841}], [{'data': 'The execution stops after process.exit(1) when function c is called.', 'idx': 817}, {'data': "No, the code after `process.exit(1);' will not run. ", 'idx': 828}, {'data': 'The last output is ft2', 'idx': 829}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 845}], [{'data': 'it will terminate during c', 'idx': 820}, {'data': 'The program is terminated in function c.', 'idx': 847}], [{'data': "Proceeding the same way as in Option 1, when we reach function c(), after logging 'c1' we abruptly terminate the whole program. No other statement is executed after that point.", 'idx': 824}, {'data': "Since function a calls function b which calls function c which kills the program, the instructions that would happen after c (the remaining line of b and a as well as the console.log('ff2') and console.log('tf2')) will not be executed.", 'idx': 831}, {'data': "Seq is correct, but c call kills program, so no function returns and logs '...2'", 'idx': 846}, {'data': 'is a wrong result of continuation', 'idx': 848}]]
silhouette scores
[-0.12184329  0.          0.49664024  1.          0.17431204  0.02683968
  0.06626951 -0.34666836 -0.09193267  0.44819395 -0.04360175 -0.15006387
  0.09105691 -0.12465925  0.56524649  0.50297765  0.07178078  0.46116181
  0.49112627  0.13515438  0.18135662  0.31574623  0.64217281  0.41995525
 -0.05969363  0.04067583  1.         -0.04516095  0.30759061]
max: 1.0 arg: 3
mean: 0.22257356206302592
min: -0.3466683615726447 arg: 7
std: 0.32753580310480884


./data/experiment_q19_clean_answers_full.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'not correct', 'idx': 882}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}]]
silhouette scores
[ 0.3213309  -0.26393533  1.         -0.19838773  0.07967669  0.03493137
  0.0799805  -0.02607694 -0.05129918  1.          0.94153305  0.15533681
 -0.04340689  0.88407329  0.8788384  -0.12356608  0.15122554 -0.38625626
 -0.45295486  0.12487877  0.33698014 -0.16243315 -0.15488726  0.30055778
 -0.18505705  0.04872896  0.3230149  -0.18186002]
max: 1.0 arg: 2
mean: 0.1582487991566155
min: -0.45295486369861354 arg: 18
std: 0.4153822562930482


./data/experiment_q19_clean_answers_only_lemma.json
[[{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}], [{'data': 'The output is missing the ft.. outputs.', 'idx': 863}], [{'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': 'See Option 1.', 'idx': 853}, {'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'the option 1 was right', 'idx': 860}], [{'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'not correct', 'idx': 882}]]
silhouette scores
[ 0.45216585  0.42920353  0.4955918   0.46228135  0.28463418  0.41449562
  0.10865802 -0.00713425 -0.00075852  0.42412027 -0.19631874  0.29276784
  0.          0.38030968  0.25679199  0.40626398  0.34376798 -0.07808762
  0.48572093  0.60449245 -0.62719976 -0.15091089  0.36440923 -0.15110688
  0.35762082 -0.1610901   0.64170966  0.15706315]
max: 0.6417096586629872 arg: 26
mean: 0.213909342158659
min: -0.6271997563911985 arg: 20
std: 0.292704037645412


./data/experiment_q19_clean_answers_only_lowercase.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}], [{'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': 'not correct', 'idx': 882}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}]]
silhouette scores
[ 0.28480174  0.31900649  0.20211637  0.06311625 -0.25726539  0.6604848
  0.18073625  0.3423445  -0.05490803  0.43130767  0.56903214 -0.09148935
  0.36009789  0.48270591  0.29132216  0.09586947  0.32920187  0.05548885
  0.55316196  0.04158612  0.49193283  0.14572402 -0.1486698   0.05089208
 -0.16518454  0.1675805  -0.05773542 -0.49226324]
max: 0.6604847985408787 arg: 5
mean: 0.17324978982757377
min: -0.4922632352616953 arg: 27
std: 0.26896862936178195


./data/experiment_q19_clean_answers_only_stopwords.json
[[{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}]]
silhouette scores
[ 0.12216821 -0.22695674  0.69533031  0.50542468  0.06684445  0.48487692
  0.37956415  0.10942496  0.34593922  0.8483603   0.93724486  0.15533681
  0.03399536  0.88204954  0.8788384   0.29090911  0.09190902 -0.38463737
  0.54784659  0.33315159  0.30844143  0.33237847 -0.34856126  0.1163984
 -0.13744282  0.05106886  0.10353331  0.31667368]
max: 0.9372448642766329 arg: 10
mean: 0.280003943987114
min: -0.38463736558497874 arg: 17
std: 0.3497192903694345


./data/experiment_q19_clean_answers_stopwords_lemma.json
[[{'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'not correct', 'idx': 882}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}]]
silhouette scores
[ 0.3213309  -0.26393533  1.         -0.19838773  0.07967669  0.03493137
  0.0799805  -0.02607694 -0.05129918  1.          0.94153305  0.15533681
 -0.04340689  0.88407329  0.8788384  -0.12356608  0.15122554 -0.38625626
 -0.45295486  0.12487877  0.33698014 -0.16243315 -0.15488726  0.30055778
 -0.18505705  0.04872896  0.3230149  -0.18186002]
max: 1.0 arg: 2
mean: 0.1582487991566155
min: -0.45295486369861354 arg: 18
std: 0.4153822562930482


./data/experiment_q19_raw.json
[[{'data': "'ft1' and 'ff1' are not printed and 'c2', 'b2' and 'a2' should not", 'idx': 851}, {'data': "It doesn't print ft1 nor ff1 and also should never reach c2", 'idx': 854}, {'data': "console.log('ft1') and console.log('ff1') should be execute", 'idx': 870}, {'data': 'ft1 will be printed always before b1, ff1 befor c1 and after c1 the program will end.', 'idx': 876}], [{'data': 'This is wrong as it never prints out ft1', 'idx': 856}, {'data': 'Because after printing a1, the function passed to a is invoked. This will print ft1.', 'idx': 861}, {'data': 'Here it does not print the `ft1` and `ff1`.', 'idx': 862}, {'data': 'The output is missing the ft.. outputs.', 'idx': 863}, {'data': 'the anonymous function passed to `a`, first prints ft1 which is not in the given output log.', 'idx': 871}], [{'data': 'second argument should be ft1 ', 'idx': 852}, {'data': 'after a1 is printed, ft1 is printed as the lambda is invoked by a just after a1 is printed.', 'idx': 865}, {'data': "after printing 'a1' the program call the lambda passed as argument, and this would print 'ft1'.", 'idx': 867}, {'data': 'Letter functions call lambdas, so seq here is incorrect', 'idx': 880}], [{'data': "There can only be one correct solution and that is option 1 (since the code doesn't change).", 'idx': 855}, {'data': 'Since, we saw already that the first option was correct, and the program is always the same.', 'idx': 857}, {'data': 'no time to type in the explanation, but the correct output is in the first option', 'idx': 873}, {'data': 'It is the same code and since the first option was right this one can not output something different.', 'idx': 875}, {'data': 'not correct', 'idx': 882}], [{'data': 'See Option 1.', 'idx': 853}, {'data': 'the option 1 was right', 'idx': 860}, {'data': 'Option 1 is the correct answer.', 'idx': 872}, {'data': 'No, the correct execution is listed in Option 1', 'idx': 883}], [{'data': "The option ignores the anonymous functions that glue together the three stages and that contain log statements. Moreover, as in Option 2 it doesn't handle correctly the abrupt termination inside stage c().", 'idx': 858}, {'data': 'The same reason. We call alternatively a1,ft1,b1,ff1,c1. the other are reached after the function c ends (continuation calls), but ic terminate the program.', 'idx': 878}, {'data': "the first function evaluated  is a (a1) which takes another function and than console.log('ft1'), then b is evaluated (b1) which thake another function and then console.log(ff1) and final c it is evaluated (c1) which reach the process.exit(1) and terminateds", 'idx': 879}, {'data': "The function a performs k(arg+1) before it logs 'a2', and the program is terminated during performing k(arg+1), so there is no chance to log 'a2'.", 'idx': 881}], [{'data': 'This shows only the lines printed by the a,b and c function and not those printed when calling the actual continuations.', 'idx': 859}, {'data': 'The logs of the continuation functions are missing, and after c1 nothing else can be printed since the program exits.', 'idx': 869}]]
silhouette scores
[ 0.35533394 -0.02476017  0.66498118  0.36271531 -0.13742333  0.11190209
  0.29325306  0.16808724  0.28883451  0.59282426 -0.13777498  0.07130165
  0.15423989  0.2838917   0.25643663 -0.1387113   0.06129623  0.30760866
  0.47842497  0.38678174  0.3599938   0.21997333 -0.02237657  0.00402764
  0.1859001   0.20199849  0.30405259  0.19622797]
max: 0.6649811819110418 arg: 2
mean: 0.20889430779539733
min: -0.13871129884425673 arg: 15
std: 0.20128767520389443


