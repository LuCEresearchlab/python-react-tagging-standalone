data_affinity/experiment_q00_clean_answers_full.json
[[{'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}], [{'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 0.38720885 -0.45045841  0.          0.02522034  0.          0.0222512
 -0.15652631  0.41570835 -0.14846235  0.3174581  -0.53676519  0.
  0.         -0.19892843 -0.03720232 -0.02683878 -0.53934831 -0.32673452
  0.29848941  0.19560907 -0.03058186  0.44581355  0.05926285  0.
  0.202872   -0.00376193 -0.26498242  0.36896458  0.          0.
 -0.14195884  0.12146531  0.        ]
max: 0.44581354756387515 arg: 21
mean: -6.745601381601004e-05
min: -0.5393483096199344 arg: 16
std: 0.24707615473883437


data_affinity/experiment_q00_clean_answers_only_lemma.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'The variable is not declared as final. ', 'idx': 19}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}], [{'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 0.7306583  -0.26113857 -0.12684209 -0.05199457  0.          0.07983489
 -0.07160148  0.40985221  0.          0.7306583  -0.32133886 -0.13688357
 -0.20938861  0.          0.24300536  0.          0.21243124  0.12821765
  0.18842875  0.29384446  0.          0.16136486  0.42441429  0.
  0.17543374  0.         -0.09630497 -0.24439937  0.01876968  0.
  0.41338351  0.0575635   0.        ]
max: 0.7306583038618144 arg: 0
mean: 0.08327177800604496
min: -0.32133885817903673 arg: 10
std: 0.24582379189575346


data_affinity/experiment_q00_clean_answers_only_lowercase.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'The variable is not declared as final. ', 'idx': 19}], [{'data': 'To be immutable should have final', 'idx': 20}], [{'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': 'it requires the keyword final to be immutable.', 'idx': 23}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': 'You can change the variable name for another string.', 'idx': 26}, {'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}], [{'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}], [{'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}], [{'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}, {'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 1.         -0.28837996 -0.13955425 -0.55421163 -0.09756664  0.0014207
  0.2151244  -0.35672999  0.05956794  1.         -0.38557192 -0.07910845
 -0.18422455  0.         -0.27979935 -0.28153152 -0.46806912  0.
  0.          0.         -0.23390757 -0.0744559   0.         -0.16750078
 -0.09577899  0.01973291 -0.42231571  0.          0.07248672 -0.18933858
  0.12960681  0.          0.        ]
max: 1.0 arg: 0
mean: -0.05454864912532689
min: -0.5542116297496089 arg: 3
std: 0.32088073689199276


data_affinity/experiment_q00_clean_answers_only_stopwords.json
[[{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}, {'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}, {'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}], [{'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 8.82045170e-01 -9.10387207e-01 -4.11823075e-01 -8.64629943e-03
  0.00000000e+00 -6.30794969e-04 -1.14861518e-01  2.89938850e-01
 -8.38944267e-02  8.66232608e-01 -4.62515690e-01 -4.29182003e-01
  0.00000000e+00 -1.44743618e-01 -3.90526199e-01  0.00000000e+00
 -4.37881414e-01  5.79925442e-02 -4.85700604e-01  6.41948287e-01
 -2.16367479e-01  1.84031784e-01  6.68028910e-01  0.00000000e+00
  8.74093648e-01 -2.88480572e-02  0.00000000e+00 -1.98954979e-01
  7.40551171e-03  0.00000000e+00  0.00000000e+00  1.52072914e-01
  0.00000000e+00]
max: 0.8820451704227614 arg: 0
mean: 0.009055359464696235
min: -0.9103872066405304 arg: 1
std: 0.4044336641264061


data_affinity/experiment_q00_clean_answers_stopwords_lemma.json
[[{'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'it is not declared as final', 'idx': 10}, {'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}], [{'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}], [{'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}], [{'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}], [{'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}], [{'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}], [{'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}], [{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}], [{'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}]]
silhouette scores
[ 0.38720885 -0.86739737  0.          0.02522034  0.          0.09527829
 -0.15652631  0.38836061 -0.14846235  0.3174581  -0.53676519  0.
  0.         -0.19892843 -0.29278204 -0.02683878 -0.53934831 -0.32673452
  0.29848941  0.65671872 -0.03058186  0.41603905  0.53057998  0.
  0.83773983 -0.00376193  0.          0.21223477  0.          0.
  0.07829399  0.11257213  0.        ]
max: 0.8377398272673146 arg: 24
mean: 0.037214150387226065
min: -0.8673973740711458 arg: 1
std: 0.33565097991082865


data_affinity/experiment_q00_raw.json
[[{'data': 'The variable can be changed(the pointer can change)', 'idx': 4}, {'data': 'The variable can be mutated simply by assigning something else to it.', 'idx': 5}, {'data': 'The variable is actually mutable, because it is not a constant and can be changed.', 'idx': 6}, {'data': 'It is mutable, since we can change the Object String to which the variable name points to, but not modifying the String itself.', 'idx': 7}, {'data': 'The variable is mutable, can change, no final for example.', 'idx': 32}], [{'data': "The variable is mutable (it's vaule can be changed) even if the String type its immutable", 'idx': 9}, {'data': "the variable is immutable because we can't change the object itself, but only the reference to the object", 'idx': 14}, {'data': "No, even if 'String' is immutable the variable name must be declared final to be immutable. This variable can be reassigned", 'idx': 17}], [{'data': 'Java strings are immutable, when you try to edit them a new String in created.', 'idx': 13}], [{'data': "The variable 'name' can be assigned and changed. It would need to be a final String to be immutable.", 'idx': 18}, {'data': 'Immutability implies that the variable cannot be reinitialized or modified after the first initialization. In this case name can be reinitialized multiple times, moreover the String object can also be modified in memory.', 'idx': 21}, {'data': "We need the final keyword to make this variable immutable, i.e. not change after it's been initialized. Right now, we could change its value as many time as we want.", 'idx': 24}, {'data': 'You can change the variable name for another string.', 'idx': 26}], [{'data': 'The object under name is immutable; the reference to it is mutable', 'idx': 30}], [{'data': 'It is not declared as final', 'idx': 1}, {'data': 'The variable name is not final, thus it is mutable', 'idx': 8}, {'data': 'it is not declared as final', 'idx': 10}], [{'data': "The final keyword is needed to make a Java variable final. However, since I do not see any code modifying the variable, I may be able to assume that it is 'effectively final'.", 'idx': 3}], [{'data': 'In order to be immutable it has to be declared as final. String object is immutable, not the variable.', 'idx': 11}, {'data': 'The variable is not declared as final. ', 'idx': 19}, {'data': "To be immutable the variable must be declared as 'final'", 'idx': 28}, {'data': 'String are immutable object in java but not the variable, it should be declared as final.', 'idx': 29}], [{'data': 'It is not marked final, therefore it is mutable. ', 'idx': 22}], [{'data': 'A variable can change his state many times. Only final variable can have 1 state ', 'idx': 33}], [{'data': 'if there is a final keyword it would be immutable', 'idx': 2}, {'data': "No. To be immutable, the keyword 'final' is needed (e.g. 'final String name;')", 'idx': 15}, {'data': 'Because it is missing the final keyword before the type', 'idx': 16}], [{'data': 'In Java, the ummutable variable should be with the key word `final`.', 'idx': 12}], [{'data': 'To be immutable should have final', 'idx': 20}, {'data': 'it requires the keyword final to be immutable.', 'idx': 23}, {'data': 'To make it immutable it should have the final keyword', 'idx': 25}, {'data': 'Its mutable. Final keyword is necessary for immutable variables', 'idx': 31}], [{'data': "the 'final' keyword needs to be used in java to make the variable immutable.", 'idx': 27}]]
silhouette scores
[ 3.71507181e-01 -5.91712412e-01  0.00000000e+00  5.02745441e-02
  1.12631601e-01  2.65100414e-01 -8.68733278e-02 -5.96258798e-01
 -4.77038195e-02  1.09727892e-01  4.67603844e-01  0.00000000e+00
  0.00000000e+00 -2.40949437e-01 -1.15630004e-01  1.95069637e-02
 -5.03003930e-01 -1.45788370e-01  7.48831768e-02  2.96335349e-01
 -1.82152331e-06  0.00000000e+00  3.68390796e-01 -3.15294917e-01
  4.57367068e-01 -8.71700888e-02  0.00000000e+00  2.34315541e-01
  1.91773130e-01  0.00000000e+00  2.05305486e-01 -1.45771411e-02
  0.00000000e+00]
max: 0.4676038435790632 arg: 10
mean: 0.014538149010525655
min: -0.5962587982203895 arg: 7
std: 0.2575022795102764


data_affinity/experiment_q01_clean_answers_full.json
[[{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}], [{'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}], [{'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'It is marked with keyword final.', 'idx': 56}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}]]
silhouette scores
[ 0.38214709 -0.41860103  0.17106825 -0.38698121 -0.26856728 -0.30927118
  0.02116454 -0.42928237  0.12829204  0.11770824  0.31418871  0.
 -0.57040643  0.04387614  0.24012263  0.         -0.28152569 -0.77839034
 -0.29913741  0.13762786  0.          0.05135956  0.02798107  0.08704833
  0.05552856  0.         -0.25669756  0.          0.04869239  0.09907732
  0.          0.          0.17968962]
max: 0.38214709365496835 arg: 0
mean: -0.05737236783507457
min: -0.778390336400028 arg: 17
std: 0.2567965675891725


data_affinity/experiment_q01_clean_answers_only_lemma.json
[[{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}], [{'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}], [{'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'It is marked with keyword final.', 'idx': 56}], [{'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}, {'data': 'final variable are immutable in java', 'idx': 67}]]
silhouette scores
[ 0.42176491  0.04696099  0.08008678  0.36186194 -0.13409911 -0.08386625
 -0.6633318  -0.37289228  0.06243321  0.          0.49914804  0.36373907
 -0.09994628  0.          0.13823509 -0.11135188  0.04622625  0.70193347
  0.44057975  0.32750812  0.          0.          0.12625871  0.11784697
 -0.31821367  0.63258612 -0.25828361  0.22987649  0.1740827  -0.25747757
  0.44910632  0.09972815  0.14431456]
max: 0.701933467985568 arg: 17
mean: 0.09590349033581917
min: -0.6633318039598965 arg: 6
std: 0.29237543500541197


data_affinity/experiment_q01_clean_answers_only_lowercase.json
[[{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'It is declared as final', 'idx': 35}], [{'data': 'Because it is declared as final', 'idx': 45}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': 'The variable is declared as final.', 'idx': 53}], [{'data': 'the variable is final', 'idx': 54}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}], [{'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}, {'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': 'It is marked with keyword final.', 'idx': 56}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}]]
silhouette scores
[ 0.          0.04887403 -0.1154835   0.         -0.26408465  0.
  0.20847343 -0.19098267 -0.12254623  0.18707747 -0.22698483  0.
  0.16467423 -0.63850105  0.         -0.57064484  0.18835313 -0.26981935
  0.02861889 -0.7351266   0.          0.         -0.3371567   0.
  0.          0.02336042  0.14454346 -0.25313276  0.         -0.18844185
  0.0659771  -0.0007718  -0.47001485]
max: 0.20847343049686973 arg: 6
mean: -0.10071937969063362
min: -0.7351266045084802 arg: 19
std: 0.2336850735909238


data_affinity/experiment_q01_clean_answers_only_stopwords.json
[[{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}, {'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': 'The variable is declared as final.', 'idx': 53}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'the variable is final', 'idx': 54}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}], [{'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}]]
silhouette scores
[ 0.69310763 -0.3055453   0.1404787  -0.43765188  0.         -0.64020851
  0.04941375 -0.38472382  0.08547136  0.02524952  0.55465648  0.01053381
 -0.48986258  0.04387614  0.06409749  0.51432517 -0.34249828 -0.74254037
  0.31784398 -0.64521901  0.12976498 -0.34866751 -0.00693107 -0.37472671
 -0.12808071  0.         -0.14468911  0.          0.1321134  -0.01237807
  0.          0.          0.24554276]
max: 0.6931076290414067 arg: 0
mean: -0.06052265885589414
min: -0.7425403650582568 arg: 17
std: 0.33169978559948754


data_affinity/experiment_q01_clean_answers_stopwords_lemma.json
[[{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'Because probability variable is declared with the final keyword', 'idx': 50}], [{'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': 'The variable is declared as final.', 'idx': 53}, {'data': 'the variable is final', 'idx': 54}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}], [{'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}], [{'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}], [{'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'It is marked with keyword final.', 'idx': 56}, {'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}], [{'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}]]
silhouette scores
[ 0.38214709 -0.4191981   0.17106825 -0.43765188  0.         -0.62887454
  0.02116454 -0.38531114  0.08547136  0.02524952  0.31418871  0.
 -0.53068477  0.04387614  0.06409749  0.         -0.28152569 -0.74254037
 -0.29913741  0.13762786  0.         -0.3183234   0.02798107 -0.43156069
 -0.11543679  0.         -0.26533484  0.          0.04869239  0.00570601
  0.          0.          0.24759313]
max: 0.38214709365496835 arg: 0
mean: -0.09941563688975608
min: -0.7425403650582568 arg: 17
std: 0.2657159921299325


data_affinity/experiment_q01_raw.json
[[{'data': 'Since it is declared final we cannot modify it.', 'idx': 41}, {'data': 'once assigned it cannot be reassigned or changed in any way', 'idx': 44}, {'data': 'Here it uses the `final` word so that it cannot be changed.', 'idx': 46}], [{'data': 'It is declared as final', 'idx': 35}, {'data': 'Because it is declared as final', 'idx': 45}], [{'data': 'This is immutable as the probability variable is final', 'idx': 40}, {'data': 'The variable is declared as final.', 'idx': 53}], [{'data': 'the variable is final', 'idx': 54}, {'data': 'the variable is defined as final, moreover the double type is not an heap object, implying that it will not be changed during runtime.', 'idx': 55}], [{'data': "Because the Math.random returns an integer which is stored in a variable declared with the label 'final'", 'idx': 62}], [{'data': 'Using Math.random() we obtain a random double value. Once assigned to the probability variable it can not be modified.', 'idx': 37}, {'data': 'Once assigned a random number, we cannot re-assign the variable.', 'idx': 49}, {'data': 'math.random() will generate a random number, which is stored in the immutable variable probability.', 'idx': 57}], [{'data': 'Once the variable is created it will receive a value from the random call and it will not be possible to change it at a later stage', 'idx': 38}], [{'data': "there's a final keyword so once assigned a value, it won't change", 'idx': 36}, {'data': 'The variable probability is final and thus we cannot change its value after assigning something to it.', 'idx': 42}, {'data': "The variable is immutable, it's value cannot be changed after this assignment.", 'idx': 43}], [{'data': "Final means that you can't change the reference of probability but it's actual value can change", 'idx': 47}], [{'data': "yes, the variable is immutable, this value can't be modified anymore", 'idx': 48}], [{'data': 'Yes, since it is declared final this variable cannot be changed', 'idx': 51}, {'data': "the variable is defined as final and can't be modified", 'idx': 52}, {'data': "As it is created as a final variable, it value can't be change after it's creation.", 'idx': 60}, {'data': 'The variable is final therefore cannot be changed.', 'idx': 63}, {'data': "The variable probability can't be changed after initialization", 'idx': 65}], [{'data': 'Once the variable has been assigned to for the first time it cannot be mutated due to the final keyword.', 'idx': 39}, {'data': 'Because probability variable is declared with the final keyword', 'idx': 50}, {'data': "As I said for option 1, probability cannot be changed after this point, i.e. we cannot reassign to it, so it's immutable (with the final keyword).", 'idx': 58}], [{'data': 'It is marked with keyword final.', 'idx': 56}], [{'data': "It is immutable as it starts with the keyword 'final'", 'idx': 59}, {'data': "since the final keyword is used, the variable 'probability' will be assigned to a random double and will not be subject to changes (will be immutable)", 'idx': 61}, {'data': 'The variable is immutable because of final keyword with assign', 'idx': 64}, {'data': 'final variable are immutable in java', 'idx': 67}], [{'data': 'there is a final, then also call method Math.random() is immutable.', 'idx': 66}]]
silhouette scores
[ 1.         -0.12401718 -0.0785813   0.         -0.06687938  0.38090402
 -0.28043696 -0.20577469 -0.23431702 -0.06091635  1.          0.21075682
  0.          0.          0.1844726  -0.27984241  0.07021968  0.340955
  0.06033376 -0.68845002 -0.01905667  0.         -0.04270543 -0.1900799
 -0.17662811 -0.01223863 -0.09943686  0.          0.31001643  0.10176628
  0.07117211  0.         -0.11543519]
max: 1.0 arg: 0
mean: 0.0319939583673711
min: -0.6884500162304903 arg: 19
std: 0.31511877277166295


data_affinity/experiment_q02_clean_answers_full.json
[[{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[-0.02257674  0.         -0.02655759  0.25233718  0.10488359 -0.42754092
 -0.15699076  0.26201002 -0.23752303 -0.16082463 -0.19853461 -0.23291249
  0.30871772  0.16532129  0.          0.         -0.41512165  0.
  0.3106084  -0.57368818 -0.12110446  0.08957082 -0.38096377 -0.20132515
  0.053853    0.         -0.51986506 -0.13923498  0.2879577   0.37361357
  0.          0.30199057  0.        ]
max: 0.3736135654314836 arg: 29
mean: -0.03951212656501768
min: -0.5736881823964746 arg: 19
std: 0.2468938828894224


data_affinity/experiment_q02_clean_answers_only_lemma.json
[[{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}], [{'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[ 0.87817718  0.00404322  0.20570154  0.92986635 -0.69546325  0.37863733
 -0.12662444  0.27334096  0.         -0.34398582  0.27449328 -0.27225786
 -0.40283177 -0.09143334 -0.60915512 -0.39797081  0.40711727 -0.43180439
 -0.3324547  -0.12915511  0.          0.         -0.47391554 -0.10439819
  0.10925872 -0.45123096 -0.61172149 -0.0112092   0.          0.
  0.31078197  0.          0.        ]
max: 0.9298663482023721 arg: 3
mean: -0.05194527743492648
min: -0.6954632480047596 arg: 4
std: 0.3764330276461654


data_affinity/experiment_q02_clean_answers_only_lowercase.json
[[{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}], [{'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}, {'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[-0.77599441 -0.40859476 -0.73061226  0.16180889 -0.3189997  -0.64247695
  0.38823271  0.24719862  0.          0.         -0.34400316  0.32052933
 -0.14111514  0.          0.          0.         -0.37318264 -0.30319219
  0.16892163 -0.58140246  0.          0.          0.         -0.7541879
  0.20061071  0.         -0.49927952  0.         -0.94987391 -0.04447013
  0.45889015  0.          0.        ]
max: 0.4588901470007914 arg: 30
mean: -0.14912706339040604
min: -0.9498739130208249 arg: 28
std: 0.3539160436959179


data_affinity/experiment_q02_clean_answers_only_stopwords.json
[[{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}], [{'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[-0.18117233  0.         -0.17261659  0.31980926  0.32094366 -0.45859507
  0.43725204  0.03194695 -0.28094006 -0.00829692 -0.10124323 -0.25273801
  0.27620795 -0.14822622  0.          0.         -0.43063327 -0.07376223
  0.15285694  0.53282292  0.          0.19372325 -0.09696253 -0.27045268
  0.24825454  0.         -0.55025892 -0.24553502  0.2879577   0.38455875
  0.          0.30199057  0.        ]
max: 0.5328229183282617 arg: 19
mean: 0.0065724677897035615
min: -0.5502589241997202 arg: 26
std: 0.2631576179759768


data_affinity/experiment_q02_clean_answers_stopwords_lemma.json
[[{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}], [{'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}], [{'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}, {'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}], [{'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}, {'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': 'Is wrong because s is declared as final too. ', 'idx': 101}]]
silhouette scores
[-0.02257674  0.         -0.02655759  0.27095942  0.10488359 -0.40157088
 -0.15699076  0.26201002 -0.24072431 -0.16082463 -0.19853461 -0.23291249
  0.25278732  0.16532129  0.          0.         -0.41512165  0.
  0.3106084  -0.57368818 -0.12110446  0.08957082 -0.38096377 -0.17879662
  0.053853    0.         -0.51986506 -0.13923498  0.2879577   0.37361357
  0.          0.30199057  0.        ]
max: 0.3736135654314836 arg: 29
mean: -0.03927003218317939
min: -0.5736881823964746 arg: 19
std: 0.24383128558261602


data_affinity/experiment_q02_raw.json
[[{'data': 'The object pointed to by variable s is shallowly immutable, because the Position object is mutable ', 'idx': 69}, {'data': 'The object is not immutable, the argument of sprite is immutable when passed to Sprite, the value of position inside of the newly created Sprite object is immutable, the variable s is immutable but it points to a mutable new Sprite object', 'idx': 72}, {'data': 'It is shallow immutable, since the element pointed by Position p (i.e. x and y) are mutable.', 'idx': 75}], [{'data': 'It is not deeply immutable. The reference of `s.position` is immutable but we still can change the deeper variables `x` and `y`, like s.position.x = 1;', 'idx': 80}], [{'data': 'it is wrong because in deep immutability every object are immutable, also the objects inside other objects. this is a case of shallow immutability.', 'idx': 82}, {'data': 's uses p which is of type Position. Position is not immutable because its field are accessible and mutable.', 'idx': 87}, {'data': 'It is not deeply immutable, because we create the object p and we pass it as s. Since Position is not immutable, then we can modify the values of x or y inside p, which modifies the values of s.position.x/y, since they are the same reference', 'idx': 93}], [{'data': 'Position fields are mutable, since java does not allocate objects inside objects', 'idx': 98}], [{'data': "It is shallow immutable. We can't modify the sprite object itself, but we can modify the Position object.", 'idx': 71}, {'data': 'The elements of Position are not immutable and Sprite contains a Position therefore it is shallow immutable.', 'idx': 73}, {'data': 'As the position p is a constant and it is creating a sprite with that position p it is deeply immutable', 'idx': 74}, {'data': 'Even though the pointer to Sprite and Position objects are immutable and the field of Sprite is immutable as well, the Position class is a mutable one and since Sprite uses it, it cannot be deeply immutable.', 'idx': 78}, {'data': "it's shallow immutable since Sprite points to mutable object Position", 'idx': 88}], [{'data': "An Object is deeply immutable if all its referred object are theirselves immutable. In this case the class Position is't immutable. Because it has public fields, it has to be final.", 'idx': 79}, {'data': 'Sprite is immutable and has no public fields', 'idx': 81}, {'data': 'to make it deeply immutable, we need to make x and y in class position private and final as well', 'idx': 91}], [{'data': 'The final keyword makes it impossible to reinitialize the p and s variables. The variables only contain the reference values to the objects, implying that the objects will still be modifiable. ', 'idx': 89}], [{'data': 'The class Position is not immutable because its fields can change once they have been initialised (they are even public!). However, here, we are creating a variable of time Position p that cannot be changed (because of the final keyword), i.e. we cannot reassign to p any other object of class Position. However, we could pass another object of type Position, with different values for x and y (than the values of x and y of p), to a Sprite object. Moreover, if p was not final, we could change the properties of p, after s has been initialised, and this would be reflected in s, so s is not deeply immutable.', 'idx': 92}], [{'data': 'No because the pointer to the Position object is final (therefore position cannot change the pointer), but the instance of object Position is not immutable, and so the x and y variable can change.', 'idx': 96}], [{'data': "The field position inside objects of class Sprite is indeed immutabile, but position's fields are not final (and thus not immutable). This means that the object pointed to by variable s is only shallowly immutable and not deeply immutable.", 'idx': 76}, {'data': 'Although the p passed as constructor argument is final, and the position field of the Sprite class is final too, we could still modify the x and y values. For example we could access p.x (public and mutable) and assing a new value to it.', 'idx': 77}, {'data': 'class should be marked as final to avoid override of methods by subclasses. ', 'idx': 90}, {'data': 'The object pointed to by variable s is an instance of the class Position (p) which is declared as final in the class Sprite.', 'idx': 95}, {'data': 'Is wrong because s is declared as final too. ', 'idx': 101}], [{'data': "Since x and y are not final, their value could still be changed if they could be accessed. The fact that the reference to an object is final doesn't mean that the referenced object is immutable.", 'idx': 86}], [{'data': "The sprite can be modified by modifying the p variable (e.g. p.x = 3;). The reference to the p reference it's final, not it's inner state.", 'idx': 83}, {'data': 'Because values x and y of Position object can be changed after the Sprite object construction. Like p.x = 100; after the last line of code', 'idx': 84}, {'data': "Yes, 's' it's itselfs final, so it's inmutable. Also, the Sprite attribute is inmutable and also the position p, so you wouldn't be able to change s or the attribute Position in it.", 'idx': 94}], [{'data': 'The reference object is final and we can also not change the final position of class sprite', 'idx': 97}], [{'data': "in Sprite position object is Final and also the call of s is final than can't mutate.", 'idx': 100}], [{'data': "it's a immutable object pointing to mutable object, even tho u can't change s, but u can change p.x and p.y", 'idx': 70}, {'data': 'No, to have deep immutability also the object p should be immutable. In our case p.x and p.y can be changed', 'idx': 85}, {'data': 'p as a field of s could change its field x and y,  so its not deeply immutable.', 'idx': 99}]]
silhouette scores
[ 0.37034152  0.1751298   0.55744979  0.0555051   0.43987739  0.2148558
  0.05860646 -0.30733587 -0.14417108  0.02560158 -0.37209561  0.
 -0.54284378 -0.23379047 -0.37306881 -0.28105761  0.05685584  0.
 -0.32225352  0.1552897   0.         -0.10263052 -0.14810872  0.
 -0.280895   -0.24319322 -0.14981611  0.          0.          0.
  0.24702354  0.          0.00161733]
max: 0.5574497913721308 arg: 2
mean: -0.03463958994295349
min: -0.5428437788495468 arg: 12
std: 0.23945562416441918


data_affinity/experiment_q03_clean_answers_full.json
[[{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[-0.45178405 -0.45069173 -0.09057969 -0.37701584 -0.5612654  -0.44747193
  0.         -0.17427177 -0.17738113 -0.41709063 -0.03475444 -0.14861928
  0.          0.          0.         -0.13156161 -0.04900102 -0.01248672
 -0.26349219  1.          0.         -0.14710822  0.         -0.19047837
  0.          0.         -0.03333436  0.09729825  1.          0.
  0.33638057  0.        ]
max: 1.0 arg: 19
mean: -0.05389717318623875
min: -0.5612653962000258 arg: 4
std: 0.33118687265783586


data_affinity/experiment_q03_clean_answers_only_lemma.json
[[{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}], [{'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Immutable object has no mutators', 'idx': 132}]]
silhouette scores
[ 0.65647836  0.53117737  0.19339358  0.16575391 -0.02158592  0.12594399
  0.60845947  0.66636166 -0.23017163 -0.2637195  -0.26467676 -0.05491509
 -0.09558759  0.17616955  0.00142118  0.          0.0090496  -0.38641737
 -0.58245173  0.522207    0.20111416  0.46598582 -0.0918355   0.
  0.18617182  0.         -0.1840356   0.11552333  0.68060005  0.
  0.42276005  0.        ]
max: 0.6806000487791938 arg: 28
mean: 0.11103669364365251
min: -0.5824517325238255 arg: 18
std: 0.3162775074566338


data_affinity/experiment_q03_clean_answers_only_lowercase.json
[[{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'There is no final keyword before class definition.', 'idx': 133}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}], [{'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}], [{'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}, {'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}]]
silhouette scores
[-0.04062491 -0.28150185  0.          0.00956465 -0.29379741  0.47057193
 -0.06003862  0.55777789  0.37390874 -0.45633469  0.31318489 -0.12004622
  0.44364169  0.28485229 -0.39619193 -0.36993296  0.22064794 -0.11560279
  0.13649415 -0.21602734  0.03019124 -0.2522464   0.         -0.13091528
  0.37694846 -0.00970535 -0.05029221  0.16834764 -0.36201337  0.
  0.14741628  0.57376704]
max: 0.5737670435039706 arg: 31
mean: 0.029751359304774544
min: -0.45633468725626514 arg: 9
std: 0.28347913206173214


data_affinity/experiment_q03_clean_answers_only_stopwords.json
[[{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[-0.21938617 -0.51479836 -0.05732339  0.         -0.50031539 -0.42501447
  0.11347687 -0.15971735 -0.48804398 -0.40780541 -0.17702248 -0.13496674
  0.          0.          0.         -0.17532945 -0.02081079 -0.26269339
 -0.34185919  1.          0.         -0.1435655   0.         -0.18887485
  0.          0.         -0.01813708  0.04836399  1.          0.
  0.31445797  0.        ]
max: 1.0 arg: 19
mean: -0.05498016083631732
min: -0.5147983605617342 arg: 1
std: 0.3315670014940375


data_affinity/experiment_q03_clean_answers_stopwords_lemma.json
[[{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}, {'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}], [{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}, {'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}], [{'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}], [{'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}], [{'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}], [{'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[-0.45178405 -0.47186296 -0.09057969 -0.37701584 -0.5612654  -0.42320571
  0.         -0.20341567 -0.17738113 -0.41709063 -0.03475444 -0.14861928
  0.          0.          0.         -0.13156161 -0.04900102 -0.01248672
 -0.26349219  1.          0.         -0.14710822  0.         -0.1659695
  0.          0.         -0.03333436  0.09729825  1.          0.
  0.33638057  0.        ]
max: 1.0 arg: 19
mean: -0.05394529992122394
min: -0.5612653962000258 arg: 4
std: 0.33121086875691175


data_affinity/experiment_q03_raw.json
[[{'data': 'Increment() could construct a new instance of Counter with the new value, but since it returns void it is not possible.', 'idx': 103}, {'data': 'Since it has a return type void. Which means we can modify the field counter, using the increment function.', 'idx': 109}], [{'data': "if the method could change the counter class, then it's not immutable", 'idx': 104}, {'data': 'If counter is immutable it will not allow for changes of values in the increment function resulting in a useless counter.', 'idx': 106}], [{'data': 'It cannot be used to increment the counter held in the current instance of an object of class Counter, as the class is immutable. What we could do is to return a new object of class Counter with the incremented value, but for doing that we would need a different signature for the increment method (specifically, a different return type)', 'idx': 110}], [{'data': 'If increment with void return type does increment the counter, it means it is modifying some value. To really be immutable, we would need an increment method that return a new Counter storing the new value.', 'idx': 111}, {'data': 'increment has to return a new Counter object if it modify the state. In this case increment is void so it is mutable. ', 'idx': 113}, {'data': 'increment is not void, because if we want to change an immutable object the only way is to returna another instance of the object. therefore increment will return a new instance of the counter, with the incremented value assigned.', 'idx': 116}], [{'data': 'We could do so by returning a new counter. However, by its signature, method increment seems to modify a field of Counter.', 'idx': 121}], [{'data': 'If class Counter is really immutable, then it should not be possible to modify its field.', 'idx': 123}], [{'data': 'because increment() has return type void and to be immutable should return some new value', 'idx': 122}, {'data': 'increment() should return a copy of Counter if we want Counter to be immutable. ', 'idx': 124}, {'data': 'The return type of incremental is void, if it is immutable should return the counter instead of void', 'idx': 131}], [{'data': "If the class counter is inmutable, their attributes should be inmutable aswell, so the method increment() wouldn't be able to modify this finals attributes.", 'idx': 128}], [{'data': "We don't know enough of its implementation, e.g. Counter may have a public field counter and therefore being mutable.", 'idx': 115}], [{'data': "If the class Counter is immutable, it can't have a mutable variable like counter", 'idx': 118}, {'data': 'If you can increment the counter, it implies that the counter is actually mutable. Also nothing in the Counter definition says it is immutable.', 'idx': 120}, {'data': 'for a class to be immutable, we need to declare it as final, make fields private and final and cloning objects if we want to perform some type of modification. In this case we have a public method that increments a counter variable, which means the class is mutable.', 'idx': 125}], [{'data': "There's no way of knowing that this class Counter is or not immutable without knowing how the properties of this class have been defined and how the increment method works. Apparently, it doesn't return anything, so I suppose it will make counter mutable, so it's true that the increment method could be used to increment the counter (which is the 'correct' part of this option), but I will mark this option as WRONG, because we probably would need to return something from increment to make this class immutable.", 'idx': 126}, {'data': 'class Counter is mutable. The only immutable classes in Java are the classes of primitive types, i.e. Integer, Double', 'idx': 129}, {'data': "The class Counter is not immutable. It doesn't declared as final class", 'idx': 135}], [{'data': 'Immutable object has no mutators', 'idx': 132}], [{'data': 'The increment function changes the state of the object, as opposed to making a new copy of it. It is not immutable.', 'idx': 105}, {'data': 'Since the class let the increment method public, anyone can alter the state of the class by invoking the increment method.', 'idx': 117}, {'data': 'No, to be immutable the increment method should return a new object when the state is changed', 'idx': 119}], [{'data': 'This is not immutable because class Counter is not final and thus can be extended. To fix this, one would need to change the signature of increment to return an object of type Counter instead of not returning anything.', 'idx': 107}, {'data': 'As the increment method can be used to increment the counter it is mutable.', 'idx': 108}, {'data': 'the method increment which changes the state of the object cannot return void as it implies a side effect mutating the internal state, rather than creating a new Counter with the updated field and returning it. Moreover the class could be further extended.', 'idx': 112}, {'data': 'No, it does not contain a keyword final. also in order to increase the counter, in the method `increment` it should return a new Counter instance and in its constructer function input the current value.', 'idx': 114}, {'data': 'Assuming that increment modifies the counter, then it is for sure not immutable. However, assuming that it does not modify the counter but it returns a new Counter, it would theoretically be immutable but the class is not declared as final, thus it could be extended by another class which have mutable fields.', 'idx': 127}], [{'data': "No because the definition of of an immutable class requires that the class is labeled with 'final' (in this way no one can create subclasses of that class).", 'idx': 130}, {'data': 'There is no final keyword before class definition.', 'idx': 133}]]
silhouette scores
[-0.41752064  0.20347381  0.00891054  0.45198608 -0.34485945 -0.503999
 -0.51316096  0.         -0.57526745 -0.32946093  0.43550541 -0.23366221
  0.          0.30644889 -0.23588852  0.4305647  -0.02454094  0.27117672
  0.         -0.28088968  0.          0.36964998 -0.07390464 -0.47193742
  0.06922872  0.         -0.31725036  0.23668805  0.6538549   0.
  0.50724882 -0.35821661]
max: 0.653854896799897 arg: 28
mean: -0.022994443870403107
min: -0.5752674539437516 arg: 8
std: 0.3331013394413614


data_affinity/experiment_q04_clean_answers_full.json
[[{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'because it has side effect with print', 'idx': 138}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}], [{'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}], [{'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.30587563  0.          0.51701993  0.04846839  0.7719218   0.12250597
 -0.14920553 -0.08964526  0.02141922 -0.28460072  0.32191149 -0.00987854
 -0.78487469 -0.48322722  0.         -0.18571132  0.         -0.67396128
 -0.45010183 -0.76505266  0.          0.16217885  0.          0.
  0.          0.2217363   0.          0.          0.14269548 -0.32315038
  0.16435211 -0.21114193  0.51918143]
max: 0.7719217973377241 arg: 4
mean: -0.03306923510291657
min: -0.7848746861003378 arg: 12
std: 0.3402773736725014


data_affinity/experiment_q04_clean_answers_only_lemma.json
[[{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}], [{'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'because it has side effect with print', 'idx': 138}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}], [{'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}]]
silhouette scores
[-0.17269251  0.          0.62812634  0.15789222  0.39873867 -0.04826794
  0.         -0.15462023 -0.28432021  0.          0.32402635 -0.11480053
 -0.4547226  -0.24443063 -0.66158265 -0.3432104   0.         -0.60098676
 -0.09720876 -0.61588554  0.          0.1611754  -0.29964     0.
 -0.47880731 -0.05761809  0.          0.          0.          0.34203622
  0.         -0.2226182   0.        ]
max: 0.6281263427980649 arg: 2
mean: -0.0860429438522522
min: -0.6615826502009876 arg: 14
std: 0.28476798857913466


data_affinity/experiment_q04_clean_answers_only_lowercase.json
[[{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}], [{'data': 'it prints on the output', 'idx': 156}], [{'data': 'It produces a side effect.', 'idx': 158}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}], [{'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'probably create side effect then is not pure', 'idx': 168}]]
silhouette scores
[ 0.          0.61434759  0.14538989  0.08518777  0.13906514  0.23773565
  0.34607223  0.          0.          0.37206908  0.53065174  0.
  0.          0.0079919  -0.50204194  0.14955895  0.         -0.59331902
  0.04255409  0.         -0.32091496  0.          0.51914514  0.17327167
 -0.5328889  -0.32441609 -0.16227054  0.          0.30143447 -0.08440621
 -0.47391078 -0.35152419 -0.41656549]
max: 0.6143475864781491 arg: 1
mean: -0.002963115595838136
min: -0.5933190226370902 arg: 17
std: 0.3058638292680564


data_affinity/experiment_q04_clean_answers_only_stopwords.json
[[{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}], [{'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}], [{'data': 'because it has side effect with print', 'idx': 138}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}], [{'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}, {'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.         -0.60627462  0.63027495 -0.28836095  0.73869437 -0.30277997
 -0.18491696  0.2782797   0.41003779 -0.02625139  0.50352018  0.12744497
  0.27363975  0.          0.39423895  0.4483917  -0.36272921  0.36766766
  0.         -0.38941311  0.09567806  0.09510423 -0.52573983  0.
  0.10121022 -0.42765278  0.24306321  0.          0.26395592  0.12482952
  0.          0.          0.16626698]
max: 0.7386943695307914 arg: 4
mean: 0.06509634336175045
min: -0.6062746243127334 arg: 1
std: 0.32122714146118103


data_affinity/experiment_q04_clean_answers_stopwords_lemma.json
[[{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}], [{'data': 'because it has side effect with print', 'idx': 138}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': 'it prints on the output', 'idx': 156}], [{'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}], [{'data': 'It is not pure as it prints something to the standard output', 'idx': 161}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}], [{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}], [{'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}]]
silhouette scores
[ 0.30587563  0.          0.51701993  0.04846839  0.7719218   0.12250597
 -0.14920553 -0.08964526  0.02141922 -0.28460072  0.32191149 -0.00987854
 -0.78487469 -0.48322722  0.         -0.18571132  0.         -0.67396128
 -0.45010183 -0.76505266  0.          0.16217885  0.          0.
  0.          0.2217363   0.          0.          0.14269548 -0.32315038
  0.16435211 -0.21114193  0.51918143]
max: 0.7719217973377241 arg: 4
mean: -0.03306923510291657
min: -0.7848746861003378 arg: 12
std: 0.3402773736725014


data_affinity/experiment_q04_raw.json
[[{'data': "It has a side effect: it affects the program's output.", 'idx': 137}, {'data': 'It produces a side effect.', 'idx': 158}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 163}, {'data': 'It results system output, which is a side-effect.', 'idx': 167}], [{'data': 'It is impure because it uses the IO. IO is a side-effect.', 'idx': 139}, {'data': 'This is impure since it does IO and therefore has side effects.', 'idx': 141}, {'data': 'Because inside there is an IO action. This is a side effect', 'idx': 147}, {'data': 'This method `say` has IO action, which is a kind of side effect.', 'idx': 148}, {'data': 'The method is performing IO, modifying the global state of the program. ', 'idx': 157}], [{'data': 'Since say(String text) deals with an IO operation which is clearly impure.', 'idx': 143}, {'data': 'Method say does I/O (specifically, outputs a string). I/O operations are impure, thus the method is not pure.', 'idx': 144}, {'data': 'The method say is not pure since it is doing an IO operation.', 'idx': 145}, {'data': 'Pure methods does not allow IO. Say is printing the text.', 'idx': 149}, {'data': 'It writes to the standard output, i.e. it does IO, so it cannot be pure, given that it interacts with the output (of the function) world, by definition.', 'idx': 160}], [{'data': 'since void say(String text) uses I/O operations it implies that it has side-effects which make it non-pure', 'idx': 146}], [{'data': 'say method is not pure because it have side effects: print variable text', 'idx': 152}, {'data': 'The method is impure because it prints, thus producing a side effect.', 'idx': 155}, {'data': 'This method has a side effect that is a screen print, so it cannot be consider a pure method.', 'idx': 162}], [{'data': 'No, because it performs an output operations (print a text)', 'idx': 164}], [{'data': 'Method say is not pure as it has IO side effect, it print to the console.', 'idx': 165}, {'data': 'Method say has side effect', 'idx': 166}, {'data': 'Pure functions have no side effect. Method say print text variable that is a side effect (IO)', 'idx': 169}], [{'data': 'because it has side effect with print', 'idx': 138}], [{'data': 'The method say is not pure because it can accesses System.out to print', 'idx': 140}, {'data': 'It is using another method (System.out.println(text)) so it is not pure.', 'idx': 142}, {'data': 'No, is not pure because there is an output to the terminal, there is a side effect', 'idx': 150}], [{'data': 'it output something on the system and that makes a function impure (accessing I/O).', 'idx': 153}], [{'data': "Pure functions don't have side effects, including IO (println does IO)", 'idx': 151}, {'data': 'System.out.println() has a side effect (it outputs something). A pure function has no side effects, so say() is not pure.', 'idx': 154}, {'data': "println causes a side effect, which means say it's not pure.", 'idx': 159}, {'data': 'It is not pure as it prints something to the standard output', 'idx': 161}, {'data': 'probably create side effect then is not pure', 'idx': 168}], [{'data': 'it prints on the output', 'idx': 156}]]
silhouette scores
[ 0.3910586   0.          0.57863681  0.24528522  0.34978962  0.12058936
 -0.13631028 -0.27383997  0.03267704  0.          0.3980357   0.07515418
 -0.08633126 -0.23607786 -0.08098848  0.13518814  0.          0.06584056
 -0.35692598  0.          0.08619858 -0.0417103   0.11533719 -0.00345723
 -0.25798303  0.06341471 -0.20340713  0.          0.15365907 -0.06090746
  0.26492435  0.12651518  0.06795021]
max: 0.5786368100011808 arg: 2
mean: 0.04643380430616629
min: -0.3569259847207297 arg: 18
std: 0.20186174695555423


data_affinity/experiment_q05_clean_answers_full.json
[[{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}], [{'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}], [{'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.31939352  0.          0.30848456 -0.30238811 -0.17316991 -0.18946315
  0.         -0.35405533  0.          0.39606811 -0.0323675  -0.2175267
 -0.02846848 -0.39141623 -0.15892807  0.20196427  0.16197505  0.
  0.          0.2152698   0.          0.29547476 -0.43934762  0.
 -0.1867818  -0.26662439 -0.12763074 -0.59116608  0.20829365 -0.29037868
  0.11941519  0.01353415 -0.61259653]
max: 0.39606810805541265 arg: 9
mean: -0.06431624985405875
min: -0.6125965253198191 arg: 32
std: 0.25290561474058254


data_affinity/experiment_q05_clean_answers_only_lemma.json
[[{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}], [{'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}], [{'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}], [{'data': 'the function has no side effects', 'idx': 190}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}]]
silhouette scores
[-0.64479342  0.          0.54773456 -0.21308738 -0.30633421  0.
 -0.075702   -0.18760226  0.          0.50495466  0.04277322  0.16046019
  0.          0.         -0.18976067  0.25085834 -0.27277243  0.11409968
 -0.03743961  0.16892018  0.          0.20095225 -0.47849881 -0.25166482
 -0.27526414  0.38550531 -0.38329094 -0.12558879  0.          0.08912261
  0.          0.          0.11592232]
max: 0.5477345551212468 arg: 2
mean: -0.026075641516865183
min: -0.644793422736313 arg: 0
std: 0.253071353925136


data_affinity/experiment_q05_clean_answers_only_lowercase.json
[[{'data': 'It has no side effects. ', 'idx': 171}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'there is no external neither IO', 'idx': 199}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}], [{'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}], [{'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}], [{'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}], [{'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'No side effects; depends on input, returns output', 'idx': 200}]]
silhouette scores
[ 1.          0.         -0.18626119 -0.61178347  0.26229381  0.07023607
 -0.30990028  0.01033358 -0.26312317  0.          0.33854483 -0.3121043
  0.          0.         -0.48187326 -0.56182983 -0.74866284  0.64820112
 -0.34537782  1.          0.          0.          0.          0.
 -0.27366953  0.20927249  0.          0.72291586  0.          0.
 -0.72315928  0.          0.        ]
max: 1.0 arg: 0
mean: -0.016846885383570605
min: -0.7486628400698917 arg: 16
std: 0.41424614749419186


data_affinity/experiment_q05_clean_answers_only_stopwords.json
[[{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'The method does not modify anything outside its local scope.', 'idx': 179}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}], [{'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}], [{'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}], [{'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}, {'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.22260753  0.246708    0.58946871 -0.43715362 -0.05570374  0.
  0.          0.32537782  0.04206339  0.7361852  -0.0917684  -0.07841222
  0.21864362 -0.02337146 -0.24295457  0.00088301 -0.18562925 -0.48372902
 -0.33414042  0.38892019  0.          0.39725233 -0.5009824   0.
 -0.30935937 -0.32243186 -0.19448271  0.          0.22135469 -0.00945053
  0.05235369  0.         -0.18567213]
max: 0.7361852044129357 arg: 9
mean: -0.00040677252085182767
min: -0.5009824031621085 arg: 22
std: 0.2853809489821516


data_affinity/experiment_q05_clean_answers_stopwords_lemma.json
[[{'data': 'It has no side effects. ', 'idx': 171}, {'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}, {'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'the function has no side effects', 'idx': 190}, {'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}], [{'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}], [{'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}], [{'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}, {'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}], [{'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}], [{'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}], [{'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}, {'data': 'No side effects; depends on input, returns output', 'idx': 200}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}, {'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}, {'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.31939352  0.          0.30848456 -0.30238811 -0.17316991 -0.18566203
  0.         -0.35580623  0.          0.39606811 -0.0323675  -0.2175267
 -0.0540897  -0.39141623 -0.15892807  0.20196427  0.16197505  0.
  0.          0.2152698   0.          0.29547476 -0.43315912  0.
 -0.17796886 -0.26662439 -0.12763074 -0.59116608  0.20557922 -0.29037868
  0.11941519  0.01353415 -0.61259653]
max: 0.39606810805541265 arg: 9
mean: -0.0646581889778953
min: -0.6125965253198191 arg: 32
std: 0.2523502065081429


data_affinity/experiment_q05_raw.json
[[{'data': 'It is directly equiavalent to a functional mapping. It always produces the same output for the same input, without any side-effects.', 'idx': 173}, {'data': 'the function maps always the same result to the same inputs without having any side-effects', 'idx': 180}, {'data': 'Yes. The method has no side effects. It works just like a mathematical function (i.e. 2*x). Invoking twice(10) multiple times will always produce the same output.', 'idx': 185}, {'data': 'the function has no side effects', 'idx': 190}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 179}], [{'data': "The method twice is pure because it doesn't change any variable value outside of it's scope. It also benefits of idempotency(if called more than once subsequently it will continue to return the same value)", 'idx': 174}, {'data': 'As v is declared in the parameters and it always will give the same output aslong as the value of v is the same it is pure.', 'idx': 176}, {'data': 'Method twice only uses its argument, does not access/modify external state, does not perform I/O and thus it is pure', 'idx': 178}], [{'data': "Since it just return a new value, and we don't modify the parameter passed to the function.", 'idx': 177}], [{'data': 'Yes this method is pure, it does not affect the state or do the IO action.', 'idx': 182}], [{'data': "yes, is pure, we don't have any kind of side effect", 'idx': 184}], [{'data': 'twice is not accessing global variables and not doing IO. All it uses is received as an argument and all it produces comes from the return statement. Therefore twice is idempotent and pure.', 'idx': 183}, {'data': 'twice is pure because it does not have side effects, it simply take an argument and return an output without modifying the passed argument', 'idx': 186}, {'data': "The method is pure because it doesn't access any internal field and only works with the given argument, without producing any side effect.", 'idx': 189}], [{'data': "it's taking a parameter v (defined nowhere else) and returning twice its value, which is completely fine. twice is pure.", 'idx': 193}, {'data': "twice is idempotent, i.e. it always returns the same output value given the same input value (assuming the compiler produces deterministic code). Moreover, it doesn't interact with the outside world, apart from just getting and returning a value. No side effects.", 'idx': 194}, {'data': "This method is pure because it has no side effects. It takes the input and returns an output without reading or writing any memory from outside it or other side effects. We could replace it by it's value after call it and is idempotent.", 'idx': 196}], [{'data': 'Yes it is pure, as it returns something based only on its input parameters and calling it more than once with the same argument will always produce the same result, without modifying the state of the program', 'idx': 195}, {'data': 'Because the function does not alter the state of the program - it just takes an argument and produces an output using that argument.', 'idx': 197}, {'data': 'take an imputes and return an output without change the variable x', 'idx': 202}], [{'data': 'It has no side effects. ', 'idx': 171}], [{'data': "This is correct because the method is idempotent, has no side effects and doesn't access non-local variables.", 'idx': 175}, {'data': "Because it hasn't side effect. It is also idempotent. It only use the given parameter and return an elaboration of that value.", 'idx': 181}, {'data': "It's referentially transparent, has no side effects and is idempotent.", 'idx': 188}], [{'data': 'It is referentially transparent, idempotent and does not have side effects. It does not access any state in the memory, it simply take an integer in the input and returns the input values times two. If we recall the function with the same input we obtain always the same result.', 'idx': 198}], [{'data': 'It doesnt produce any side-effect and the result is deterministic', 'idx': 201}], [{'data': 'The function depends only on the argument `v`.', 'idx': 191}], [{'data': 'nothing change and also no side effect when method twice is called, v is only effected inside the method', 'idx': 172}, {'data': "'twice' has no side effect and is idempotent. It always perform the same action with the same input without having any side effect", 'idx': 187}, {'data': 'The output of twice depends only on the input argument v and does not have side effects.', 'idx': 192}], [{'data': 'No side effects; depends on input, returns output', 'idx': 200}], [{'data': 'Method twice has no side-effect and the result is the same if you call the method multiple times with the same input', 'idx': 203}], [{'data': 'there is no external neither IO', 'idx': 199}]]
silhouette scores
[ 0.         -0.30709045  0.37239152 -0.36597896  0.10031469 -0.27021249
  0.         -0.56026991  0.          0.11277895  0.09747929  0.
  0.1314947   0.         -0.21329101 -0.11867867 -0.51075762 -0.34580793
  0.03160964 -0.07439725  0.         -0.00566129 -0.28873631 -0.24526693
 -0.40453385 -0.2519274   0.07186259  0.          0.          0.
  0.         -0.16545417  0.        ]
max: 0.3723915159268559 arg: 2
mean: -0.09727675303078939
min: -0.5602699051297304 arg: 7
std: 0.20157868253296116


data_affinity/experiment_q06_clean_answers_full.json
[[{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}], [{'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'return a non-local variable', 'idx': 226}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}], [{'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.         -0.43024186  0.19602719  0.26096943  0.         -0.11596479
  0.42693916  0.24346426  0.         -0.12711873  0.04127111 -0.36783866
 -0.29236169  0.42935659  0.44499311 -0.51428254  0.         -0.53226217
 -0.04865858  0.          0.09597684  0.         -0.35991717  0.01619032
 -0.05324835  0.         -0.23645631  0.          0.01259882  0.29372779
  0.         -0.53359948 -0.43017555]
max: 0.44499311293738714 arg: 14
mean: -0.047897310685267445
min: -0.5335994806084586 arg: 31
std: 0.26945927346626436


data_affinity/experiment_q06_clean_answers_only_lemma.json
[[{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}], [{'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}], [{'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}]]
silhouette scores
[ 0.56610495 -0.36810403  0.         -0.02330711  0.23904142  0.21174138
 -0.3098874   0.32266919  0.         -0.09846093  0.16220788  0.
 -0.22143703  0.50635547  0.38515523  0.76035896  0.53483147 -0.59909778
  0.14463668  0.41926191 -0.13085193 -0.03337104 -0.43536495 -0.34064619
  0.24995358  0.          0.         -0.327678   -0.30468645  0.19308737
  0.         -0.25651087 -0.01643987]
max: 0.7603589558056177 arg: 15
mean: 0.03725945172157088
min: -0.5990977803648782 arg: 17
std: 0.3168150644314802


data_affinity/experiment_q06_clean_answers_only_lowercase.json
[[{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}], [{'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}], [{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}], [{'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}], [{'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}], [{'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}], [{'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'It depends on the current state of the object.', 'idx': 225}], [{'data': 'return a non-local variable', 'idx': 226}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[-0.05098283  0.          0.         -0.34989407  0.23055341 -0.25772969
 -0.12364839 -0.30374858  0.1292448   0.26990114  0.          0.
 -0.12891002 -0.40033762 -0.34626329  0.          0.07243522  0.
 -0.47951799  0.04678684  0.          0.          0.22945986  0.099023
  0.09676568  0.44137833  0.2149446  -0.00594535  0.05741546 -0.38356275
  0.          0.24861334 -0.32810056]
max: 0.4413783252906241 arg: 25
mean: -0.030973316327004466
min: -0.4795179858480819 arg: 18
std: 0.21860137908853228


data_affinity/experiment_q06_clean_answers_only_stopwords.json
[[{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': 'return a non-local variable', 'idx': 226}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}], [{'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}], [{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}], [{'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}, {'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'It depends on the current state of the object.', 'idx': 225}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}]]
silhouette scores
[ 0.         -0.63483406  0.17533395  0.          0.          0.34810612
  0.54106434  0.56439183 -0.09653819 -0.0335938   0.22486782 -0.27947149
 -0.28212796  0.41690023  0.38698695  0.80118108  0.         -0.56154209
 -0.15112972  0.16261089  0.         -0.2088753  -0.27043686 -0.206461
  0.32416025 -0.16317487 -0.37809947  0.08798662 -0.37799775  0.
  0.0380343  -0.32079983 -0.4072071 ]
max: 0.8011810771311358 arg: 15
mean: -0.00911106366459724
min: -0.6348340577809977 arg: 1
std: 0.32877746475948816


data_affinity/experiment_q06_clean_answers_stopwords_lemma.json
[[{'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}, {'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}], [{'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}], [{'data': 'it returns a field of the class which can change', 'idx': 224}], [{'data': 'return a non-local variable', 'idx': 226}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}], [{'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}, {'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}], [{'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'It accesses memory state.', 'idx': 235}]]
silhouette scores
[ 0.         -0.43024186  0.19602719  0.26096943  0.         -0.11596479
  0.42693916  0.24346426  0.         -0.12711873  0.04127111 -0.36783866
 -0.29236169  0.42935659  0.44499311 -0.51428254  0.         -0.53226217
 -0.04865858  0.          0.09597684  0.         -0.35991717  0.01619032
 -0.05324835  0.         -0.23645631  0.          0.01259882  0.29372779
  0.         -0.53359948 -0.43017555]
max: 0.44499311293738714 arg: 14
mean: -0.047897310685267445
min: -0.5335994806084586 arg: 31
std: 0.26945927346626436


data_affinity/experiment_q06_raw.json
[[{'data': 'it depends on the state of Pacman and in particular to a non final field, which could change at any point in the execution. Successive calls are not guaranteed to return the same value.', 'idx': 214}, {'data': 'no, is not pure, if we return x it is possible to change the state of pacman, and this is a side effect', 'idx': 218}, {'data': 'The method is not pure as it returns a variable of PacMan which might change over time. Calling the getX() method in different lines of the code might produce different results.', 'idx': 219}, {'data': 'its returning the value of global variable x, which means there could be a side effect when the value of x changes. getX is not pure.', 'idx': 227}, {'data': 'It is not pure as it accesses and returns a field inside Pacman (x) which could change over time, as it is not immutable', 'idx': 229}], [{'data': "It has a side effect: it returns part of the program's state, namely the instance variable x", 'idx': 205}, {'data': "it has no side effect and it always return the variable 'x' without any side effect", 'idx': 221}, {'data': 'No because the function access a state in the memory. The variable x can be modified and if we invoke the function again we cannot guarantee that the result will be the same.', 'idx': 232}, {'data': 'does not take any input but not change the variable x as output.', 'idx': 236}], [{'data': 'The method does not modify anything outside its local scope.', 'idx': 213}], [{'data': 'This is not pure as it is getting the variable x which is declared outside of the scope of the function.', 'idx': 210}, {'data': 'Method getX accesses the external state to retrieve the value of field x, thus it is not pure', 'idx': 212}, {'data': 'getX is not pure because it accesses an external variable x', 'idx': 220}], [{'data': "It accesses a variable outside of it's state/scope, making it not pure.", 'idx': 222}, {'data': 'The method is not pure because it returns a modifiable field.', 'idx': 223}, {'data': 'It is not pure as return an external variable x that is not defined as it own argument.', 'idx': 233}], [{'data': "This method reads memory from outside the function, so it can't be pure.", 'idx': 230}], [{'data': 'It accesses memory state.', 'idx': 235}], [{'data': 'The result of the function depends on the state of the Pacman object, that is, its value of x.', 'idx': 207}, {'data': 'It depends on the current state of the object.', 'idx': 225}, {'data': 'getX has implicit this arg; the result depends on it', 'idx': 234}], [{'data': 'This is wrong since we acess non-local variables in the method.', 'idx': 209}, {'data': 'Since it return an object field, that is a modifiable variable.', 'idx': 211}, {'data': 'Because it returns a variable declared outside of the function.', 'idx': 215}, {'data': 'return a non-local variable', 'idx': 226}, {'data': 'The method getX returns a value that is not directly related to the input passed but depends on setX calls. Using local variables in this way is considered a side-effect', 'idx': 237}], [{'data': 'x is outside the method, so when u call the method, it will change the state of the class', 'idx': 206}, {'data': "The method get x is pure because even if it accesses a variable outside of it's scope it doesn't change its value or state, it also benefits of idempotency(if called twice it will return the same result)", 'idx': 208}, {'data': "getX is accessing x from the Pacman's scope, therefore the value of x can change overtime (e.g. a call of setX). Pure functions are idempotent and because of what said getX is not. So getX is not pure.", 'idx': 217}], [{'data': "It does not affect the `x`, just read and return. And also this function is idempotent if we don't invoke `setX`.", 'idx': 216}], [{'data': 'it returns a field of the class which can change', 'idx': 224}, {'data': "The property x of this class can change because there's the method setX, so calling x multiple times can return different values, i.e. getX is not idempotent, which makes it impure.", 'idx': 228}], [{'data': 'The global variable x may be subject to changes as the program proceeds which makes it impure.', 'idx': 231}]]
silhouette scores
[ 0.11552588 -0.34094956 -0.0438612  -0.03924254  0.15244351  0.08933627
  0.08129403  0.2409013   0.          0.1574751   0.07146285  0.
 -0.21825318  0.510546    0.34891517  0.72724433  0.26357    -0.56296864
  0.06054721  0.46125089  0.40925315  0.3486268  -0.4728699  -0.31712071
  0.2729416   0.          0.         -0.09030833 -0.40854442 -0.01987057
  0.          0.03083529  0.08612576]
max: 0.7272443263942092 arg: 15
mean: 0.05800927508153719
min: -0.5629686407284452 arg: 17
std: 0.2796664893659151


data_affinity/experiment_q07_clean_answers_full.json
[[{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'it should be f()(1)', 'idx': 292}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}], [{'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'return another function', 'idx': 304}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[ 0.26048405 -0.08784993  0.         -0.14192524  0.          0.
  0.          0.25052385 -0.0861381  -0.01950704 -0.10788319 -0.27408112
 -0.29869715 -0.48121614  0.         -0.09441669 -0.43897974 -0.20284473
  0.         -0.12472443  0.03318969 -0.08123131  0.          0.
  0.04617059  0.19687927 -0.11672243 -0.10625803  0.          0.
  0.38173248  0.         -0.46811625]
max: 0.38173248136509214 arg: 30
mean: -0.05944277566764657
min: -0.48121614454221595 arg: 13
std: 0.18699375648647928


data_affinity/experiment_q07_clean_answers_only_lemma.json
[[{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}, {'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'return another function', 'idx': 304}], [{'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[-0.71332217 -0.1420593   0.          0.03514111  0.40372375  0.
 -0.15754146  0.07776387  0.37498992 -0.11775344 -0.79706211  0.44566757
  0.05967469  0.61963637 -0.03139353  0.17860489 -1.         -0.26520757
  0.          0.         -0.05198256  0.         -0.21202587  0.18895934
  0.15457108  0.1258613   0.71272654  0.20114746  0.          0.
  0.28098795  0.          0.        ]
max: 0.7127265440936459 arg: 26
mean: 0.011245692365547023
min: -1.0 arg: 16
std: 0.34595329630927873


data_affinity/experiment_q07_clean_answers_only_lowercase.json
[[{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}], [{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}], [{'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}], [{'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}], [{'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'It returns the wrapped function', 'idx': 301}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'This will return a function(x) but not 2', 'idx': 278}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}], [{'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}], [{'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}, {'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'return another function', 'idx': 304}]]
silhouette scores
[-0.60024396  0.         -0.13807463 -0.2584217   0.4173163  -0.07646006
 -0.25540914 -0.30538782 -0.30929497  0.40997522 -0.5434668   0.
 -0.0477339  -0.2724793   0.         -0.56779641  0.35266564  0.
  0.          0.          0.13763284 -0.33452063 -0.53671908 -0.48939296
 -0.2224955   0.          0.43452596 -0.45466458 -0.17795195  0.
  0.         -0.19743097  0.44294456]
max: 0.44294455784783976 arg: 32
mean: -0.10887526758833611
min: -0.6002439574135209 arg: 0
std: 0.2936782665236453


data_affinity/experiment_q07_clean_answers_only_stopwords.json
[[{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}], [{'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}], [{'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'return another function', 'idx': 304}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[-0.61837042 -0.06145201 -0.18860409  0.         -0.12082581  0.
 -0.09432808 -0.05715902 -0.63818664 -0.02570955 -1.          0.
 -0.17698937 -0.31115036  0.         -0.04374029 -0.98380889 -0.22959251
  0.          0.32539437  0.11203953  0.          0.          0.
  0.          0.19687927 -0.18001075 -0.27337021  0.         -0.26195962
  0.40023029  0.          0.        ]
max: 0.40023029338661303 arg: 30
mean: -0.1282034590552358
min: -1.0 arg: 10
std: 0.2993846383095032


data_affinity/experiment_q07_clean_answers_stopwords_lemma.json
[[{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}, {'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}], [{'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}], [{'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}, {'data': 'it should be f()(1)', 'idx': 292}], [{'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}], [{'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}, {'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'return another function', 'idx': 304}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[-0.61987143 -0.08784993 -0.18860409  0.         -0.1072777   0.
 -0.11876202 -0.03073801 -0.65571189 -0.02699598 -1.          0.
 -0.20205036 -0.32385166  0.          0.04999604 -0.98380889 -0.20284473
  0.          0.32539437  0.22327575  0.          0.          0.
  0.          0.19687927 -0.16145752 -0.27337021  0.         -0.19500863
  0.38173248  0.          0.        ]
max: 0.38173248136509214 arg: 30
mean: -0.12124015589481177
min: -1.0 arg: 10
std: 0.30331372610517027


data_affinity/experiment_q07_raw.json
[[{'data': "The function f takes no arguments, so the '1' will be ignored by JS and the inner anonymous function will be returned in the same way as just calling f()", 'idx': 281}, {'data': 'Calling f(1) will return a function taking another argument which will be increased by one. So f1 will return a Function.', 'idx': 285}, {'data': "f does not accept any parameter, but the function it returns accepts it. So, calling f(1) should produce an error in any decent language, but not in JS, because JS doesn't protect the programmer (usually). In any case, calling f will return a function.", 'idx': 296}, {'data': 'by calling f(1) the 1 all actually be ignored and it will return the inner function', 'idx': 297}], [{'data': 'no, because f takes no parameters, it returns only a function.', 'idx': 286}, {'data': "function 'f' takes no parameters.", 'idx': 299}, {'data': 'No. Probably will experience an error because the function f does not require a parameter in input. Anyway, the function f does not return a value but an anonymous function.', 'idx': 300}], [{'data': 'To return 2 f()(1) should be called.', 'idx': 273}, {'data': 'No it will return an error, to return a value of two the correct syntax would be f()(1) or let a=f() and a(1)', 'idx': 276}, {'data': 'Since it is a curried function, meaning that we need two function calls in this case, an example that will return 2 will be -> f()(1)', 'idx': 279}], [{'data': 'This will return a function(x) but not 2', 'idx': 278}], [{'data': 'Calling f returns a function (and not a numerical value); moreover f takes no parameters. To get 2, we would need to call f()(1)', 'idx': 280}, {'data': 'f()(1) will return 2. f(1) return a function.', 'idx': 283}, {'data': 'calling f() will return a function. To return 2 the call should be f()(1)', 'idx': 289}], [{'data': 'it should be f()(1)', 'idx': 292}], [{'data': "f(1) returns function of 'number -> number'", 'idx': 302}], [{'data': 'Calling f(1) will return a function. f()(1) will return 2', 'idx': 305}], [{'data': 'The function call is wrong. We should call f()(1). ', 'idx': 294}], [{'data': "Function f doesn't take any arguments.", 'idx': 277}, {'data': 'Calling f(1) produce an error, as the f function takes no arguments.', 'idx': 287}], [{'data': 'It will return a function, and also it contains an error because `f` does not accept the input variable.', 'idx': 284}, {'data': 'f does not accept arguments, and furthermore it returns a function not a number value ', 'idx': 288}], [{'data': 'The function `f` does not take any argument. The function returned by `f()` returns a function taking a single argument. ', 'idx': 293}], [{'data': 'return another function', 'idx': 304}], [{'data': "you can't passe x as argument like that, it needs to be something like f()(1).", 'idx': 295}], [{'data': 'it will return the anonymous incrementer function we see in the method body.', 'idx': 275}], [{'data': 'the value 1 is not passed to the function which returns x+1', 'idx': 274}, {'data': 'f(1) returns a new function that still has to be invoked so: f(1) = function(x) { return x+1; }', 'idx': 282}, {'data': 'f() takes no input. It will return: function(x) {return x+1;}.', 'idx': 290}], [{'data': 'No, it will return the internal anonymous function (function(x) {...}).', 'idx': 291}], [{'data': 'That will return just the function(x) {return x + 1}', 'idx': 298}, {'data': 'It will return a function which will return x+1 when its called with the parameter x.', 'idx': 303}], [{'data': 'It returns the wrapped function', 'idx': 301}]]
silhouette scores
[-0.71847528 -0.12259037  0.          0.01039771 -0.64766403  0.
 -0.16082571  0.07768164  0.27826106 -0.13994246 -0.79734444 -0.05303425
 -0.1123601   0.22314545  0.0437364  -0.00814275 -1.         -0.2245604
  0.          0.          0.          0.          0.         -0.1629979
  0.13137848  0.0413089   0.10329975 -0.15085458  0.          0.
  0.2428155   0.          0.        ]
max: 0.2782610645401486 arg: 8
mean: -0.09535658753842098
min: -1.0 arg: 16
std: 0.2844973123969721


data_affinity/experiment_q08_clean_answers_full.json
[[{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'pass a function and return f+1', 'idx': 338}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.         -0.02750147 -0.1627389   0.25739989  0.          0.14975822
  0.26571413 -0.84541732  0.          0.5838799   0.          0.
  0.18581903  0.00688703  0.11995067  0.38097525  0.52511239 -0.18730945
 -0.22802267  0.16033745  0.12792136  0.61408412 -0.36959523  0.05334736
  0.18174797  0.         -0.18766155  0.52039523  0.         -0.38066685
 -0.19276688 -0.29792294]
max: 0.6140841165620875 arg: 21
mean: 0.03917895998346188
min: -0.8454173223500863 arg: 7
std: 0.3019977357420558


data_affinity/experiment_q08_clean_answers_only_lemma.json
[[{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}], [{'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}, {'data': 'pass a function and return f+1', 'idx': 338}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.          0.00743222  0.23699265  0.10521067 -0.02326207  0.
  0.         -0.1261065  -0.20077868  0.59622943 -0.20608682  0.
 -0.19503658 -0.12019098  0.11451849  0.09397566  0.15770444  0.
  0.05455377  0.24370338 -0.48717069  0.72034419  0.19496071 -0.04023861
  0.16518555  0.          0.         -0.42385068  0.         -0.46035869
  0.29227105 -0.20628445]
max: 0.7203441875792351 arg: 21
mean: 0.015428670909631848
min: -0.4871706876689197 arg: 20
std: 0.2511697921891852


data_affinity/experiment_q08_clean_answers_only_lowercase.json
[[{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}], [{'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}], [{'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}], [{'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}], [{'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Just because', 'idx': 336}], [{'data': 'pass a function and return f+1', 'idx': 338}]]
silhouette scores
[ 0.         -0.00648486  0.11453981 -0.41973113 -0.42861206  0.10226768
  0.         -0.7346702  -0.74294668  0.         -0.04246085  0.53791327
 -0.13749122 -1.         -0.48929538 -0.84822889 -0.39894283 -0.40740915
 -0.26656112 -0.6811875   0.          0.          0.          0.
  0.         -0.13576072  0.          0.          0.          0.
  0.         -0.51984683]
max: 0.5379132652090342 arg: 11
mean: -0.20327839529637795
min: -1.0 arg: 13
std: 0.33404460238593736


data_affinity/experiment_q08_clean_answers_only_stopwords.json
[[{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}, {'data': 'pass a function and return f+1', 'idx': 338}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.          0.11066922 -0.13783211  0.09797523  0.          0.2255897
  0.2281354  -0.59940774  0.06581525  0.55962367  0.          0.
  0.24110825  0.02350085  0.11438944  0.27818803  0.35166379 -0.20041258
 -0.16842444  0.23337711  0.17742581  0.61121765 -0.37645248 -0.12798925
  0.18715108  0.         -0.09841247  0.56300178  0.          0.10651181
 -0.15249604 -0.28846766]
max: 0.6112176487052068 arg: 21
mean: 0.0632952898493969
min: -0.5994077416468195 arg: 7
std: 0.25804931732815234


data_affinity/experiment_q08_clean_answers_stopwords_lemma.json
[[{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'pass a function and return f+1', 'idx': 338}, {'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}], [{'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}, {'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}], [{'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}], [{'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}, {'data': 'we increment x, which is 10, by 1. ', 'idx': 328}, {'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'Just because', 'idx': 336}]]
silhouette scores
[ 0.          0.00555086 -0.16223912  0.35956922  0.          0.16933779
  0.22683885 -0.46788397 -0.04089914  0.5409206   0.          0.
  0.27634266 -0.02970652  0.09681786  0.27510383  0.31486415 -0.19875614
 -0.16907667  0.13825791  0.12792136  0.59575416 -0.36959523 -0.12507342
  0.16152334  0.         -0.18766155  0.54936308  0.          0.1198042
 -0.14231164 -0.23275515]
max: 0.5957541557070788 arg: 21
mean: 0.05725035394996397
min: -0.46788396674549537 arg: 7
std: 0.24800079085847185


data_affinity/experiment_q08_raw.json
[[{'data': "it's the regular expression", 'idx': 308}], [{'data': 'This is indeed correct because we pass 10 as parameter to the function returned by f() which is the anonymous function.', 'idx': 311}, {'data': 'yes, is correct because because first we call f and then we pass the parameter to the anonymous function inside f.', 'idx': 320}, {'data': 'first is called f() and then 10 is passed as parameter to function(x)', 'idx': 326}], [{'data': 'we increment x, which is 10, by 1. ', 'idx': 328}], [{'data': 'f returns a function that adds 1 to the parameter passed to it. We are passing 10. So, 10 + 1 = 11.', 'idx': 330}], [{'data': 'It is correct. f() returns a function and the further calling execute the inner function with the variable x set to 10', 'idx': 339}], [{'data': 'Calling f() returns an anonymous function which can then be called with a numerical argument (e.g., 10) and will return its successor (e.g., 11).', 'idx': 314}], [{'data': 'The first call to f() returns the anonymous function. The second part of the call: f()(10), provides 10 as input to the returned incrementer function. Incrementing 10 yields 11.', 'idx': 309}, {'data': 'f() returns the inner anonymous function, which is then called with 10 as argument, returning 11.', 'idx': 315}, {'data': 'because f() is going to be the inner anonymous function and invoking it with parameter 10 will result in 11', 'idx': 316}], [{'data': 'f() will return the anonymous function and this function takes x as input variable and returns x+1, so that it is 11.', 'idx': 318}], [{'data': 'As said in the previous answer, f() returns a function that takes one argument and return that argument increased by one. Therefore calling f()(10) will increase 10 by 1 and return 11.', 'idx': 319}], [{'data': 'f() will return a function, this function when called with (10) will return 11, so calling f()(10) will execute f and the internal function', 'idx': 323}, {'data': 'f() returns the internal function, and that internal function with input 10 will return 11.', 'idx': 324}, {'data': 'By calling f() we get as result the inner function, which is invoked directly with the (10). Thus, it computes 10 + 1 which is 11', 'idx': 331}, {'data': 'It first call f() wich return the function. With the (10), this function is called, so it returns 10 + 1 that is 11.', 'idx': 332}], [{'data': 'This will correctly return 11 because the value is passed onto the function(x)', 'idx': 312}, {'data': 'Yes because f() will return a function. Calling that function with 10, it will return 11.', 'idx': 317}, {'data': 'yes, this is the right way to call it, call f and passing to the function 10 will return 11.', 'idx': 329}, {'data': 'yes, f return the function in which we apply the number 10 -> 10 + 1 == 11', 'idx': 335}], [{'data': 'Since it a curried function, meaning that in this case it needs two function calls, where the second one takes the parameter of the function returned by f().', 'idx': 313}, {'data': 'Calling f() will return a function that takes an argument and returns the argument plus one.', 'idx': 321}, {'data': 'in this way we are calling correctly the function that is returned by f, that simply increment with one its x argument', 'idx': 322}, {'data': 'Calling the function returned by `f()` will yield a function summing its argument to 1. The result is therefore 2.', 'idx': 327}, {'data': 'Yes. The function f return an anonymous function which, when invoked, return the values taken in input, incremented by 1.', 'idx': 334}], [{'data': 'Just because', 'idx': 336}], [{'data': 'Once f is called it will create a function with one input param. that will be passed with the second parenthesis(10) and will add that 10 to 1', 'idx': 310}, {'data': 'The first call will return the lambda (function(x) {...}) while the second one will call the lambda with value 10.', 'idx': 325}, {'data': "outer function f takes no parameters and inner function 'function' takes one parameter, in this case 10, and returns 10+1.", 'idx': 333}, {'data': 'calling f() return the function, and calling f()(10) return the result of (10+1).', 'idx': 337}, {'data': 'pass a function and return f+1', 'idx': 338}]]
silhouette scores
[ 0.          0.00631197 -0.35163189  0.28089127 -0.12662957  0.04491879
  0.         -0.07712342 -0.28045434  0.13634732  0.          0.
  0.28230654 -0.11137634 -0.23176369  0.12183085  0.08935692 -0.31843323
 -0.10609741  0.0452502   0.          0.31225601  0.         -0.05298744
  0.30022665 -0.06868819 -0.16153498 -0.13331256  0.         -0.11310281
 -0.17953429  0.        ]
max: 0.31225600685397975 arg: 21
mean: -0.02165542675893292
min: -0.35163189390805394 arg: 2
std: 0.165475427223875


data_affinity/experiment_q09_clean_answers_full.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It return a function', 'idx': 356}], [{'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'any f call results in a function', 'idx': 370}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}], [{'data': 'No it will return a function as a value.', 'idx': 352}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[-0.23274243  0.          0.13493309  0.1966008  -0.28740305  0.22024733
 -0.30178949 -0.15814332 -0.29039209  0.29237852  0.          0.
 -0.42106066  0.14773017  0.         -0.12356192  0.32068841  0.
 -0.24889703  0.31446143  0.3560521   0.31446143  0.         -0.31929383
  0.         -0.33990225 -0.19171604 -0.18622749  0.          0.04961065
 -0.26641341  0.          0.07164736]
max: 0.35605210113415586 arg: 20
mean: -0.028749446125737748
min: -0.4210606621592944 arg: 12
std: 0.218255401946101


data_affinity/experiment_q09_clean_answers_only_lemma.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}], [{'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}], [{'data': 'there is no passing function', 'idx': 372}]]
silhouette scores
[-0.34693494  0.          0.03465565  0.21406228 -0.29577113  0.24938952
 -0.10695426 -0.1965892   0.59070018  0.55714771  0.         -0.01455783
 -0.3827211   0.          0.          0.11819028 -0.48588569  0.
  0.         -0.58207476 -0.13029364  0.          0.          0.08318343
  0.         -0.21010962  0.1687457  -0.29947104  0.          0.
 -0.17054462  0.          0.        ]
max: 0.5907001803159732 arg: 8
mean: -0.036540396529533
min: -0.5820747610699541 arg: 19
std: 0.24204094905916076


data_affinity/experiment_q09_clean_answers_only_lowercase.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}, {'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'Returns a function.', 'idx': 347}, {'data': 'No it will return a function as a value.', 'idx': 352}], [{'data': 'It return a function', 'idx': 356}], [{'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}, {'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}], [{'data': 'any f call results in a function', 'idx': 370}, {'data': 'there is no passing function', 'idx': 372}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}]]
silhouette scores
[-0.57453999  0.          0.21816979 -0.19320358  0.         -0.14167031
 -1.          0.28337089  0.          0.7382513   0.         -0.70069905
 -0.33003452  0.         -0.40455295  0.          0.5359798   0.44054319
 -0.61057144  0.43600769  0.15650017  0.87371247  0.         -0.2973316
  0.          0.          0.         -0.07751733  0.         -0.58059551
  0.         -0.68675511 -0.34379509]
max: 0.8737124731390303 arg: 21
mean: -0.06844639945802596
min: -1.0 arg: 6
std: 0.40909441185272555


data_affinity/experiment_q09_clean_answers_only_stopwords.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It return a function', 'idx': 356}], [{'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}], [{'data': 'No it will return a function as a value.', 'idx': 352}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[-0.30042272  0.          0.19040402  0.17450994 -0.26289477  0.2082812
 -0.21344947 -0.21805368 -0.30050354  0.26812308  0.          0.
 -0.3753443   0.13859959  0.         -0.11416432 -0.12672081  0.
  0.          0.36347984 -0.10198395  0.33696683  0.         -0.239141
  0.          0.          0.08422271 -0.07431896  0.          0.
 -0.16711898  0.          0.        ]
max: 0.36347984167157 arg: 19
mean: -0.02210694845651588
min: -0.3753443041717713 arg: 12
std: 0.17851343060658095


data_affinity/experiment_q09_clean_answers_stopwords_lemma.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'It return a function', 'idx': 356}], [{'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}, {'data': 'any f call results in a function', 'idx': 370}, {'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}, {'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}], [{'data': 'Returns a function.', 'idx': 347}], [{'data': 'No it will return a function as a value.', 'idx': 352}], [{'data': 'f() return the inner anonymous function', 'idx': 350}, {'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'there is no passing function', 'idx': 372}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}]]
silhouette scores
[-0.21337161  0.         -0.05609871  0.1966008  -0.43666999  0.22024733
  0.         -0.14830812 -0.31882833  0.31509872  0.          0.
 -0.33603525  0.21938494  0.         -0.13817669  0.32068841  0.
 -0.24889703  0.34703575  0.3560521   0.34703575  0.         -0.31929383
  0.         -0.33990225 -0.19171604 -0.18622749  0.          0.04961065
 -0.26641341  0.          0.07164736]
max: 0.35605210113415586 arg: 20
mean: -0.022925361115057843
min: -0.43666998573824123 arg: 4
std: 0.22102846939579723


data_affinity/experiment_q09_raw.json
[[{'data': "only return a function that needs a input x, so there's no value", 'idx': 342}], [{'data': "It returns a function that can be used to add one to a given value (technically it doesn't return a value but will return a function) ", 'idx': 344}, {'data': "It doesn't return a value but it will return a function.", 'idx': 346}, {'data': 'No it will return a function as a value.', 'idx': 352}], [{'data': 'It returns a function as a value. Since functions can be used as values, the statement is incorrect. ', 'idx': 358}, {'data': "It returns a function, which is a value. Remember higher-order functions and 'functions as values'? Here you have it. Though f does get any function as input!", 'idx': 364}, {'data': "It depends what you consider as 'value'. In my opinion, it returns a function as value, therefore the function f returns a value.", 'idx': 368}, {'data': 'It returns a function which is also a value.', 'idx': 371}], [{'data': "it's not taking any parameter, so it will return nothing", 'idx': 363}], [{'data': 'It returns a function. In javascript, functions can be values. In this case calls to f yield the anonymous incrementer function.', 'idx': 343}, {'data': 'f() does return a value and it is a function value. In this case it returns an anonymous function: function(x) {return x + 1;}', 'idx': 345}], [{'data': 'f() returns the inner anonymous function defined in the body of f();', 'idx': 349}, {'data': 'f() return the inner anonymous function', 'idx': 350}], [{'data': 'yes, it only returns the anonymous function inside f.', 'idx': 354}], [{'data': 'returns an anonymous function ', 'idx': 362}], [{'data': 'Returns a function.', 'idx': 347}, {'data': 'It return a function', 'idx': 356}, {'data': 'it should return an anonymous function', 'idx': 360}, {'data': 'It returns the wrapped function.', 'idx': 369}], [{'data': 'f() returns a first class function', 'idx': 341}, {'data': 'It returns a function. f()(2) will return a value.', 'idx': 351}, {'data': 'As said in HOF.1 a call of f() returns a Function.', 'idx': 353}], [{'data': 'Calling f() returns an anonymous function (which can be stored in a variable or immediately be executed)', 'idx': 348}], [{'data': 'Calling f() actually returns a function that can be used. (e.g. let myf = f(); myf(10);). Functions can be treated as values as well.', 'idx': 355}], [{'data': 'calling f() return a function', 'idx': 357}, {'data': 'Calling `f()` returns a function.', 'idx': 361}, {'data': "Calling f() will return 'function(x)'.", 'idx': 367}], [{'data': "Calling f() returns a function, specifically the function 'function(x) { return x + 1; }'", 'idx': 365}], [{'data': 'any f call results in a function', 'idx': 370}], [{'data': 'Calling f() returns a function as a value', 'idx': 373}], [{'data': 'It actually returns a function: the lambda in the body of f.', 'idx': 359}], [{'data': "It returns the function wich takes a argument 'x' and returns x + 1", 'idx': 366}], [{'data': 'there is no passing function', 'idx': 372}]]
silhouette scores
[-0.27264692  0.          0.18756772  0.12977253 -0.39741284  0.3807254
 -0.19710987  0.          0.61103958  0.59196252 -0.52478373  0.25053059
 -0.37715246  0.          0.          0.02040467 -0.09743652 -0.12925346
  0.         -0.70546037  0.12167185  0.          0.         -0.15555141
  0.          0.          0.15992182 -0.19645692  0.28232845  0.
 -0.27757539  0.          0.        ]
max: 0.611039581381306 arg: 8
mean: -0.018027720508382635
min: -0.7054603734718892 arg: 19
std: 0.27224045829254506


