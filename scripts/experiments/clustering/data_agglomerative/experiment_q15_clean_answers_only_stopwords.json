[
  [
    {
      "data": "What we have done here is transformed a function that has multiple parameters into fultiple functions that use a single parameter.",
      "idx": 615
    },
    {
      "data": "We are decomposing a function of multiple parameters in functions of a single parameter. f accepts only one parameter a, then returns a function, which accepts b. So, f only performs PARTIAL computation. The function returned by f can then be called with multiple different b.",
      "idx": 636
    },
    {
      "data": "It takes a parameter and returns a function which take the other parameters.",
      "idx": 643
    }
  ],
  [
    {
      "data": "the uncurried function take 2 arguments and is turned into 2 functions that take 1 arguments.",
      "idx": 629
    },
    {
      "data": "It does, because now instead of calling one function with 2 parameters we can call 2 functions with a single parameter.",
      "idx": 639
    },
    {
      "data": "Yes. The uncurried version version has 1 function with 2 parameters and the curried version is composed by 2 functions that takes each 1 parameter",
      "idx": 645
    }
  ],
  [
    {
      "data": "Just because",
      "idx": 642
    }
  ],
  [
    {
      "data": "because there is a sequence of nested functions with a single argument",
      "idx": 613
    },
    {
      "data": "The division of one function in two correctly represents currying because it allows to half execute the function but it is missing a semicolon after the return of f",
      "idx": 616
    },
    {
      "data": "Since we can represent the second function as a sequence of multiple functions with one parameter -> f(1)(2) while the first one is only represented by f(1, 2)",
      "idx": 619
    },
    {
      "data": "From a function with multiple arguments to multiple function with one argument. Instead of calling f(1, 3) now you can call f(1)(3). It's half executing a function.",
      "idx": 623
    },
    {
      "data": "Because it splits a multi-argument function into more functions. ",
      "idx": 634
    }
  ],
  [
    {
      "data": "It represents currying as the function f(a,b) has been converted into two functions with each one argument.",
      "idx": 618
    },
    {
      "data": "Yes, we went from calling f with 'f(a,b)' to 'f(a)(b)', effectively turning f into a single argument function (that returns another single argument function). Those two calls produce the same effects.",
      "idx": 621
    },
    {
      "data": "Yes. f(a,b), which is a single multi-parameter function, is Converted into multiple single-argument functions. To obtain the same result as f(a,b), one now needs to call f(a)(b).",
      "idx": 627
    }
  ],
  [
    {
      "data": "two functions, and each function dealing with one argument",
      "idx": 614
    },
    {
      "data": "Yes because from a function that takes two arguments we have two functions with one argument for each",
      "idx": 628
    },
    {
      "data": "Yes, it properly represent currying as a function with two arguments is split into two functions, one for each argument and one function returns the other one.",
      "idx": 637
    }
  ],
  [
    {
      "data": "two functions are invoked with two different params",
      "idx": 632
    }
  ],
  [
    {
      "data": "This is a proper example of currying. The functions can then be called like this in the curried version: f(a)(b). In this case we use an anonymous function to do the currying.",
      "idx": 617
    },
    {
      "data": "The curried version properly represents currying: it transformed a function with multiple arguments to a sequence of functions with one argument each.",
      "idx": 631
    },
    {
      "data": "The function is curried by breaking it down to a series of two functions taking one argument each.",
      "idx": 633
    },
    {
      "data": "Yes, we have to argument and inside the curried function there is an inner function which take the second argument and execute the body",
      "idx": 641
    },
    {
      "data": "in the curried function we decomposing the unhurried function",
      "idx": 644
    }
  ],
  [
    {
      "data": "The 'uncurried' version has two parameters. With currying, we require just one parameter for f and return a function which then takes the second parameter and carries out the same behavior of the uncurried version.",
      "idx": 620
    },
    {
      "data": "instead of passing (a,b) we use a closure to pass 'a' in a first time and returning a function that can take 'b' and still has access to 'a', allowing the computation.",
      "idx": 622
    },
    {
      "data": "In the code above you go from a function that takes two arguments to a function that takes one argument and returns another function taking the second argument. The computation is made in the inner call.",
      "idx": 625
    },
    {
      "data": "The internal function is correctly bound by the environment of the external one.",
      "idx": 630
    },
    {
      "data": "In this case, we go from a two argument function 'f(a,b)' to a curried function wich takes at first one argument and returns another function that will take the second, and finally when it has both arguments, it returns the real output.",
      "idx": 638
    }
  ],
  [
    {
      "data": "Yes, it contains two input parameters and uses currying to deal with them. It can be invoked as `f(1)(2)`.",
      "idx": 624
    },
    {
      "data": "yes, it is correct we can pass values step by step and use curryng properly.",
      "idx": 626
    },
    {
      "data": "yes, this way we can first set a independently, then we can call later the sum function with some value b.",
      "idx": 635
    },
    {
      "data": "Yes. It store the value of the first operand, and then calling the function with the second operand we obtain the sum.",
      "idx": 640
    }
  ]
]
